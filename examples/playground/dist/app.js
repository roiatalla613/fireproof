(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
  var __commonJS = (callback, module) => () => {
    if (!module) {
      module = {exports: {}};
      callback(module.exports, module);
    }
    return module.exports;
  };
  var __exportStar = (target, module, desc) => {
    if (module && typeof module === "object" || typeof module === "function") {
      for (let key of __getOwnPropNames(module))
        if (!__hasOwnProp.call(target, key) && key !== "default")
          __defProp(target, key, {get: () => module[key], enumerable: !(desc = __getOwnPropDesc(module, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule = (module) => {
    return __exportStar(__markAsModule(__defProp(module != null ? __create(__getProtoOf(module)) : {}, "default", module && module.__esModule && "default" in module ? {get: () => module.default, enumerable: true} : {value: module, enumerable: true})), module);
  };
  var __publicField = (obj, key, value) => {
    if (typeof key !== "symbol")
      key += "";
    if (key in obj)
      return __defProp(obj, key, {enumerable: true, configurable: true, writable: true, value});
    return obj[key] = value;
  };

  // ../../node_modules/.pnpm/object-assign@4.1.1/node_modules/object-assign/index.js
  var require_object_assign = __commonJS((exports, module) => {
    /*
    object-assign
    (c) Sindre Sorhus
    @license MIT
    */
    "use strict";
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var propIsEnumerable = Object.prototype.propertyIsEnumerable;
    function toObject(val) {
      if (val === null || val === void 0) {
        throw new TypeError("Object.assign cannot be called with null or undefined");
      }
      return Object(val);
    }
    function shouldUseNative() {
      try {
        if (!Object.assign) {
          return false;
        }
        var test1 = new String("abc");
        test1[5] = "de";
        if (Object.getOwnPropertyNames(test1)[0] === "5") {
          return false;
        }
        var test2 = {};
        for (var i = 0; i < 10; i++) {
          test2["_" + String.fromCharCode(i)] = i;
        }
        var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
          return test2[n];
        });
        if (order2.join("") !== "0123456789") {
          return false;
        }
        var test3 = {};
        "abcdefghijklmnopqrst".split("").forEach(function(letter) {
          test3[letter] = letter;
        });
        if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
          return false;
        }
        return true;
      } catch (err) {
        return false;
      }
    }
    module.exports = shouldUseNative() ? Object.assign : function(target, source) {
      var from;
      var to = toObject(target);
      var symbols;
      for (var s = 1; s < arguments.length; s++) {
        from = Object(arguments[s]);
        for (var key in from) {
          if (hasOwnProperty.call(from, key)) {
            to[key] = from[key];
          }
        }
        if (getOwnPropertySymbols) {
          symbols = getOwnPropertySymbols(from);
          for (var i = 0; i < symbols.length; i++) {
            if (propIsEnumerable.call(from, symbols[i])) {
              to[symbols[i]] = from[symbols[i]];
            }
          }
        }
      }
      return to;
    };
  });

  // ../../node_modules/.pnpm/react@17.0.2/node_modules/react/cjs/react.production.min.js
  var require_react_production_min = __commonJS((exports) => {
    /** @license React v17.0.2
     * react.production.min.js
     *
     * Copyright (c) Facebook, Inc. and its affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    "use strict";
    var l = require_object_assign();
    var n = 60103;
    var p = 60106;
    exports.Fragment = 60107;
    exports.StrictMode = 60108;
    exports.Profiler = 60114;
    var q = 60109;
    var r = 60110;
    var t = 60112;
    exports.Suspense = 60113;
    var u = 60115;
    var v = 60116;
    if (typeof Symbol === "function" && Symbol.for) {
      w = Symbol.for;
      n = w("react.element");
      p = w("react.portal");
      exports.Fragment = w("react.fragment");
      exports.StrictMode = w("react.strict_mode");
      exports.Profiler = w("react.profiler");
      q = w("react.provider");
      r = w("react.context");
      t = w("react.forward_ref");
      exports.Suspense = w("react.suspense");
      u = w("react.memo");
      v = w("react.lazy");
    }
    var w;
    var x = typeof Symbol === "function" && Symbol.iterator;
    function y(a) {
      if (a === null || typeof a !== "object")
        return null;
      a = x && a[x] || a["@@iterator"];
      return typeof a === "function" ? a : null;
    }
    function z(a) {
      for (var b = "https://reactjs.org/docs/error-decoder.html?invariant=" + a, c = 1; c < arguments.length; c++)
        b += "&args[]=" + encodeURIComponent(arguments[c]);
      return "Minified React error #" + a + "; visit " + b + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
    }
    var A = {isMounted: function() {
      return false;
    }, enqueueForceUpdate: function() {
    }, enqueueReplaceState: function() {
    }, enqueueSetState: function() {
    }};
    var B = {};
    function C(a, b, c) {
      this.props = a;
      this.context = b;
      this.refs = B;
      this.updater = c || A;
    }
    C.prototype.isReactComponent = {};
    C.prototype.setState = function(a, b) {
      if (typeof a !== "object" && typeof a !== "function" && a != null)
        throw Error(z(85));
      this.updater.enqueueSetState(this, a, b, "setState");
    };
    C.prototype.forceUpdate = function(a) {
      this.updater.enqueueForceUpdate(this, a, "forceUpdate");
    };
    function D() {
    }
    D.prototype = C.prototype;
    function E(a, b, c) {
      this.props = a;
      this.context = b;
      this.refs = B;
      this.updater = c || A;
    }
    var F = E.prototype = new D();
    F.constructor = E;
    l(F, C.prototype);
    F.isPureReactComponent = true;
    var G = {current: null};
    var H = Object.prototype.hasOwnProperty;
    var I = {key: true, ref: true, __self: true, __source: true};
    function J(a, b, c) {
      var e, d = {}, k = null, h = null;
      if (b != null)
        for (e in b.ref !== void 0 && (h = b.ref), b.key !== void 0 && (k = "" + b.key), b)
          H.call(b, e) && !I.hasOwnProperty(e) && (d[e] = b[e]);
      var g = arguments.length - 2;
      if (g === 1)
        d.children = c;
      else if (1 < g) {
        for (var f = Array(g), m = 0; m < g; m++)
          f[m] = arguments[m + 2];
        d.children = f;
      }
      if (a && a.defaultProps)
        for (e in g = a.defaultProps, g)
          d[e] === void 0 && (d[e] = g[e]);
      return {$$typeof: n, type: a, key: k, ref: h, props: d, _owner: G.current};
    }
    function K(a, b) {
      return {$$typeof: n, type: a.type, key: b, ref: a.ref, props: a.props, _owner: a._owner};
    }
    function L(a) {
      return typeof a === "object" && a !== null && a.$$typeof === n;
    }
    function escape(a) {
      var b = {"=": "=0", ":": "=2"};
      return "$" + a.replace(/[=:]/g, function(a2) {
        return b[a2];
      });
    }
    var M = /\/+/g;
    function N(a, b) {
      return typeof a === "object" && a !== null && a.key != null ? escape("" + a.key) : b.toString(36);
    }
    function O(a, b, c, e, d) {
      var k = typeof a;
      if (k === "undefined" || k === "boolean")
        a = null;
      var h = false;
      if (a === null)
        h = true;
      else
        switch (k) {
          case "string":
          case "number":
            h = true;
            break;
          case "object":
            switch (a.$$typeof) {
              case n:
              case p:
                h = true;
            }
        }
      if (h)
        return h = a, d = d(h), a = e === "" ? "." + N(h, 0) : e, Array.isArray(d) ? (c = "", a != null && (c = a.replace(M, "$&/") + "/"), O(d, b, c, "", function(a2) {
          return a2;
        })) : d != null && (L(d) && (d = K(d, c + (!d.key || h && h.key === d.key ? "" : ("" + d.key).replace(M, "$&/") + "/") + a)), b.push(d)), 1;
      h = 0;
      e = e === "" ? "." : e + ":";
      if (Array.isArray(a))
        for (var g = 0; g < a.length; g++) {
          k = a[g];
          var f = e + N(k, g);
          h += O(k, b, c, f, d);
        }
      else if (f = y(a), typeof f === "function")
        for (a = f.call(a), g = 0; !(k = a.next()).done; )
          k = k.value, f = e + N(k, g++), h += O(k, b, c, f, d);
      else if (k === "object")
        throw b = "" + a, Error(z(31, b === "[object Object]" ? "object with keys {" + Object.keys(a).join(", ") + "}" : b));
      return h;
    }
    function P(a, b, c) {
      if (a == null)
        return a;
      var e = [], d = 0;
      O(a, e, "", "", function(a2) {
        return b.call(c, a2, d++);
      });
      return e;
    }
    function Q(a) {
      if (a._status === -1) {
        var b = a._result;
        b = b();
        a._status = 0;
        a._result = b;
        b.then(function(b2) {
          a._status === 0 && (b2 = b2.default, a._status = 1, a._result = b2);
        }, function(b2) {
          a._status === 0 && (a._status = 2, a._result = b2);
        });
      }
      if (a._status === 1)
        return a._result;
      throw a._result;
    }
    var R = {current: null};
    function S() {
      var a = R.current;
      if (a === null)
        throw Error(z(321));
      return a;
    }
    var T = {ReactCurrentDispatcher: R, ReactCurrentBatchConfig: {transition: 0}, ReactCurrentOwner: G, IsSomeRendererActing: {current: false}, assign: l};
    exports.Children = {map: P, forEach: function(a, b, c) {
      P(a, function() {
        b.apply(this, arguments);
      }, c);
    }, count: function(a) {
      var b = 0;
      P(a, function() {
        b++;
      });
      return b;
    }, toArray: function(a) {
      return P(a, function(a2) {
        return a2;
      }) || [];
    }, only: function(a) {
      if (!L(a))
        throw Error(z(143));
      return a;
    }};
    exports.Component = C;
    exports.PureComponent = E;
    exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = T;
    exports.cloneElement = function(a, b, c) {
      if (a === null || a === void 0)
        throw Error(z(267, a));
      var e = l({}, a.props), d = a.key, k = a.ref, h = a._owner;
      if (b != null) {
        b.ref !== void 0 && (k = b.ref, h = G.current);
        b.key !== void 0 && (d = "" + b.key);
        if (a.type && a.type.defaultProps)
          var g = a.type.defaultProps;
        for (f in b)
          H.call(b, f) && !I.hasOwnProperty(f) && (e[f] = b[f] === void 0 && g !== void 0 ? g[f] : b[f]);
      }
      var f = arguments.length - 2;
      if (f === 1)
        e.children = c;
      else if (1 < f) {
        g = Array(f);
        for (var m = 0; m < f; m++)
          g[m] = arguments[m + 2];
        e.children = g;
      }
      return {
        $$typeof: n,
        type: a.type,
        key: d,
        ref: k,
        props: e,
        _owner: h
      };
    };
    exports.createContext = function(a, b) {
      b === void 0 && (b = null);
      a = {$$typeof: r, _calculateChangedBits: b, _currentValue: a, _currentValue2: a, _threadCount: 0, Provider: null, Consumer: null};
      a.Provider = {$$typeof: q, _context: a};
      return a.Consumer = a;
    };
    exports.createElement = J;
    exports.createFactory = function(a) {
      var b = J.bind(null, a);
      b.type = a;
      return b;
    };
    exports.createRef = function() {
      return {current: null};
    };
    exports.forwardRef = function(a) {
      return {$$typeof: t, render: a};
    };
    exports.isValidElement = L;
    exports.lazy = function(a) {
      return {$$typeof: v, _payload: {_status: -1, _result: a}, _init: Q};
    };
    exports.memo = function(a, b) {
      return {$$typeof: u, type: a, compare: b === void 0 ? null : b};
    };
    exports.useCallback = function(a, b) {
      return S().useCallback(a, b);
    };
    exports.useContext = function(a, b) {
      return S().useContext(a, b);
    };
    exports.useDebugValue = function() {
    };
    exports.useEffect = function(a, b) {
      return S().useEffect(a, b);
    };
    exports.useImperativeHandle = function(a, b, c) {
      return S().useImperativeHandle(a, b, c);
    };
    exports.useLayoutEffect = function(a, b) {
      return S().useLayoutEffect(a, b);
    };
    exports.useMemo = function(a, b) {
      return S().useMemo(a, b);
    };
    exports.useReducer = function(a, b, c) {
      return S().useReducer(a, b, c);
    };
    exports.useRef = function(a) {
      return S().useRef(a);
    };
    exports.useState = function(a) {
      return S().useState(a);
    };
    exports.version = "17.0.2";
  });

  // ../../node_modules/.pnpm/react@17.0.2/node_modules/react/index.js
  var require_react = __commonJS((exports, module) => {
    "use strict";
    if (true) {
      module.exports = require_react_production_min();
    } else {
      module.exports = null;
    }
  });

  // ../../node_modules/.pnpm/scheduler@0.20.2/node_modules/scheduler/cjs/scheduler.production.min.js
  var require_scheduler_production_min = __commonJS((exports) => {
    /** @license React v0.20.2
     * scheduler.production.min.js
     *
     * Copyright (c) Facebook, Inc. and its affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    "use strict";
    var f;
    var g;
    var h;
    var k;
    if (typeof performance === "object" && typeof performance.now === "function") {
      l = performance;
      exports.unstable_now = function() {
        return l.now();
      };
    } else {
      p = Date, q = p.now();
      exports.unstable_now = function() {
        return p.now() - q;
      };
    }
    var l;
    var p;
    var q;
    if (typeof window === "undefined" || typeof MessageChannel !== "function") {
      t = null, u = null, w = function() {
        if (t !== null)
          try {
            var a = exports.unstable_now();
            t(true, a);
            t = null;
          } catch (b) {
            throw setTimeout(w, 0), b;
          }
      };
      f = function(a) {
        t !== null ? setTimeout(f, 0, a) : (t = a, setTimeout(w, 0));
      };
      g = function(a, b) {
        u = setTimeout(a, b);
      };
      h = function() {
        clearTimeout(u);
      };
      exports.unstable_shouldYield = function() {
        return false;
      };
      k = exports.unstable_forceFrameRate = function() {
      };
    } else {
      x = window.setTimeout, y = window.clearTimeout;
      if (typeof console !== "undefined") {
        z = window.cancelAnimationFrame;
        typeof window.requestAnimationFrame !== "function" && console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills");
        typeof z !== "function" && console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills");
      }
      A = false, B = null, C = -1, D = 5, E = 0;
      exports.unstable_shouldYield = function() {
        return exports.unstable_now() >= E;
      };
      k = function() {
      };
      exports.unstable_forceFrameRate = function(a) {
        0 > a || 125 < a ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : D = 0 < a ? Math.floor(1e3 / a) : 5;
      };
      F = new MessageChannel(), G = F.port2;
      F.port1.onmessage = function() {
        if (B !== null) {
          var a = exports.unstable_now();
          E = a + D;
          try {
            B(true, a) ? G.postMessage(null) : (A = false, B = null);
          } catch (b) {
            throw G.postMessage(null), b;
          }
        } else
          A = false;
      };
      f = function(a) {
        B = a;
        A || (A = true, G.postMessage(null));
      };
      g = function(a, b) {
        C = x(function() {
          a(exports.unstable_now());
        }, b);
      };
      h = function() {
        y(C);
        C = -1;
      };
    }
    var t;
    var u;
    var w;
    var x;
    var y;
    var z;
    var A;
    var B;
    var C;
    var D;
    var E;
    var F;
    var G;
    function H(a, b) {
      var c = a.length;
      a.push(b);
      a:
        for (; ; ) {
          var d = c - 1 >>> 1, e = a[d];
          if (e !== void 0 && 0 < I(e, b))
            a[d] = b, a[c] = e, c = d;
          else
            break a;
        }
    }
    function J(a) {
      a = a[0];
      return a === void 0 ? null : a;
    }
    function K(a) {
      var b = a[0];
      if (b !== void 0) {
        var c = a.pop();
        if (c !== b) {
          a[0] = c;
          a:
            for (var d = 0, e = a.length; d < e; ) {
              var m = 2 * (d + 1) - 1, n = a[m], v = m + 1, r = a[v];
              if (n !== void 0 && 0 > I(n, c))
                r !== void 0 && 0 > I(r, n) ? (a[d] = r, a[v] = c, d = v) : (a[d] = n, a[m] = c, d = m);
              else if (r !== void 0 && 0 > I(r, c))
                a[d] = r, a[v] = c, d = v;
              else
                break a;
            }
        }
        return b;
      }
      return null;
    }
    function I(a, b) {
      var c = a.sortIndex - b.sortIndex;
      return c !== 0 ? c : a.id - b.id;
    }
    var L = [];
    var M = [];
    var N = 1;
    var O = null;
    var P = 3;
    var Q = false;
    var R = false;
    var S = false;
    function T(a) {
      for (var b = J(M); b !== null; ) {
        if (b.callback === null)
          K(M);
        else if (b.startTime <= a)
          K(M), b.sortIndex = b.expirationTime, H(L, b);
        else
          break;
        b = J(M);
      }
    }
    function U(a) {
      S = false;
      T(a);
      if (!R)
        if (J(L) !== null)
          R = true, f(V);
        else {
          var b = J(M);
          b !== null && g(U, b.startTime - a);
        }
    }
    function V(a, b) {
      R = false;
      S && (S = false, h());
      Q = true;
      var c = P;
      try {
        T(b);
        for (O = J(L); O !== null && (!(O.expirationTime > b) || a && !exports.unstable_shouldYield()); ) {
          var d = O.callback;
          if (typeof d === "function") {
            O.callback = null;
            P = O.priorityLevel;
            var e = d(O.expirationTime <= b);
            b = exports.unstable_now();
            typeof e === "function" ? O.callback = e : O === J(L) && K(L);
            T(b);
          } else
            K(L);
          O = J(L);
        }
        if (O !== null)
          var m = true;
        else {
          var n = J(M);
          n !== null && g(U, n.startTime - b);
          m = false;
        }
        return m;
      } finally {
        O = null, P = c, Q = false;
      }
    }
    var W = k;
    exports.unstable_IdlePriority = 5;
    exports.unstable_ImmediatePriority = 1;
    exports.unstable_LowPriority = 4;
    exports.unstable_NormalPriority = 3;
    exports.unstable_Profiling = null;
    exports.unstable_UserBlockingPriority = 2;
    exports.unstable_cancelCallback = function(a) {
      a.callback = null;
    };
    exports.unstable_continueExecution = function() {
      R || Q || (R = true, f(V));
    };
    exports.unstable_getCurrentPriorityLevel = function() {
      return P;
    };
    exports.unstable_getFirstCallbackNode = function() {
      return J(L);
    };
    exports.unstable_next = function(a) {
      switch (P) {
        case 1:
        case 2:
        case 3:
          var b = 3;
          break;
        default:
          b = P;
      }
      var c = P;
      P = b;
      try {
        return a();
      } finally {
        P = c;
      }
    };
    exports.unstable_pauseExecution = function() {
    };
    exports.unstable_requestPaint = W;
    exports.unstable_runWithPriority = function(a, b) {
      switch (a) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          a = 3;
      }
      var c = P;
      P = a;
      try {
        return b();
      } finally {
        P = c;
      }
    };
    exports.unstable_scheduleCallback = function(a, b, c) {
      var d = exports.unstable_now();
      typeof c === "object" && c !== null ? (c = c.delay, c = typeof c === "number" && 0 < c ? d + c : d) : c = d;
      switch (a) {
        case 1:
          var e = -1;
          break;
        case 2:
          e = 250;
          break;
        case 5:
          e = 1073741823;
          break;
        case 4:
          e = 1e4;
          break;
        default:
          e = 5e3;
      }
      e = c + e;
      a = {id: N++, callback: b, priorityLevel: a, startTime: c, expirationTime: e, sortIndex: -1};
      c > d ? (a.sortIndex = c, H(M, a), J(L) === null && a === J(M) && (S ? h() : S = true, g(U, c - d))) : (a.sortIndex = e, H(L, a), R || Q || (R = true, f(V)));
      return a;
    };
    exports.unstable_wrapCallback = function(a) {
      var b = P;
      return function() {
        var c = P;
        P = b;
        try {
          return a.apply(this, arguments);
        } finally {
          P = c;
        }
      };
    };
  });

  // ../../node_modules/.pnpm/scheduler@0.20.2/node_modules/scheduler/index.js
  var require_scheduler = __commonJS((exports, module) => {
    "use strict";
    if (true) {
      module.exports = require_scheduler_production_min();
    } else {
      module.exports = null;
    }
  });

  // ../../node_modules/.pnpm/react-dom@17.0.2_react@17.0.2/node_modules/react-dom/cjs/react-dom.production.min.js
  var require_react_dom_production_min = __commonJS((exports) => {
    /** @license React v17.0.2
     * react-dom.production.min.js
     *
     * Copyright (c) Facebook, Inc. and its affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    "use strict";
    var aa = require_react();
    var m = require_object_assign();
    var r = require_scheduler();
    function y(a) {
      for (var b = "https://reactjs.org/docs/error-decoder.html?invariant=" + a, c = 1; c < arguments.length; c++)
        b += "&args[]=" + encodeURIComponent(arguments[c]);
      return "Minified React error #" + a + "; visit " + b + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
    }
    if (!aa)
      throw Error(y(227));
    var ba = new Set();
    var ca = {};
    function da(a, b) {
      ea(a, b);
      ea(a + "Capture", b);
    }
    function ea(a, b) {
      ca[a] = b;
      for (a = 0; a < b.length; a++)
        ba.add(b[a]);
    }
    var fa = !(typeof window === "undefined" || typeof window.document === "undefined" || typeof window.document.createElement === "undefined");
    var ha = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/;
    var ia = Object.prototype.hasOwnProperty;
    var ja = {};
    var ka = {};
    function la(a) {
      if (ia.call(ka, a))
        return true;
      if (ia.call(ja, a))
        return false;
      if (ha.test(a))
        return ka[a] = true;
      ja[a] = true;
      return false;
    }
    function ma(a, b, c, d) {
      if (c !== null && c.type === 0)
        return false;
      switch (typeof b) {
        case "function":
        case "symbol":
          return true;
        case "boolean":
          if (d)
            return false;
          if (c !== null)
            return !c.acceptsBooleans;
          a = a.toLowerCase().slice(0, 5);
          return a !== "data-" && a !== "aria-";
        default:
          return false;
      }
    }
    function na(a, b, c, d) {
      if (b === null || typeof b === "undefined" || ma(a, b, c, d))
        return true;
      if (d)
        return false;
      if (c !== null)
        switch (c.type) {
          case 3:
            return !b;
          case 4:
            return b === false;
          case 5:
            return isNaN(b);
          case 6:
            return isNaN(b) || 1 > b;
        }
      return false;
    }
    function B(a, b, c, d, e, f, g) {
      this.acceptsBooleans = b === 2 || b === 3 || b === 4;
      this.attributeName = d;
      this.attributeNamespace = e;
      this.mustUseProperty = c;
      this.propertyName = a;
      this.type = b;
      this.sanitizeURL = f;
      this.removeEmptyString = g;
    }
    var D = {};
    "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a) {
      D[a] = new B(a, 0, false, a, null, false, false);
    });
    [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a) {
      var b = a[0];
      D[b] = new B(b, 1, false, a[1], null, false, false);
    });
    ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a) {
      D[a] = new B(a, 2, false, a.toLowerCase(), null, false, false);
    });
    ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a) {
      D[a] = new B(a, 2, false, a, null, false, false);
    });
    "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a) {
      D[a] = new B(a, 3, false, a.toLowerCase(), null, false, false);
    });
    ["checked", "multiple", "muted", "selected"].forEach(function(a) {
      D[a] = new B(a, 3, true, a, null, false, false);
    });
    ["capture", "download"].forEach(function(a) {
      D[a] = new B(a, 4, false, a, null, false, false);
    });
    ["cols", "rows", "size", "span"].forEach(function(a) {
      D[a] = new B(a, 6, false, a, null, false, false);
    });
    ["rowSpan", "start"].forEach(function(a) {
      D[a] = new B(a, 5, false, a.toLowerCase(), null, false, false);
    });
    var oa = /[\-:]([a-z])/g;
    function pa(a) {
      return a[1].toUpperCase();
    }
    "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a) {
      var b = a.replace(oa, pa);
      D[b] = new B(b, 1, false, a, null, false, false);
    });
    "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a) {
      var b = a.replace(oa, pa);
      D[b] = new B(b, 1, false, a, "http://www.w3.org/1999/xlink", false, false);
    });
    ["xml:base", "xml:lang", "xml:space"].forEach(function(a) {
      var b = a.replace(oa, pa);
      D[b] = new B(b, 1, false, a, "http://www.w3.org/XML/1998/namespace", false, false);
    });
    ["tabIndex", "crossOrigin"].forEach(function(a) {
      D[a] = new B(a, 1, false, a.toLowerCase(), null, false, false);
    });
    D.xlinkHref = new B("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
    ["src", "href", "action", "formAction"].forEach(function(a) {
      D[a] = new B(a, 1, false, a.toLowerCase(), null, true, true);
    });
    function qa(a, b, c, d) {
      var e = D.hasOwnProperty(b) ? D[b] : null;
      var f = e !== null ? e.type === 0 : d ? false : !(2 < b.length) || b[0] !== "o" && b[0] !== "O" || b[1] !== "n" && b[1] !== "N" ? false : true;
      f || (na(b, c, e, d) && (c = null), d || e === null ? la(b) && (c === null ? a.removeAttribute(b) : a.setAttribute(b, "" + c)) : e.mustUseProperty ? a[e.propertyName] = c === null ? e.type === 3 ? false : "" : c : (b = e.attributeName, d = e.attributeNamespace, c === null ? a.removeAttribute(b) : (e = e.type, c = e === 3 || e === 4 && c === true ? "" : "" + c, d ? a.setAttributeNS(d, b, c) : a.setAttribute(b, c))));
    }
    var ra = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    var sa = 60103;
    var ta = 60106;
    var ua = 60107;
    var wa = 60108;
    var xa = 60114;
    var ya = 60109;
    var za = 60110;
    var Aa = 60112;
    var Ba = 60113;
    var Ca = 60120;
    var Da = 60115;
    var Ea = 60116;
    var Fa = 60121;
    var Ga = 60128;
    var Ha = 60129;
    var Ia = 60130;
    var Ja = 60131;
    if (typeof Symbol === "function" && Symbol.for) {
      E = Symbol.for;
      sa = E("react.element");
      ta = E("react.portal");
      ua = E("react.fragment");
      wa = E("react.strict_mode");
      xa = E("react.profiler");
      ya = E("react.provider");
      za = E("react.context");
      Aa = E("react.forward_ref");
      Ba = E("react.suspense");
      Ca = E("react.suspense_list");
      Da = E("react.memo");
      Ea = E("react.lazy");
      Fa = E("react.block");
      E("react.scope");
      Ga = E("react.opaque.id");
      Ha = E("react.debug_trace_mode");
      Ia = E("react.offscreen");
      Ja = E("react.legacy_hidden");
    }
    var E;
    var Ka = typeof Symbol === "function" && Symbol.iterator;
    function La(a) {
      if (a === null || typeof a !== "object")
        return null;
      a = Ka && a[Ka] || a["@@iterator"];
      return typeof a === "function" ? a : null;
    }
    var Ma;
    function Na(a) {
      if (Ma === void 0)
        try {
          throw Error();
        } catch (c) {
          var b = c.stack.trim().match(/\n( *(at )?)/);
          Ma = b && b[1] || "";
        }
      return "\n" + Ma + a;
    }
    var Oa = false;
    function Pa(a, b) {
      if (!a || Oa)
        return "";
      Oa = true;
      var c = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      try {
        if (b)
          if (b = function() {
            throw Error();
          }, Object.defineProperty(b.prototype, "props", {set: function() {
            throw Error();
          }}), typeof Reflect === "object" && Reflect.construct) {
            try {
              Reflect.construct(b, []);
            } catch (k) {
              var d = k;
            }
            Reflect.construct(a, [], b);
          } else {
            try {
              b.call();
            } catch (k) {
              d = k;
            }
            a.call(b.prototype);
          }
        else {
          try {
            throw Error();
          } catch (k) {
            d = k;
          }
          a();
        }
      } catch (k) {
        if (k && d && typeof k.stack === "string") {
          for (var e = k.stack.split("\n"), f = d.stack.split("\n"), g = e.length - 1, h = f.length - 1; 1 <= g && 0 <= h && e[g] !== f[h]; )
            h--;
          for (; 1 <= g && 0 <= h; g--, h--)
            if (e[g] !== f[h]) {
              if (g !== 1 || h !== 1) {
                do
                  if (g--, h--, 0 > h || e[g] !== f[h])
                    return "\n" + e[g].replace(" at new ", " at ");
                while (1 <= g && 0 <= h);
              }
              break;
            }
        }
      } finally {
        Oa = false, Error.prepareStackTrace = c;
      }
      return (a = a ? a.displayName || a.name : "") ? Na(a) : "";
    }
    function Qa(a) {
      switch (a.tag) {
        case 5:
          return Na(a.type);
        case 16:
          return Na("Lazy");
        case 13:
          return Na("Suspense");
        case 19:
          return Na("SuspenseList");
        case 0:
        case 2:
        case 15:
          return a = Pa(a.type, false), a;
        case 11:
          return a = Pa(a.type.render, false), a;
        case 22:
          return a = Pa(a.type._render, false), a;
        case 1:
          return a = Pa(a.type, true), a;
        default:
          return "";
      }
    }
    function Ra(a) {
      if (a == null)
        return null;
      if (typeof a === "function")
        return a.displayName || a.name || null;
      if (typeof a === "string")
        return a;
      switch (a) {
        case ua:
          return "Fragment";
        case ta:
          return "Portal";
        case xa:
          return "Profiler";
        case wa:
          return "StrictMode";
        case Ba:
          return "Suspense";
        case Ca:
          return "SuspenseList";
      }
      if (typeof a === "object")
        switch (a.$$typeof) {
          case za:
            return (a.displayName || "Context") + ".Consumer";
          case ya:
            return (a._context.displayName || "Context") + ".Provider";
          case Aa:
            var b = a.render;
            b = b.displayName || b.name || "";
            return a.displayName || (b !== "" ? "ForwardRef(" + b + ")" : "ForwardRef");
          case Da:
            return Ra(a.type);
          case Fa:
            return Ra(a._render);
          case Ea:
            b = a._payload;
            a = a._init;
            try {
              return Ra(a(b));
            } catch (c) {
            }
        }
      return null;
    }
    function Sa(a) {
      switch (typeof a) {
        case "boolean":
        case "number":
        case "object":
        case "string":
        case "undefined":
          return a;
        default:
          return "";
      }
    }
    function Ta(a) {
      var b = a.type;
      return (a = a.nodeName) && a.toLowerCase() === "input" && (b === "checkbox" || b === "radio");
    }
    function Ua(a) {
      var b = Ta(a) ? "checked" : "value", c = Object.getOwnPropertyDescriptor(a.constructor.prototype, b), d = "" + a[b];
      if (!a.hasOwnProperty(b) && typeof c !== "undefined" && typeof c.get === "function" && typeof c.set === "function") {
        var e = c.get, f = c.set;
        Object.defineProperty(a, b, {configurable: true, get: function() {
          return e.call(this);
        }, set: function(a2) {
          d = "" + a2;
          f.call(this, a2);
        }});
        Object.defineProperty(a, b, {enumerable: c.enumerable});
        return {getValue: function() {
          return d;
        }, setValue: function(a2) {
          d = "" + a2;
        }, stopTracking: function() {
          a._valueTracker = null;
          delete a[b];
        }};
      }
    }
    function Va(a) {
      a._valueTracker || (a._valueTracker = Ua(a));
    }
    function Wa(a) {
      if (!a)
        return false;
      var b = a._valueTracker;
      if (!b)
        return true;
      var c = b.getValue();
      var d = "";
      a && (d = Ta(a) ? a.checked ? "true" : "false" : a.value);
      a = d;
      return a !== c ? (b.setValue(a), true) : false;
    }
    function Xa(a) {
      a = a || (typeof document !== "undefined" ? document : void 0);
      if (typeof a === "undefined")
        return null;
      try {
        return a.activeElement || a.body;
      } catch (b) {
        return a.body;
      }
    }
    function Ya(a, b) {
      var c = b.checked;
      return m({}, b, {defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: c != null ? c : a._wrapperState.initialChecked});
    }
    function Za(a, b) {
      var c = b.defaultValue == null ? "" : b.defaultValue, d = b.checked != null ? b.checked : b.defaultChecked;
      c = Sa(b.value != null ? b.value : c);
      a._wrapperState = {initialChecked: d, initialValue: c, controlled: b.type === "checkbox" || b.type === "radio" ? b.checked != null : b.value != null};
    }
    function $a(a, b) {
      b = b.checked;
      b != null && qa(a, "checked", b, false);
    }
    function ab(a, b) {
      $a(a, b);
      var c = Sa(b.value), d = b.type;
      if (c != null)
        if (d === "number") {
          if (c === 0 && a.value === "" || a.value != c)
            a.value = "" + c;
        } else
          a.value !== "" + c && (a.value = "" + c);
      else if (d === "submit" || d === "reset") {
        a.removeAttribute("value");
        return;
      }
      b.hasOwnProperty("value") ? bb(a, b.type, c) : b.hasOwnProperty("defaultValue") && bb(a, b.type, Sa(b.defaultValue));
      b.checked == null && b.defaultChecked != null && (a.defaultChecked = !!b.defaultChecked);
    }
    function cb(a, b, c) {
      if (b.hasOwnProperty("value") || b.hasOwnProperty("defaultValue")) {
        var d = b.type;
        if (!(d !== "submit" && d !== "reset" || b.value !== void 0 && b.value !== null))
          return;
        b = "" + a._wrapperState.initialValue;
        c || b === a.value || (a.value = b);
        a.defaultValue = b;
      }
      c = a.name;
      c !== "" && (a.name = "");
      a.defaultChecked = !!a._wrapperState.initialChecked;
      c !== "" && (a.name = c);
    }
    function bb(a, b, c) {
      if (b !== "number" || Xa(a.ownerDocument) !== a)
        c == null ? a.defaultValue = "" + a._wrapperState.initialValue : a.defaultValue !== "" + c && (a.defaultValue = "" + c);
    }
    function db(a) {
      var b = "";
      aa.Children.forEach(a, function(a2) {
        a2 != null && (b += a2);
      });
      return b;
    }
    function eb(a, b) {
      a = m({children: void 0}, b);
      if (b = db(b.children))
        a.children = b;
      return a;
    }
    function fb(a, b, c, d) {
      a = a.options;
      if (b) {
        b = {};
        for (var e = 0; e < c.length; e++)
          b["$" + c[e]] = true;
        for (c = 0; c < a.length; c++)
          e = b.hasOwnProperty("$" + a[c].value), a[c].selected !== e && (a[c].selected = e), e && d && (a[c].defaultSelected = true);
      } else {
        c = "" + Sa(c);
        b = null;
        for (e = 0; e < a.length; e++) {
          if (a[e].value === c) {
            a[e].selected = true;
            d && (a[e].defaultSelected = true);
            return;
          }
          b !== null || a[e].disabled || (b = a[e]);
        }
        b !== null && (b.selected = true);
      }
    }
    function gb(a, b) {
      if (b.dangerouslySetInnerHTML != null)
        throw Error(y(91));
      return m({}, b, {value: void 0, defaultValue: void 0, children: "" + a._wrapperState.initialValue});
    }
    function hb(a, b) {
      var c = b.value;
      if (c == null) {
        c = b.children;
        b = b.defaultValue;
        if (c != null) {
          if (b != null)
            throw Error(y(92));
          if (Array.isArray(c)) {
            if (!(1 >= c.length))
              throw Error(y(93));
            c = c[0];
          }
          b = c;
        }
        b == null && (b = "");
        c = b;
      }
      a._wrapperState = {initialValue: Sa(c)};
    }
    function ib(a, b) {
      var c = Sa(b.value), d = Sa(b.defaultValue);
      c != null && (c = "" + c, c !== a.value && (a.value = c), b.defaultValue == null && a.defaultValue !== c && (a.defaultValue = c));
      d != null && (a.defaultValue = "" + d);
    }
    function jb(a) {
      var b = a.textContent;
      b === a._wrapperState.initialValue && b !== "" && b !== null && (a.value = b);
    }
    var kb = {html: "http://www.w3.org/1999/xhtml", mathml: "http://www.w3.org/1998/Math/MathML", svg: "http://www.w3.org/2000/svg"};
    function lb(a) {
      switch (a) {
        case "svg":
          return "http://www.w3.org/2000/svg";
        case "math":
          return "http://www.w3.org/1998/Math/MathML";
        default:
          return "http://www.w3.org/1999/xhtml";
      }
    }
    function mb(a, b) {
      return a == null || a === "http://www.w3.org/1999/xhtml" ? lb(b) : a === "http://www.w3.org/2000/svg" && b === "foreignObject" ? "http://www.w3.org/1999/xhtml" : a;
    }
    var nb;
    var ob = function(a) {
      return typeof MSApp !== "undefined" && MSApp.execUnsafeLocalFunction ? function(b, c, d, e) {
        MSApp.execUnsafeLocalFunction(function() {
          return a(b, c, d, e);
        });
      } : a;
    }(function(a, b) {
      if (a.namespaceURI !== kb.svg || "innerHTML" in a)
        a.innerHTML = b;
      else {
        nb = nb || document.createElement("div");
        nb.innerHTML = "<svg>" + b.valueOf().toString() + "</svg>";
        for (b = nb.firstChild; a.firstChild; )
          a.removeChild(a.firstChild);
        for (; b.firstChild; )
          a.appendChild(b.firstChild);
      }
    });
    function pb(a, b) {
      if (b) {
        var c = a.firstChild;
        if (c && c === a.lastChild && c.nodeType === 3) {
          c.nodeValue = b;
          return;
        }
      }
      a.textContent = b;
    }
    var qb = {
      animationIterationCount: true,
      borderImageOutset: true,
      borderImageSlice: true,
      borderImageWidth: true,
      boxFlex: true,
      boxFlexGroup: true,
      boxOrdinalGroup: true,
      columnCount: true,
      columns: true,
      flex: true,
      flexGrow: true,
      flexPositive: true,
      flexShrink: true,
      flexNegative: true,
      flexOrder: true,
      gridArea: true,
      gridRow: true,
      gridRowEnd: true,
      gridRowSpan: true,
      gridRowStart: true,
      gridColumn: true,
      gridColumnEnd: true,
      gridColumnSpan: true,
      gridColumnStart: true,
      fontWeight: true,
      lineClamp: true,
      lineHeight: true,
      opacity: true,
      order: true,
      orphans: true,
      tabSize: true,
      widows: true,
      zIndex: true,
      zoom: true,
      fillOpacity: true,
      floodOpacity: true,
      stopOpacity: true,
      strokeDasharray: true,
      strokeDashoffset: true,
      strokeMiterlimit: true,
      strokeOpacity: true,
      strokeWidth: true
    };
    var rb = ["Webkit", "ms", "Moz", "O"];
    Object.keys(qb).forEach(function(a) {
      rb.forEach(function(b) {
        b = b + a.charAt(0).toUpperCase() + a.substring(1);
        qb[b] = qb[a];
      });
    });
    function sb(a, b, c) {
      return b == null || typeof b === "boolean" || b === "" ? "" : c || typeof b !== "number" || b === 0 || qb.hasOwnProperty(a) && qb[a] ? ("" + b).trim() : b + "px";
    }
    function tb(a, b) {
      a = a.style;
      for (var c in b)
        if (b.hasOwnProperty(c)) {
          var d = c.indexOf("--") === 0, e = sb(c, b[c], d);
          c === "float" && (c = "cssFloat");
          d ? a.setProperty(c, e) : a[c] = e;
        }
    }
    var ub = m({menuitem: true}, {area: true, base: true, br: true, col: true, embed: true, hr: true, img: true, input: true, keygen: true, link: true, meta: true, param: true, source: true, track: true, wbr: true});
    function vb(a, b) {
      if (b) {
        if (ub[a] && (b.children != null || b.dangerouslySetInnerHTML != null))
          throw Error(y(137, a));
        if (b.dangerouslySetInnerHTML != null) {
          if (b.children != null)
            throw Error(y(60));
          if (!(typeof b.dangerouslySetInnerHTML === "object" && "__html" in b.dangerouslySetInnerHTML))
            throw Error(y(61));
        }
        if (b.style != null && typeof b.style !== "object")
          throw Error(y(62));
      }
    }
    function wb(a, b) {
      if (a.indexOf("-") === -1)
        return typeof b.is === "string";
      switch (a) {
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return false;
        default:
          return true;
      }
    }
    function xb(a) {
      a = a.target || a.srcElement || window;
      a.correspondingUseElement && (a = a.correspondingUseElement);
      return a.nodeType === 3 ? a.parentNode : a;
    }
    var yb = null;
    var zb = null;
    var Ab = null;
    function Bb(a) {
      if (a = Cb(a)) {
        if (typeof yb !== "function")
          throw Error(y(280));
        var b = a.stateNode;
        b && (b = Db(b), yb(a.stateNode, a.type, b));
      }
    }
    function Eb(a) {
      zb ? Ab ? Ab.push(a) : Ab = [a] : zb = a;
    }
    function Fb() {
      if (zb) {
        var a = zb, b = Ab;
        Ab = zb = null;
        Bb(a);
        if (b)
          for (a = 0; a < b.length; a++)
            Bb(b[a]);
      }
    }
    function Gb(a, b) {
      return a(b);
    }
    function Hb(a, b, c, d, e) {
      return a(b, c, d, e);
    }
    function Ib() {
    }
    var Jb = Gb;
    var Kb = false;
    var Lb = false;
    function Mb() {
      if (zb !== null || Ab !== null)
        Ib(), Fb();
    }
    function Nb(a, b, c) {
      if (Lb)
        return a(b, c);
      Lb = true;
      try {
        return Jb(a, b, c);
      } finally {
        Lb = false, Mb();
      }
    }
    function Ob(a, b) {
      var c = a.stateNode;
      if (c === null)
        return null;
      var d = Db(c);
      if (d === null)
        return null;
      c = d[b];
      a:
        switch (b) {
          case "onClick":
          case "onClickCapture":
          case "onDoubleClick":
          case "onDoubleClickCapture":
          case "onMouseDown":
          case "onMouseDownCapture":
          case "onMouseMove":
          case "onMouseMoveCapture":
          case "onMouseUp":
          case "onMouseUpCapture":
          case "onMouseEnter":
            (d = !d.disabled) || (a = a.type, d = !(a === "button" || a === "input" || a === "select" || a === "textarea"));
            a = !d;
            break a;
          default:
            a = false;
        }
      if (a)
        return null;
      if (c && typeof c !== "function")
        throw Error(y(231, b, typeof c));
      return c;
    }
    var Pb = false;
    if (fa)
      try {
        Qb = {};
        Object.defineProperty(Qb, "passive", {get: function() {
          Pb = true;
        }});
        window.addEventListener("test", Qb, Qb);
        window.removeEventListener("test", Qb, Qb);
      } catch (a) {
        Pb = false;
      }
    var Qb;
    function Rb(a, b, c, d, e, f, g, h, k) {
      var l = Array.prototype.slice.call(arguments, 3);
      try {
        b.apply(c, l);
      } catch (n) {
        this.onError(n);
      }
    }
    var Sb = false;
    var Tb = null;
    var Ub = false;
    var Vb = null;
    var Wb = {onError: function(a) {
      Sb = true;
      Tb = a;
    }};
    function Xb(a, b, c, d, e, f, g, h, k) {
      Sb = false;
      Tb = null;
      Rb.apply(Wb, arguments);
    }
    function Yb(a, b, c, d, e, f, g, h, k) {
      Xb.apply(this, arguments);
      if (Sb) {
        if (Sb) {
          var l = Tb;
          Sb = false;
          Tb = null;
        } else
          throw Error(y(198));
        Ub || (Ub = true, Vb = l);
      }
    }
    function Zb(a) {
      var b = a, c = a;
      if (a.alternate)
        for (; b.return; )
          b = b.return;
      else {
        a = b;
        do
          b = a, (b.flags & 1026) !== 0 && (c = b.return), a = b.return;
        while (a);
      }
      return b.tag === 3 ? c : null;
    }
    function $b(a) {
      if (a.tag === 13) {
        var b = a.memoizedState;
        b === null && (a = a.alternate, a !== null && (b = a.memoizedState));
        if (b !== null)
          return b.dehydrated;
      }
      return null;
    }
    function ac(a) {
      if (Zb(a) !== a)
        throw Error(y(188));
    }
    function bc(a) {
      var b = a.alternate;
      if (!b) {
        b = Zb(a);
        if (b === null)
          throw Error(y(188));
        return b !== a ? null : a;
      }
      for (var c = a, d = b; ; ) {
        var e = c.return;
        if (e === null)
          break;
        var f = e.alternate;
        if (f === null) {
          d = e.return;
          if (d !== null) {
            c = d;
            continue;
          }
          break;
        }
        if (e.child === f.child) {
          for (f = e.child; f; ) {
            if (f === c)
              return ac(e), a;
            if (f === d)
              return ac(e), b;
            f = f.sibling;
          }
          throw Error(y(188));
        }
        if (c.return !== d.return)
          c = e, d = f;
        else {
          for (var g = false, h = e.child; h; ) {
            if (h === c) {
              g = true;
              c = e;
              d = f;
              break;
            }
            if (h === d) {
              g = true;
              d = e;
              c = f;
              break;
            }
            h = h.sibling;
          }
          if (!g) {
            for (h = f.child; h; ) {
              if (h === c) {
                g = true;
                c = f;
                d = e;
                break;
              }
              if (h === d) {
                g = true;
                d = f;
                c = e;
                break;
              }
              h = h.sibling;
            }
            if (!g)
              throw Error(y(189));
          }
        }
        if (c.alternate !== d)
          throw Error(y(190));
      }
      if (c.tag !== 3)
        throw Error(y(188));
      return c.stateNode.current === c ? a : b;
    }
    function cc(a) {
      a = bc(a);
      if (!a)
        return null;
      for (var b = a; ; ) {
        if (b.tag === 5 || b.tag === 6)
          return b;
        if (b.child)
          b.child.return = b, b = b.child;
        else {
          if (b === a)
            break;
          for (; !b.sibling; ) {
            if (!b.return || b.return === a)
              return null;
            b = b.return;
          }
          b.sibling.return = b.return;
          b = b.sibling;
        }
      }
      return null;
    }
    function dc(a, b) {
      for (var c = a.alternate; b !== null; ) {
        if (b === a || b === c)
          return true;
        b = b.return;
      }
      return false;
    }
    var ec;
    var fc;
    var gc;
    var hc;
    var ic = false;
    var jc = [];
    var kc = null;
    var lc = null;
    var mc = null;
    var nc = new Map();
    var oc = new Map();
    var pc = [];
    var qc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
    function rc(a, b, c, d, e) {
      return {blockedOn: a, domEventName: b, eventSystemFlags: c | 16, nativeEvent: e, targetContainers: [d]};
    }
    function sc(a, b) {
      switch (a) {
        case "focusin":
        case "focusout":
          kc = null;
          break;
        case "dragenter":
        case "dragleave":
          lc = null;
          break;
        case "mouseover":
        case "mouseout":
          mc = null;
          break;
        case "pointerover":
        case "pointerout":
          nc.delete(b.pointerId);
          break;
        case "gotpointercapture":
        case "lostpointercapture":
          oc.delete(b.pointerId);
      }
    }
    function tc(a, b, c, d, e, f) {
      if (a === null || a.nativeEvent !== f)
        return a = rc(b, c, d, e, f), b !== null && (b = Cb(b), b !== null && fc(b)), a;
      a.eventSystemFlags |= d;
      b = a.targetContainers;
      e !== null && b.indexOf(e) === -1 && b.push(e);
      return a;
    }
    function uc(a, b, c, d, e) {
      switch (b) {
        case "focusin":
          return kc = tc(kc, a, b, c, d, e), true;
        case "dragenter":
          return lc = tc(lc, a, b, c, d, e), true;
        case "mouseover":
          return mc = tc(mc, a, b, c, d, e), true;
        case "pointerover":
          var f = e.pointerId;
          nc.set(f, tc(nc.get(f) || null, a, b, c, d, e));
          return true;
        case "gotpointercapture":
          return f = e.pointerId, oc.set(f, tc(oc.get(f) || null, a, b, c, d, e)), true;
      }
      return false;
    }
    function vc(a) {
      var b = wc(a.target);
      if (b !== null) {
        var c = Zb(b);
        if (c !== null) {
          if (b = c.tag, b === 13) {
            if (b = $b(c), b !== null) {
              a.blockedOn = b;
              hc(a.lanePriority, function() {
                r.unstable_runWithPriority(a.priority, function() {
                  gc(c);
                });
              });
              return;
            }
          } else if (b === 3 && c.stateNode.hydrate) {
            a.blockedOn = c.tag === 3 ? c.stateNode.containerInfo : null;
            return;
          }
        }
      }
      a.blockedOn = null;
    }
    function xc(a) {
      if (a.blockedOn !== null)
        return false;
      for (var b = a.targetContainers; 0 < b.length; ) {
        var c = yc(a.domEventName, a.eventSystemFlags, b[0], a.nativeEvent);
        if (c !== null)
          return b = Cb(c), b !== null && fc(b), a.blockedOn = c, false;
        b.shift();
      }
      return true;
    }
    function zc(a, b, c) {
      xc(a) && c.delete(b);
    }
    function Ac() {
      for (ic = false; 0 < jc.length; ) {
        var a = jc[0];
        if (a.blockedOn !== null) {
          a = Cb(a.blockedOn);
          a !== null && ec(a);
          break;
        }
        for (var b = a.targetContainers; 0 < b.length; ) {
          var c = yc(a.domEventName, a.eventSystemFlags, b[0], a.nativeEvent);
          if (c !== null) {
            a.blockedOn = c;
            break;
          }
          b.shift();
        }
        a.blockedOn === null && jc.shift();
      }
      kc !== null && xc(kc) && (kc = null);
      lc !== null && xc(lc) && (lc = null);
      mc !== null && xc(mc) && (mc = null);
      nc.forEach(zc);
      oc.forEach(zc);
    }
    function Bc(a, b) {
      a.blockedOn === b && (a.blockedOn = null, ic || (ic = true, r.unstable_scheduleCallback(r.unstable_NormalPriority, Ac)));
    }
    function Cc(a) {
      function b(b2) {
        return Bc(b2, a);
      }
      if (0 < jc.length) {
        Bc(jc[0], a);
        for (var c = 1; c < jc.length; c++) {
          var d = jc[c];
          d.blockedOn === a && (d.blockedOn = null);
        }
      }
      kc !== null && Bc(kc, a);
      lc !== null && Bc(lc, a);
      mc !== null && Bc(mc, a);
      nc.forEach(b);
      oc.forEach(b);
      for (c = 0; c < pc.length; c++)
        d = pc[c], d.blockedOn === a && (d.blockedOn = null);
      for (; 0 < pc.length && (c = pc[0], c.blockedOn === null); )
        vc(c), c.blockedOn === null && pc.shift();
    }
    function Dc(a, b) {
      var c = {};
      c[a.toLowerCase()] = b.toLowerCase();
      c["Webkit" + a] = "webkit" + b;
      c["Moz" + a] = "moz" + b;
      return c;
    }
    var Ec = {animationend: Dc("Animation", "AnimationEnd"), animationiteration: Dc("Animation", "AnimationIteration"), animationstart: Dc("Animation", "AnimationStart"), transitionend: Dc("Transition", "TransitionEnd")};
    var Fc = {};
    var Gc = {};
    fa && (Gc = document.createElement("div").style, "AnimationEvent" in window || (delete Ec.animationend.animation, delete Ec.animationiteration.animation, delete Ec.animationstart.animation), "TransitionEvent" in window || delete Ec.transitionend.transition);
    function Hc(a) {
      if (Fc[a])
        return Fc[a];
      if (!Ec[a])
        return a;
      var b = Ec[a], c;
      for (c in b)
        if (b.hasOwnProperty(c) && c in Gc)
          return Fc[a] = b[c];
      return a;
    }
    var Ic = Hc("animationend");
    var Jc = Hc("animationiteration");
    var Kc = Hc("animationstart");
    var Lc = Hc("transitionend");
    var Mc = new Map();
    var Nc = new Map();
    var Oc = [
      "abort",
      "abort",
      Ic,
      "animationEnd",
      Jc,
      "animationIteration",
      Kc,
      "animationStart",
      "canplay",
      "canPlay",
      "canplaythrough",
      "canPlayThrough",
      "durationchange",
      "durationChange",
      "emptied",
      "emptied",
      "encrypted",
      "encrypted",
      "ended",
      "ended",
      "error",
      "error",
      "gotpointercapture",
      "gotPointerCapture",
      "load",
      "load",
      "loadeddata",
      "loadedData",
      "loadedmetadata",
      "loadedMetadata",
      "loadstart",
      "loadStart",
      "lostpointercapture",
      "lostPointerCapture",
      "playing",
      "playing",
      "progress",
      "progress",
      "seeking",
      "seeking",
      "stalled",
      "stalled",
      "suspend",
      "suspend",
      "timeupdate",
      "timeUpdate",
      Lc,
      "transitionEnd",
      "waiting",
      "waiting"
    ];
    function Pc(a, b) {
      for (var c = 0; c < a.length; c += 2) {
        var d = a[c], e = a[c + 1];
        e = "on" + (e[0].toUpperCase() + e.slice(1));
        Nc.set(d, b);
        Mc.set(d, e);
        da(e, [d]);
      }
    }
    var Qc = r.unstable_now;
    Qc();
    var F = 8;
    function Rc(a) {
      if ((1 & a) !== 0)
        return F = 15, 1;
      if ((2 & a) !== 0)
        return F = 14, 2;
      if ((4 & a) !== 0)
        return F = 13, 4;
      var b = 24 & a;
      if (b !== 0)
        return F = 12, b;
      if ((a & 32) !== 0)
        return F = 11, 32;
      b = 192 & a;
      if (b !== 0)
        return F = 10, b;
      if ((a & 256) !== 0)
        return F = 9, 256;
      b = 3584 & a;
      if (b !== 0)
        return F = 8, b;
      if ((a & 4096) !== 0)
        return F = 7, 4096;
      b = 4186112 & a;
      if (b !== 0)
        return F = 6, b;
      b = 62914560 & a;
      if (b !== 0)
        return F = 5, b;
      if (a & 67108864)
        return F = 4, 67108864;
      if ((a & 134217728) !== 0)
        return F = 3, 134217728;
      b = 805306368 & a;
      if (b !== 0)
        return F = 2, b;
      if ((1073741824 & a) !== 0)
        return F = 1, 1073741824;
      F = 8;
      return a;
    }
    function Sc(a) {
      switch (a) {
        case 99:
          return 15;
        case 98:
          return 10;
        case 97:
        case 96:
          return 8;
        case 95:
          return 2;
        default:
          return 0;
      }
    }
    function Tc(a) {
      switch (a) {
        case 15:
        case 14:
          return 99;
        case 13:
        case 12:
        case 11:
        case 10:
          return 98;
        case 9:
        case 8:
        case 7:
        case 6:
        case 4:
        case 5:
          return 97;
        case 3:
        case 2:
        case 1:
          return 95;
        case 0:
          return 90;
        default:
          throw Error(y(358, a));
      }
    }
    function Uc(a, b) {
      var c = a.pendingLanes;
      if (c === 0)
        return F = 0;
      var d = 0, e = 0, f = a.expiredLanes, g = a.suspendedLanes, h = a.pingedLanes;
      if (f !== 0)
        d = f, e = F = 15;
      else if (f = c & 134217727, f !== 0) {
        var k = f & ~g;
        k !== 0 ? (d = Rc(k), e = F) : (h &= f, h !== 0 && (d = Rc(h), e = F));
      } else
        f = c & ~g, f !== 0 ? (d = Rc(f), e = F) : h !== 0 && (d = Rc(h), e = F);
      if (d === 0)
        return 0;
      d = 31 - Vc(d);
      d = c & ((0 > d ? 0 : 1 << d) << 1) - 1;
      if (b !== 0 && b !== d && (b & g) === 0) {
        Rc(b);
        if (e <= F)
          return b;
        F = e;
      }
      b = a.entangledLanes;
      if (b !== 0)
        for (a = a.entanglements, b &= d; 0 < b; )
          c = 31 - Vc(b), e = 1 << c, d |= a[c], b &= ~e;
      return d;
    }
    function Wc(a) {
      a = a.pendingLanes & -1073741825;
      return a !== 0 ? a : a & 1073741824 ? 1073741824 : 0;
    }
    function Xc(a, b) {
      switch (a) {
        case 15:
          return 1;
        case 14:
          return 2;
        case 12:
          return a = Yc(24 & ~b), a === 0 ? Xc(10, b) : a;
        case 10:
          return a = Yc(192 & ~b), a === 0 ? Xc(8, b) : a;
        case 8:
          return a = Yc(3584 & ~b), a === 0 && (a = Yc(4186112 & ~b), a === 0 && (a = 512)), a;
        case 2:
          return b = Yc(805306368 & ~b), b === 0 && (b = 268435456), b;
      }
      throw Error(y(358, a));
    }
    function Yc(a) {
      return a & -a;
    }
    function Zc(a) {
      for (var b = [], c = 0; 31 > c; c++)
        b.push(a);
      return b;
    }
    function $c(a, b, c) {
      a.pendingLanes |= b;
      var d = b - 1;
      a.suspendedLanes &= d;
      a.pingedLanes &= d;
      a = a.eventTimes;
      b = 31 - Vc(b);
      a[b] = c;
    }
    var Vc = Math.clz32 ? Math.clz32 : ad;
    var bd = Math.log;
    var cd = Math.LN2;
    function ad(a) {
      return a === 0 ? 32 : 31 - (bd(a) / cd | 0) | 0;
    }
    var dd = r.unstable_UserBlockingPriority;
    var ed = r.unstable_runWithPriority;
    var fd = true;
    function gd(a, b, c, d) {
      Kb || Ib();
      var e = hd, f = Kb;
      Kb = true;
      try {
        Hb(e, a, b, c, d);
      } finally {
        (Kb = f) || Mb();
      }
    }
    function id(a, b, c, d) {
      ed(dd, hd.bind(null, a, b, c, d));
    }
    function hd(a, b, c, d) {
      if (fd) {
        var e;
        if ((e = (b & 4) === 0) && 0 < jc.length && -1 < qc.indexOf(a))
          a = rc(null, a, b, c, d), jc.push(a);
        else {
          var f = yc(a, b, c, d);
          if (f === null)
            e && sc(a, d);
          else {
            if (e) {
              if (-1 < qc.indexOf(a)) {
                a = rc(f, a, b, c, d);
                jc.push(a);
                return;
              }
              if (uc(f, a, b, c, d))
                return;
              sc(a, d);
            }
            jd(a, b, d, null, c);
          }
        }
      }
    }
    function yc(a, b, c, d) {
      var e = xb(d);
      e = wc(e);
      if (e !== null) {
        var f = Zb(e);
        if (f === null)
          e = null;
        else {
          var g = f.tag;
          if (g === 13) {
            e = $b(f);
            if (e !== null)
              return e;
            e = null;
          } else if (g === 3) {
            if (f.stateNode.hydrate)
              return f.tag === 3 ? f.stateNode.containerInfo : null;
            e = null;
          } else
            f !== e && (e = null);
        }
      }
      jd(a, b, d, e, c);
      return null;
    }
    var kd = null;
    var ld = null;
    var md = null;
    function nd() {
      if (md)
        return md;
      var a, b = ld, c = b.length, d, e = "value" in kd ? kd.value : kd.textContent, f = e.length;
      for (a = 0; a < c && b[a] === e[a]; a++)
        ;
      var g = c - a;
      for (d = 1; d <= g && b[c - d] === e[f - d]; d++)
        ;
      return md = e.slice(a, 1 < d ? 1 - d : void 0);
    }
    function od(a) {
      var b = a.keyCode;
      "charCode" in a ? (a = a.charCode, a === 0 && b === 13 && (a = 13)) : a = b;
      a === 10 && (a = 13);
      return 32 <= a || a === 13 ? a : 0;
    }
    function pd() {
      return true;
    }
    function qd() {
      return false;
    }
    function rd(a) {
      function b(b2, d, e, f, g) {
        this._reactName = b2;
        this._targetInst = e;
        this.type = d;
        this.nativeEvent = f;
        this.target = g;
        this.currentTarget = null;
        for (var c in a)
          a.hasOwnProperty(c) && (b2 = a[c], this[c] = b2 ? b2(f) : f[c]);
        this.isDefaultPrevented = (f.defaultPrevented != null ? f.defaultPrevented : f.returnValue === false) ? pd : qd;
        this.isPropagationStopped = qd;
        return this;
      }
      m(b.prototype, {preventDefault: function() {
        this.defaultPrevented = true;
        var a2 = this.nativeEvent;
        a2 && (a2.preventDefault ? a2.preventDefault() : typeof a2.returnValue !== "unknown" && (a2.returnValue = false), this.isDefaultPrevented = pd);
      }, stopPropagation: function() {
        var a2 = this.nativeEvent;
        a2 && (a2.stopPropagation ? a2.stopPropagation() : typeof a2.cancelBubble !== "unknown" && (a2.cancelBubble = true), this.isPropagationStopped = pd);
      }, persist: function() {
      }, isPersistent: pd});
      return b;
    }
    var sd = {eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(a) {
      return a.timeStamp || Date.now();
    }, defaultPrevented: 0, isTrusted: 0};
    var td = rd(sd);
    var ud = m({}, sd, {view: 0, detail: 0});
    var vd = rd(ud);
    var wd;
    var xd;
    var yd;
    var Ad = m({}, ud, {screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: zd, button: 0, buttons: 0, relatedTarget: function(a) {
      return a.relatedTarget === void 0 ? a.fromElement === a.srcElement ? a.toElement : a.fromElement : a.relatedTarget;
    }, movementX: function(a) {
      if ("movementX" in a)
        return a.movementX;
      a !== yd && (yd && a.type === "mousemove" ? (wd = a.screenX - yd.screenX, xd = a.screenY - yd.screenY) : xd = wd = 0, yd = a);
      return wd;
    }, movementY: function(a) {
      return "movementY" in a ? a.movementY : xd;
    }});
    var Bd = rd(Ad);
    var Cd = m({}, Ad, {dataTransfer: 0});
    var Dd = rd(Cd);
    var Ed = m({}, ud, {relatedTarget: 0});
    var Fd = rd(Ed);
    var Gd = m({}, sd, {animationName: 0, elapsedTime: 0, pseudoElement: 0});
    var Hd = rd(Gd);
    var Id = m({}, sd, {clipboardData: function(a) {
      return "clipboardData" in a ? a.clipboardData : window.clipboardData;
    }});
    var Jd = rd(Id);
    var Kd = m({}, sd, {data: 0});
    var Ld = rd(Kd);
    var Md = {
      Esc: "Escape",
      Spacebar: " ",
      Left: "ArrowLeft",
      Up: "ArrowUp",
      Right: "ArrowRight",
      Down: "ArrowDown",
      Del: "Delete",
      Win: "OS",
      Menu: "ContextMenu",
      Apps: "ContextMenu",
      Scroll: "ScrollLock",
      MozPrintableKey: "Unidentified"
    };
    var Nd = {
      8: "Backspace",
      9: "Tab",
      12: "Clear",
      13: "Enter",
      16: "Shift",
      17: "Control",
      18: "Alt",
      19: "Pause",
      20: "CapsLock",
      27: "Escape",
      32: " ",
      33: "PageUp",
      34: "PageDown",
      35: "End",
      36: "Home",
      37: "ArrowLeft",
      38: "ArrowUp",
      39: "ArrowRight",
      40: "ArrowDown",
      45: "Insert",
      46: "Delete",
      112: "F1",
      113: "F2",
      114: "F3",
      115: "F4",
      116: "F5",
      117: "F6",
      118: "F7",
      119: "F8",
      120: "F9",
      121: "F10",
      122: "F11",
      123: "F12",
      144: "NumLock",
      145: "ScrollLock",
      224: "Meta"
    };
    var Od = {Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey"};
    function Pd(a) {
      var b = this.nativeEvent;
      return b.getModifierState ? b.getModifierState(a) : (a = Od[a]) ? !!b[a] : false;
    }
    function zd() {
      return Pd;
    }
    var Qd = m({}, ud, {key: function(a) {
      if (a.key) {
        var b = Md[a.key] || a.key;
        if (b !== "Unidentified")
          return b;
      }
      return a.type === "keypress" ? (a = od(a), a === 13 ? "Enter" : String.fromCharCode(a)) : a.type === "keydown" || a.type === "keyup" ? Nd[a.keyCode] || "Unidentified" : "";
    }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: zd, charCode: function(a) {
      return a.type === "keypress" ? od(a) : 0;
    }, keyCode: function(a) {
      return a.type === "keydown" || a.type === "keyup" ? a.keyCode : 0;
    }, which: function(a) {
      return a.type === "keypress" ? od(a) : a.type === "keydown" || a.type === "keyup" ? a.keyCode : 0;
    }});
    var Rd = rd(Qd);
    var Sd = m({}, Ad, {pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0});
    var Td = rd(Sd);
    var Ud = m({}, ud, {touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: zd});
    var Vd = rd(Ud);
    var Wd = m({}, sd, {propertyName: 0, elapsedTime: 0, pseudoElement: 0});
    var Xd = rd(Wd);
    var Yd = m({}, Ad, {
      deltaX: function(a) {
        return "deltaX" in a ? a.deltaX : "wheelDeltaX" in a ? -a.wheelDeltaX : 0;
      },
      deltaY: function(a) {
        return "deltaY" in a ? a.deltaY : "wheelDeltaY" in a ? -a.wheelDeltaY : "wheelDelta" in a ? -a.wheelDelta : 0;
      },
      deltaZ: 0,
      deltaMode: 0
    });
    var Zd = rd(Yd);
    var $d = [9, 13, 27, 32];
    var ae = fa && "CompositionEvent" in window;
    var be = null;
    fa && "documentMode" in document && (be = document.documentMode);
    var ce = fa && "TextEvent" in window && !be;
    var de = fa && (!ae || be && 8 < be && 11 >= be);
    var ee = String.fromCharCode(32);
    var fe = false;
    function ge(a, b) {
      switch (a) {
        case "keyup":
          return $d.indexOf(b.keyCode) !== -1;
        case "keydown":
          return b.keyCode !== 229;
        case "keypress":
        case "mousedown":
        case "focusout":
          return true;
        default:
          return false;
      }
    }
    function he(a) {
      a = a.detail;
      return typeof a === "object" && "data" in a ? a.data : null;
    }
    var ie = false;
    function je(a, b) {
      switch (a) {
        case "compositionend":
          return he(b);
        case "keypress":
          if (b.which !== 32)
            return null;
          fe = true;
          return ee;
        case "textInput":
          return a = b.data, a === ee && fe ? null : a;
        default:
          return null;
      }
    }
    function ke(a, b) {
      if (ie)
        return a === "compositionend" || !ae && ge(a, b) ? (a = nd(), md = ld = kd = null, ie = false, a) : null;
      switch (a) {
        case "paste":
          return null;
        case "keypress":
          if (!(b.ctrlKey || b.altKey || b.metaKey) || b.ctrlKey && b.altKey) {
            if (b.char && 1 < b.char.length)
              return b.char;
            if (b.which)
              return String.fromCharCode(b.which);
          }
          return null;
        case "compositionend":
          return de && b.locale !== "ko" ? null : b.data;
        default:
          return null;
      }
    }
    var le = {color: true, date: true, datetime: true, "datetime-local": true, email: true, month: true, number: true, password: true, range: true, search: true, tel: true, text: true, time: true, url: true, week: true};
    function me(a) {
      var b = a && a.nodeName && a.nodeName.toLowerCase();
      return b === "input" ? !!le[a.type] : b === "textarea" ? true : false;
    }
    function ne(a, b, c, d) {
      Eb(d);
      b = oe(b, "onChange");
      0 < b.length && (c = new td("onChange", "change", null, c, d), a.push({event: c, listeners: b}));
    }
    var pe = null;
    var qe = null;
    function re(a) {
      se(a, 0);
    }
    function te(a) {
      var b = ue(a);
      if (Wa(b))
        return a;
    }
    function ve(a, b) {
      if (a === "change")
        return b;
    }
    var we = false;
    if (fa) {
      if (fa) {
        ye = "oninput" in document;
        if (!ye) {
          ze = document.createElement("div");
          ze.setAttribute("oninput", "return;");
          ye = typeof ze.oninput === "function";
        }
        xe = ye;
      } else
        xe = false;
      we = xe && (!document.documentMode || 9 < document.documentMode);
    }
    var xe;
    var ye;
    var ze;
    function Ae() {
      pe && (pe.detachEvent("onpropertychange", Be), qe = pe = null);
    }
    function Be(a) {
      if (a.propertyName === "value" && te(qe)) {
        var b = [];
        ne(b, qe, a, xb(a));
        a = re;
        if (Kb)
          a(b);
        else {
          Kb = true;
          try {
            Gb(a, b);
          } finally {
            Kb = false, Mb();
          }
        }
      }
    }
    function Ce(a, b, c) {
      a === "focusin" ? (Ae(), pe = b, qe = c, pe.attachEvent("onpropertychange", Be)) : a === "focusout" && Ae();
    }
    function De(a) {
      if (a === "selectionchange" || a === "keyup" || a === "keydown")
        return te(qe);
    }
    function Ee(a, b) {
      if (a === "click")
        return te(b);
    }
    function Fe(a, b) {
      if (a === "input" || a === "change")
        return te(b);
    }
    function Ge(a, b) {
      return a === b && (a !== 0 || 1 / a === 1 / b) || a !== a && b !== b;
    }
    var He = typeof Object.is === "function" ? Object.is : Ge;
    var Ie = Object.prototype.hasOwnProperty;
    function Je(a, b) {
      if (He(a, b))
        return true;
      if (typeof a !== "object" || a === null || typeof b !== "object" || b === null)
        return false;
      var c = Object.keys(a), d = Object.keys(b);
      if (c.length !== d.length)
        return false;
      for (d = 0; d < c.length; d++)
        if (!Ie.call(b, c[d]) || !He(a[c[d]], b[c[d]]))
          return false;
      return true;
    }
    function Ke(a) {
      for (; a && a.firstChild; )
        a = a.firstChild;
      return a;
    }
    function Le(a, b) {
      var c = Ke(a);
      a = 0;
      for (var d; c; ) {
        if (c.nodeType === 3) {
          d = a + c.textContent.length;
          if (a <= b && d >= b)
            return {node: c, offset: b - a};
          a = d;
        }
        a: {
          for (; c; ) {
            if (c.nextSibling) {
              c = c.nextSibling;
              break a;
            }
            c = c.parentNode;
          }
          c = void 0;
        }
        c = Ke(c);
      }
    }
    function Me(a, b) {
      return a && b ? a === b ? true : a && a.nodeType === 3 ? false : b && b.nodeType === 3 ? Me(a, b.parentNode) : "contains" in a ? a.contains(b) : a.compareDocumentPosition ? !!(a.compareDocumentPosition(b) & 16) : false : false;
    }
    function Ne() {
      for (var a = window, b = Xa(); b instanceof a.HTMLIFrameElement; ) {
        try {
          var c = typeof b.contentWindow.location.href === "string";
        } catch (d) {
          c = false;
        }
        if (c)
          a = b.contentWindow;
        else
          break;
        b = Xa(a.document);
      }
      return b;
    }
    function Oe(a) {
      var b = a && a.nodeName && a.nodeName.toLowerCase();
      return b && (b === "input" && (a.type === "text" || a.type === "search" || a.type === "tel" || a.type === "url" || a.type === "password") || b === "textarea" || a.contentEditable === "true");
    }
    var Pe = fa && "documentMode" in document && 11 >= document.documentMode;
    var Qe = null;
    var Re = null;
    var Se = null;
    var Te = false;
    function Ue(a, b, c) {
      var d = c.window === c ? c.document : c.nodeType === 9 ? c : c.ownerDocument;
      Te || Qe == null || Qe !== Xa(d) || (d = Qe, "selectionStart" in d && Oe(d) ? d = {start: d.selectionStart, end: d.selectionEnd} : (d = (d.ownerDocument && d.ownerDocument.defaultView || window).getSelection(), d = {anchorNode: d.anchorNode, anchorOffset: d.anchorOffset, focusNode: d.focusNode, focusOffset: d.focusOffset}), Se && Je(Se, d) || (Se = d, d = oe(Re, "onSelect"), 0 < d.length && (b = new td("onSelect", "select", null, b, c), a.push({event: b, listeners: d}), b.target = Qe)));
    }
    Pc("cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focusin focus focusout blur input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "), 0);
    Pc("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "), 1);
    Pc(Oc, 2);
    for (var Ve = "change selectionchange textInput compositionstart compositionend compositionupdate".split(" "), We = 0; We < Ve.length; We++)
      Nc.set(Ve[We], 0);
    ea("onMouseEnter", ["mouseout", "mouseover"]);
    ea("onMouseLeave", ["mouseout", "mouseover"]);
    ea("onPointerEnter", ["pointerout", "pointerover"]);
    ea("onPointerLeave", ["pointerout", "pointerover"]);
    da("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
    da("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
    da("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
    da("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
    da("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
    da("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
    var Xe = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" ");
    var Ye = new Set("cancel close invalid load scroll toggle".split(" ").concat(Xe));
    function Ze(a, b, c) {
      var d = a.type || "unknown-event";
      a.currentTarget = c;
      Yb(d, b, void 0, a);
      a.currentTarget = null;
    }
    function se(a, b) {
      b = (b & 4) !== 0;
      for (var c = 0; c < a.length; c++) {
        var d = a[c], e = d.event;
        d = d.listeners;
        a: {
          var f = void 0;
          if (b)
            for (var g = d.length - 1; 0 <= g; g--) {
              var h = d[g], k = h.instance, l = h.currentTarget;
              h = h.listener;
              if (k !== f && e.isPropagationStopped())
                break a;
              Ze(e, h, l);
              f = k;
            }
          else
            for (g = 0; g < d.length; g++) {
              h = d[g];
              k = h.instance;
              l = h.currentTarget;
              h = h.listener;
              if (k !== f && e.isPropagationStopped())
                break a;
              Ze(e, h, l);
              f = k;
            }
        }
      }
      if (Ub)
        throw a = Vb, Ub = false, Vb = null, a;
    }
    function G(a, b) {
      var c = $e(b), d = a + "__bubble";
      c.has(d) || (af(b, a, 2, false), c.add(d));
    }
    var bf = "_reactListening" + Math.random().toString(36).slice(2);
    function cf(a) {
      a[bf] || (a[bf] = true, ba.forEach(function(b) {
        Ye.has(b) || df(b, false, a, null);
        df(b, true, a, null);
      }));
    }
    function df(a, b, c, d) {
      var e = 4 < arguments.length && arguments[4] !== void 0 ? arguments[4] : 0, f = c;
      a === "selectionchange" && c.nodeType !== 9 && (f = c.ownerDocument);
      if (d !== null && !b && Ye.has(a)) {
        if (a !== "scroll")
          return;
        e |= 2;
        f = d;
      }
      var g = $e(f), h = a + "__" + (b ? "capture" : "bubble");
      g.has(h) || (b && (e |= 4), af(f, a, e, b), g.add(h));
    }
    function af(a, b, c, d) {
      var e = Nc.get(b);
      switch (e === void 0 ? 2 : e) {
        case 0:
          e = gd;
          break;
        case 1:
          e = id;
          break;
        default:
          e = hd;
      }
      c = e.bind(null, b, c, a);
      e = void 0;
      !Pb || b !== "touchstart" && b !== "touchmove" && b !== "wheel" || (e = true);
      d ? e !== void 0 ? a.addEventListener(b, c, {capture: true, passive: e}) : a.addEventListener(b, c, true) : e !== void 0 ? a.addEventListener(b, c, {passive: e}) : a.addEventListener(b, c, false);
    }
    function jd(a, b, c, d, e) {
      var f = d;
      if ((b & 1) === 0 && (b & 2) === 0 && d !== null)
        a:
          for (; ; ) {
            if (d === null)
              return;
            var g = d.tag;
            if (g === 3 || g === 4) {
              var h = d.stateNode.containerInfo;
              if (h === e || h.nodeType === 8 && h.parentNode === e)
                break;
              if (g === 4)
                for (g = d.return; g !== null; ) {
                  var k = g.tag;
                  if (k === 3 || k === 4) {
                    if (k = g.stateNode.containerInfo, k === e || k.nodeType === 8 && k.parentNode === e)
                      return;
                  }
                  g = g.return;
                }
              for (; h !== null; ) {
                g = wc(h);
                if (g === null)
                  return;
                k = g.tag;
                if (k === 5 || k === 6) {
                  d = f = g;
                  continue a;
                }
                h = h.parentNode;
              }
            }
            d = d.return;
          }
      Nb(function() {
        var d2 = f, e2 = xb(c), g2 = [];
        a: {
          var h2 = Mc.get(a);
          if (h2 !== void 0) {
            var k2 = td, x = a;
            switch (a) {
              case "keypress":
                if (od(c) === 0)
                  break a;
              case "keydown":
              case "keyup":
                k2 = Rd;
                break;
              case "focusin":
                x = "focus";
                k2 = Fd;
                break;
              case "focusout":
                x = "blur";
                k2 = Fd;
                break;
              case "beforeblur":
              case "afterblur":
                k2 = Fd;
                break;
              case "click":
                if (c.button === 2)
                  break a;
              case "auxclick":
              case "dblclick":
              case "mousedown":
              case "mousemove":
              case "mouseup":
              case "mouseout":
              case "mouseover":
              case "contextmenu":
                k2 = Bd;
                break;
              case "drag":
              case "dragend":
              case "dragenter":
              case "dragexit":
              case "dragleave":
              case "dragover":
              case "dragstart":
              case "drop":
                k2 = Dd;
                break;
              case "touchcancel":
              case "touchend":
              case "touchmove":
              case "touchstart":
                k2 = Vd;
                break;
              case Ic:
              case Jc:
              case Kc:
                k2 = Hd;
                break;
              case Lc:
                k2 = Xd;
                break;
              case "scroll":
                k2 = vd;
                break;
              case "wheel":
                k2 = Zd;
                break;
              case "copy":
              case "cut":
              case "paste":
                k2 = Jd;
                break;
              case "gotpointercapture":
              case "lostpointercapture":
              case "pointercancel":
              case "pointerdown":
              case "pointermove":
              case "pointerout":
              case "pointerover":
              case "pointerup":
                k2 = Td;
            }
            var w = (b & 4) !== 0, z = !w && a === "scroll", u = w ? h2 !== null ? h2 + "Capture" : null : h2;
            w = [];
            for (var t = d2, q; t !== null; ) {
              q = t;
              var v = q.stateNode;
              q.tag === 5 && v !== null && (q = v, u !== null && (v = Ob(t, u), v != null && w.push(ef(t, v, q))));
              if (z)
                break;
              t = t.return;
            }
            0 < w.length && (h2 = new k2(h2, x, null, c, e2), g2.push({event: h2, listeners: w}));
          }
        }
        if ((b & 7) === 0) {
          a: {
            h2 = a === "mouseover" || a === "pointerover";
            k2 = a === "mouseout" || a === "pointerout";
            if (h2 && (b & 16) === 0 && (x = c.relatedTarget || c.fromElement) && (wc(x) || x[ff]))
              break a;
            if (k2 || h2) {
              h2 = e2.window === e2 ? e2 : (h2 = e2.ownerDocument) ? h2.defaultView || h2.parentWindow : window;
              if (k2) {
                if (x = c.relatedTarget || c.toElement, k2 = d2, x = x ? wc(x) : null, x !== null && (z = Zb(x), x !== z || x.tag !== 5 && x.tag !== 6))
                  x = null;
              } else
                k2 = null, x = d2;
              if (k2 !== x) {
                w = Bd;
                v = "onMouseLeave";
                u = "onMouseEnter";
                t = "mouse";
                if (a === "pointerout" || a === "pointerover")
                  w = Td, v = "onPointerLeave", u = "onPointerEnter", t = "pointer";
                z = k2 == null ? h2 : ue(k2);
                q = x == null ? h2 : ue(x);
                h2 = new w(v, t + "leave", k2, c, e2);
                h2.target = z;
                h2.relatedTarget = q;
                v = null;
                wc(e2) === d2 && (w = new w(u, t + "enter", x, c, e2), w.target = q, w.relatedTarget = z, v = w);
                z = v;
                if (k2 && x)
                  b: {
                    w = k2;
                    u = x;
                    t = 0;
                    for (q = w; q; q = gf(q))
                      t++;
                    q = 0;
                    for (v = u; v; v = gf(v))
                      q++;
                    for (; 0 < t - q; )
                      w = gf(w), t--;
                    for (; 0 < q - t; )
                      u = gf(u), q--;
                    for (; t--; ) {
                      if (w === u || u !== null && w === u.alternate)
                        break b;
                      w = gf(w);
                      u = gf(u);
                    }
                    w = null;
                  }
                else
                  w = null;
                k2 !== null && hf(g2, h2, k2, w, false);
                x !== null && z !== null && hf(g2, z, x, w, true);
              }
            }
          }
          a: {
            h2 = d2 ? ue(d2) : window;
            k2 = h2.nodeName && h2.nodeName.toLowerCase();
            if (k2 === "select" || k2 === "input" && h2.type === "file")
              var J = ve;
            else if (me(h2))
              if (we)
                J = Fe;
              else {
                J = De;
                var K = Ce;
              }
            else
              (k2 = h2.nodeName) && k2.toLowerCase() === "input" && (h2.type === "checkbox" || h2.type === "radio") && (J = Ee);
            if (J && (J = J(a, d2))) {
              ne(g2, J, c, e2);
              break a;
            }
            K && K(a, h2, d2);
            a === "focusout" && (K = h2._wrapperState) && K.controlled && h2.type === "number" && bb(h2, "number", h2.value);
          }
          K = d2 ? ue(d2) : window;
          switch (a) {
            case "focusin":
              if (me(K) || K.contentEditable === "true")
                Qe = K, Re = d2, Se = null;
              break;
            case "focusout":
              Se = Re = Qe = null;
              break;
            case "mousedown":
              Te = true;
              break;
            case "contextmenu":
            case "mouseup":
            case "dragend":
              Te = false;
              Ue(g2, c, e2);
              break;
            case "selectionchange":
              if (Pe)
                break;
            case "keydown":
            case "keyup":
              Ue(g2, c, e2);
          }
          var Q;
          if (ae)
            b: {
              switch (a) {
                case "compositionstart":
                  var L = "onCompositionStart";
                  break b;
                case "compositionend":
                  L = "onCompositionEnd";
                  break b;
                case "compositionupdate":
                  L = "onCompositionUpdate";
                  break b;
              }
              L = void 0;
            }
          else
            ie ? ge(a, c) && (L = "onCompositionEnd") : a === "keydown" && c.keyCode === 229 && (L = "onCompositionStart");
          L && (de && c.locale !== "ko" && (ie || L !== "onCompositionStart" ? L === "onCompositionEnd" && ie && (Q = nd()) : (kd = e2, ld = "value" in kd ? kd.value : kd.textContent, ie = true)), K = oe(d2, L), 0 < K.length && (L = new Ld(L, a, null, c, e2), g2.push({event: L, listeners: K}), Q ? L.data = Q : (Q = he(c), Q !== null && (L.data = Q))));
          if (Q = ce ? je(a, c) : ke(a, c))
            d2 = oe(d2, "onBeforeInput"), 0 < d2.length && (e2 = new Ld("onBeforeInput", "beforeinput", null, c, e2), g2.push({event: e2, listeners: d2}), e2.data = Q);
        }
        se(g2, b);
      });
    }
    function ef(a, b, c) {
      return {instance: a, listener: b, currentTarget: c};
    }
    function oe(a, b) {
      for (var c = b + "Capture", d = []; a !== null; ) {
        var e = a, f = e.stateNode;
        e.tag === 5 && f !== null && (e = f, f = Ob(a, c), f != null && d.unshift(ef(a, f, e)), f = Ob(a, b), f != null && d.push(ef(a, f, e)));
        a = a.return;
      }
      return d;
    }
    function gf(a) {
      if (a === null)
        return null;
      do
        a = a.return;
      while (a && a.tag !== 5);
      return a ? a : null;
    }
    function hf(a, b, c, d, e) {
      for (var f = b._reactName, g = []; c !== null && c !== d; ) {
        var h = c, k = h.alternate, l = h.stateNode;
        if (k !== null && k === d)
          break;
        h.tag === 5 && l !== null && (h = l, e ? (k = Ob(c, f), k != null && g.unshift(ef(c, k, h))) : e || (k = Ob(c, f), k != null && g.push(ef(c, k, h))));
        c = c.return;
      }
      g.length !== 0 && a.push({event: b, listeners: g});
    }
    function jf() {
    }
    var kf = null;
    var lf = null;
    function mf(a, b) {
      switch (a) {
        case "button":
        case "input":
        case "select":
        case "textarea":
          return !!b.autoFocus;
      }
      return false;
    }
    function nf(a, b) {
      return a === "textarea" || a === "option" || a === "noscript" || typeof b.children === "string" || typeof b.children === "number" || typeof b.dangerouslySetInnerHTML === "object" && b.dangerouslySetInnerHTML !== null && b.dangerouslySetInnerHTML.__html != null;
    }
    var of = typeof setTimeout === "function" ? setTimeout : void 0;
    var pf = typeof clearTimeout === "function" ? clearTimeout : void 0;
    function qf(a) {
      a.nodeType === 1 ? a.textContent = "" : a.nodeType === 9 && (a = a.body, a != null && (a.textContent = ""));
    }
    function rf(a) {
      for (; a != null; a = a.nextSibling) {
        var b = a.nodeType;
        if (b === 1 || b === 3)
          break;
      }
      return a;
    }
    function sf(a) {
      a = a.previousSibling;
      for (var b = 0; a; ) {
        if (a.nodeType === 8) {
          var c = a.data;
          if (c === "$" || c === "$!" || c === "$?") {
            if (b === 0)
              return a;
            b--;
          } else
            c === "/$" && b++;
        }
        a = a.previousSibling;
      }
      return null;
    }
    var tf = 0;
    function uf(a) {
      return {$$typeof: Ga, toString: a, valueOf: a};
    }
    var vf = Math.random().toString(36).slice(2);
    var wf = "__reactFiber$" + vf;
    var xf = "__reactProps$" + vf;
    var ff = "__reactContainer$" + vf;
    var yf = "__reactEvents$" + vf;
    function wc(a) {
      var b = a[wf];
      if (b)
        return b;
      for (var c = a.parentNode; c; ) {
        if (b = c[ff] || c[wf]) {
          c = b.alternate;
          if (b.child !== null || c !== null && c.child !== null)
            for (a = sf(a); a !== null; ) {
              if (c = a[wf])
                return c;
              a = sf(a);
            }
          return b;
        }
        a = c;
        c = a.parentNode;
      }
      return null;
    }
    function Cb(a) {
      a = a[wf] || a[ff];
      return !a || a.tag !== 5 && a.tag !== 6 && a.tag !== 13 && a.tag !== 3 ? null : a;
    }
    function ue(a) {
      if (a.tag === 5 || a.tag === 6)
        return a.stateNode;
      throw Error(y(33));
    }
    function Db(a) {
      return a[xf] || null;
    }
    function $e(a) {
      var b = a[yf];
      b === void 0 && (b = a[yf] = new Set());
      return b;
    }
    var zf = [];
    var Af = -1;
    function Bf(a) {
      return {current: a};
    }
    function H(a) {
      0 > Af || (a.current = zf[Af], zf[Af] = null, Af--);
    }
    function I(a, b) {
      Af++;
      zf[Af] = a.current;
      a.current = b;
    }
    var Cf = {};
    var M = Bf(Cf);
    var N = Bf(false);
    var Df = Cf;
    function Ef(a, b) {
      var c = a.type.contextTypes;
      if (!c)
        return Cf;
      var d = a.stateNode;
      if (d && d.__reactInternalMemoizedUnmaskedChildContext === b)
        return d.__reactInternalMemoizedMaskedChildContext;
      var e = {}, f;
      for (f in c)
        e[f] = b[f];
      d && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = b, a.__reactInternalMemoizedMaskedChildContext = e);
      return e;
    }
    function Ff(a) {
      a = a.childContextTypes;
      return a !== null && a !== void 0;
    }
    function Gf() {
      H(N);
      H(M);
    }
    function Hf(a, b, c) {
      if (M.current !== Cf)
        throw Error(y(168));
      I(M, b);
      I(N, c);
    }
    function If(a, b, c) {
      var d = a.stateNode;
      a = b.childContextTypes;
      if (typeof d.getChildContext !== "function")
        return c;
      d = d.getChildContext();
      for (var e in d)
        if (!(e in a))
          throw Error(y(108, Ra(b) || "Unknown", e));
      return m({}, c, d);
    }
    function Jf(a) {
      a = (a = a.stateNode) && a.__reactInternalMemoizedMergedChildContext || Cf;
      Df = M.current;
      I(M, a);
      I(N, N.current);
      return true;
    }
    function Kf(a, b, c) {
      var d = a.stateNode;
      if (!d)
        throw Error(y(169));
      c ? (a = If(a, b, Df), d.__reactInternalMemoizedMergedChildContext = a, H(N), H(M), I(M, a)) : H(N);
      I(N, c);
    }
    var Lf = null;
    var Mf = null;
    var Nf = r.unstable_runWithPriority;
    var Of = r.unstable_scheduleCallback;
    var Pf = r.unstable_cancelCallback;
    var Qf = r.unstable_shouldYield;
    var Rf = r.unstable_requestPaint;
    var Sf = r.unstable_now;
    var Tf = r.unstable_getCurrentPriorityLevel;
    var Uf = r.unstable_ImmediatePriority;
    var Vf = r.unstable_UserBlockingPriority;
    var Wf = r.unstable_NormalPriority;
    var Xf = r.unstable_LowPriority;
    var Yf = r.unstable_IdlePriority;
    var Zf = {};
    var $f = Rf !== void 0 ? Rf : function() {
    };
    var ag = null;
    var bg = null;
    var cg = false;
    var dg = Sf();
    var O = 1e4 > dg ? Sf : function() {
      return Sf() - dg;
    };
    function eg() {
      switch (Tf()) {
        case Uf:
          return 99;
        case Vf:
          return 98;
        case Wf:
          return 97;
        case Xf:
          return 96;
        case Yf:
          return 95;
        default:
          throw Error(y(332));
      }
    }
    function fg(a) {
      switch (a) {
        case 99:
          return Uf;
        case 98:
          return Vf;
        case 97:
          return Wf;
        case 96:
          return Xf;
        case 95:
          return Yf;
        default:
          throw Error(y(332));
      }
    }
    function gg(a, b) {
      a = fg(a);
      return Nf(a, b);
    }
    function hg(a, b, c) {
      a = fg(a);
      return Of(a, b, c);
    }
    function ig() {
      if (bg !== null) {
        var a = bg;
        bg = null;
        Pf(a);
      }
      jg();
    }
    function jg() {
      if (!cg && ag !== null) {
        cg = true;
        var a = 0;
        try {
          var b = ag;
          gg(99, function() {
            for (; a < b.length; a++) {
              var c = b[a];
              do
                c = c(true);
              while (c !== null);
            }
          });
          ag = null;
        } catch (c) {
          throw ag !== null && (ag = ag.slice(a + 1)), Of(Uf, ig), c;
        } finally {
          cg = false;
        }
      }
    }
    var kg = ra.ReactCurrentBatchConfig;
    function lg(a, b) {
      if (a && a.defaultProps) {
        b = m({}, b);
        a = a.defaultProps;
        for (var c in a)
          b[c] === void 0 && (b[c] = a[c]);
        return b;
      }
      return b;
    }
    var mg = Bf(null);
    var ng = null;
    var og = null;
    var pg = null;
    function qg() {
      pg = og = ng = null;
    }
    function rg(a) {
      var b = mg.current;
      H(mg);
      a.type._context._currentValue = b;
    }
    function sg(a, b) {
      for (; a !== null; ) {
        var c = a.alternate;
        if ((a.childLanes & b) === b)
          if (c === null || (c.childLanes & b) === b)
            break;
          else
            c.childLanes |= b;
        else
          a.childLanes |= b, c !== null && (c.childLanes |= b);
        a = a.return;
      }
    }
    function tg(a, b) {
      ng = a;
      pg = og = null;
      a = a.dependencies;
      a !== null && a.firstContext !== null && ((a.lanes & b) !== 0 && (ug = true), a.firstContext = null);
    }
    function vg(a, b) {
      if (pg !== a && b !== false && b !== 0) {
        if (typeof b !== "number" || b === 1073741823)
          pg = a, b = 1073741823;
        b = {context: a, observedBits: b, next: null};
        if (og === null) {
          if (ng === null)
            throw Error(y(308));
          og = b;
          ng.dependencies = {lanes: 0, firstContext: b, responders: null};
        } else
          og = og.next = b;
      }
      return a._currentValue;
    }
    var wg = false;
    function xg(a) {
      a.updateQueue = {baseState: a.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: {pending: null}, effects: null};
    }
    function yg(a, b) {
      a = a.updateQueue;
      b.updateQueue === a && (b.updateQueue = {baseState: a.baseState, firstBaseUpdate: a.firstBaseUpdate, lastBaseUpdate: a.lastBaseUpdate, shared: a.shared, effects: a.effects});
    }
    function zg(a, b) {
      return {eventTime: a, lane: b, tag: 0, payload: null, callback: null, next: null};
    }
    function Ag(a, b) {
      a = a.updateQueue;
      if (a !== null) {
        a = a.shared;
        var c = a.pending;
        c === null ? b.next = b : (b.next = c.next, c.next = b);
        a.pending = b;
      }
    }
    function Bg(a, b) {
      var c = a.updateQueue, d = a.alternate;
      if (d !== null && (d = d.updateQueue, c === d)) {
        var e = null, f = null;
        c = c.firstBaseUpdate;
        if (c !== null) {
          do {
            var g = {eventTime: c.eventTime, lane: c.lane, tag: c.tag, payload: c.payload, callback: c.callback, next: null};
            f === null ? e = f = g : f = f.next = g;
            c = c.next;
          } while (c !== null);
          f === null ? e = f = b : f = f.next = b;
        } else
          e = f = b;
        c = {baseState: d.baseState, firstBaseUpdate: e, lastBaseUpdate: f, shared: d.shared, effects: d.effects};
        a.updateQueue = c;
        return;
      }
      a = c.lastBaseUpdate;
      a === null ? c.firstBaseUpdate = b : a.next = b;
      c.lastBaseUpdate = b;
    }
    function Cg(a, b, c, d) {
      var e = a.updateQueue;
      wg = false;
      var f = e.firstBaseUpdate, g = e.lastBaseUpdate, h = e.shared.pending;
      if (h !== null) {
        e.shared.pending = null;
        var k = h, l = k.next;
        k.next = null;
        g === null ? f = l : g.next = l;
        g = k;
        var n = a.alternate;
        if (n !== null) {
          n = n.updateQueue;
          var A = n.lastBaseUpdate;
          A !== g && (A === null ? n.firstBaseUpdate = l : A.next = l, n.lastBaseUpdate = k);
        }
      }
      if (f !== null) {
        A = e.baseState;
        g = 0;
        n = l = k = null;
        do {
          h = f.lane;
          var p = f.eventTime;
          if ((d & h) === h) {
            n !== null && (n = n.next = {
              eventTime: p,
              lane: 0,
              tag: f.tag,
              payload: f.payload,
              callback: f.callback,
              next: null
            });
            a: {
              var C = a, x = f;
              h = b;
              p = c;
              switch (x.tag) {
                case 1:
                  C = x.payload;
                  if (typeof C === "function") {
                    A = C.call(p, A, h);
                    break a;
                  }
                  A = C;
                  break a;
                case 3:
                  C.flags = C.flags & -4097 | 64;
                case 0:
                  C = x.payload;
                  h = typeof C === "function" ? C.call(p, A, h) : C;
                  if (h === null || h === void 0)
                    break a;
                  A = m({}, A, h);
                  break a;
                case 2:
                  wg = true;
              }
            }
            f.callback !== null && (a.flags |= 32, h = e.effects, h === null ? e.effects = [f] : h.push(f));
          } else
            p = {eventTime: p, lane: h, tag: f.tag, payload: f.payload, callback: f.callback, next: null}, n === null ? (l = n = p, k = A) : n = n.next = p, g |= h;
          f = f.next;
          if (f === null)
            if (h = e.shared.pending, h === null)
              break;
            else
              f = h.next, h.next = null, e.lastBaseUpdate = h, e.shared.pending = null;
        } while (1);
        n === null && (k = A);
        e.baseState = k;
        e.firstBaseUpdate = l;
        e.lastBaseUpdate = n;
        Dg |= g;
        a.lanes = g;
        a.memoizedState = A;
      }
    }
    function Eg(a, b, c) {
      a = b.effects;
      b.effects = null;
      if (a !== null)
        for (b = 0; b < a.length; b++) {
          var d = a[b], e = d.callback;
          if (e !== null) {
            d.callback = null;
            d = c;
            if (typeof e !== "function")
              throw Error(y(191, e));
            e.call(d);
          }
        }
    }
    var Fg = new aa.Component().refs;
    function Gg(a, b, c, d) {
      b = a.memoizedState;
      c = c(d, b);
      c = c === null || c === void 0 ? b : m({}, b, c);
      a.memoizedState = c;
      a.lanes === 0 && (a.updateQueue.baseState = c);
    }
    var Kg = {isMounted: function(a) {
      return (a = a._reactInternals) ? Zb(a) === a : false;
    }, enqueueSetState: function(a, b, c) {
      a = a._reactInternals;
      var d = Hg(), e = Ig(a), f = zg(d, e);
      f.payload = b;
      c !== void 0 && c !== null && (f.callback = c);
      Ag(a, f);
      Jg(a, e, d);
    }, enqueueReplaceState: function(a, b, c) {
      a = a._reactInternals;
      var d = Hg(), e = Ig(a), f = zg(d, e);
      f.tag = 1;
      f.payload = b;
      c !== void 0 && c !== null && (f.callback = c);
      Ag(a, f);
      Jg(a, e, d);
    }, enqueueForceUpdate: function(a, b) {
      a = a._reactInternals;
      var c = Hg(), d = Ig(a), e = zg(c, d);
      e.tag = 2;
      b !== void 0 && b !== null && (e.callback = b);
      Ag(a, e);
      Jg(a, d, c);
    }};
    function Lg(a, b, c, d, e, f, g) {
      a = a.stateNode;
      return typeof a.shouldComponentUpdate === "function" ? a.shouldComponentUpdate(d, f, g) : b.prototype && b.prototype.isPureReactComponent ? !Je(c, d) || !Je(e, f) : true;
    }
    function Mg(a, b, c) {
      var d = false, e = Cf;
      var f = b.contextType;
      typeof f === "object" && f !== null ? f = vg(f) : (e = Ff(b) ? Df : M.current, d = b.contextTypes, f = (d = d !== null && d !== void 0) ? Ef(a, e) : Cf);
      b = new b(c, f);
      a.memoizedState = b.state !== null && b.state !== void 0 ? b.state : null;
      b.updater = Kg;
      a.stateNode = b;
      b._reactInternals = a;
      d && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = e, a.__reactInternalMemoizedMaskedChildContext = f);
      return b;
    }
    function Ng(a, b, c, d) {
      a = b.state;
      typeof b.componentWillReceiveProps === "function" && b.componentWillReceiveProps(c, d);
      typeof b.UNSAFE_componentWillReceiveProps === "function" && b.UNSAFE_componentWillReceiveProps(c, d);
      b.state !== a && Kg.enqueueReplaceState(b, b.state, null);
    }
    function Og(a, b, c, d) {
      var e = a.stateNode;
      e.props = c;
      e.state = a.memoizedState;
      e.refs = Fg;
      xg(a);
      var f = b.contextType;
      typeof f === "object" && f !== null ? e.context = vg(f) : (f = Ff(b) ? Df : M.current, e.context = Ef(a, f));
      Cg(a, c, e, d);
      e.state = a.memoizedState;
      f = b.getDerivedStateFromProps;
      typeof f === "function" && (Gg(a, b, f, c), e.state = a.memoizedState);
      typeof b.getDerivedStateFromProps === "function" || typeof e.getSnapshotBeforeUpdate === "function" || typeof e.UNSAFE_componentWillMount !== "function" && typeof e.componentWillMount !== "function" || (b = e.state, typeof e.componentWillMount === "function" && e.componentWillMount(), typeof e.UNSAFE_componentWillMount === "function" && e.UNSAFE_componentWillMount(), b !== e.state && Kg.enqueueReplaceState(e, e.state, null), Cg(a, c, e, d), e.state = a.memoizedState);
      typeof e.componentDidMount === "function" && (a.flags |= 4);
    }
    var Pg = Array.isArray;
    function Qg(a, b, c) {
      a = c.ref;
      if (a !== null && typeof a !== "function" && typeof a !== "object") {
        if (c._owner) {
          c = c._owner;
          if (c) {
            if (c.tag !== 1)
              throw Error(y(309));
            var d = c.stateNode;
          }
          if (!d)
            throw Error(y(147, a));
          var e = "" + a;
          if (b !== null && b.ref !== null && typeof b.ref === "function" && b.ref._stringRef === e)
            return b.ref;
          b = function(a2) {
            var b2 = d.refs;
            b2 === Fg && (b2 = d.refs = {});
            a2 === null ? delete b2[e] : b2[e] = a2;
          };
          b._stringRef = e;
          return b;
        }
        if (typeof a !== "string")
          throw Error(y(284));
        if (!c._owner)
          throw Error(y(290, a));
      }
      return a;
    }
    function Rg(a, b) {
      if (a.type !== "textarea")
        throw Error(y(31, Object.prototype.toString.call(b) === "[object Object]" ? "object with keys {" + Object.keys(b).join(", ") + "}" : b));
    }
    function Sg(a) {
      function b(b2, c2) {
        if (a) {
          var d2 = b2.lastEffect;
          d2 !== null ? (d2.nextEffect = c2, b2.lastEffect = c2) : b2.firstEffect = b2.lastEffect = c2;
          c2.nextEffect = null;
          c2.flags = 8;
        }
      }
      function c(c2, d2) {
        if (!a)
          return null;
        for (; d2 !== null; )
          b(c2, d2), d2 = d2.sibling;
        return null;
      }
      function d(a2, b2) {
        for (a2 = new Map(); b2 !== null; )
          b2.key !== null ? a2.set(b2.key, b2) : a2.set(b2.index, b2), b2 = b2.sibling;
        return a2;
      }
      function e(a2, b2) {
        a2 = Tg(a2, b2);
        a2.index = 0;
        a2.sibling = null;
        return a2;
      }
      function f(b2, c2, d2) {
        b2.index = d2;
        if (!a)
          return c2;
        d2 = b2.alternate;
        if (d2 !== null)
          return d2 = d2.index, d2 < c2 ? (b2.flags = 2, c2) : d2;
        b2.flags = 2;
        return c2;
      }
      function g(b2) {
        a && b2.alternate === null && (b2.flags = 2);
        return b2;
      }
      function h(a2, b2, c2, d2) {
        if (b2 === null || b2.tag !== 6)
          return b2 = Ug(c2, a2.mode, d2), b2.return = a2, b2;
        b2 = e(b2, c2);
        b2.return = a2;
        return b2;
      }
      function k(a2, b2, c2, d2) {
        if (b2 !== null && b2.elementType === c2.type)
          return d2 = e(b2, c2.props), d2.ref = Qg(a2, b2, c2), d2.return = a2, d2;
        d2 = Vg(c2.type, c2.key, c2.props, null, a2.mode, d2);
        d2.ref = Qg(a2, b2, c2);
        d2.return = a2;
        return d2;
      }
      function l(a2, b2, c2, d2) {
        if (b2 === null || b2.tag !== 4 || b2.stateNode.containerInfo !== c2.containerInfo || b2.stateNode.implementation !== c2.implementation)
          return b2 = Wg(c2, a2.mode, d2), b2.return = a2, b2;
        b2 = e(b2, c2.children || []);
        b2.return = a2;
        return b2;
      }
      function n(a2, b2, c2, d2, f2) {
        if (b2 === null || b2.tag !== 7)
          return b2 = Xg(c2, a2.mode, d2, f2), b2.return = a2, b2;
        b2 = e(b2, c2);
        b2.return = a2;
        return b2;
      }
      function A(a2, b2, c2) {
        if (typeof b2 === "string" || typeof b2 === "number")
          return b2 = Ug("" + b2, a2.mode, c2), b2.return = a2, b2;
        if (typeof b2 === "object" && b2 !== null) {
          switch (b2.$$typeof) {
            case sa:
              return c2 = Vg(b2.type, b2.key, b2.props, null, a2.mode, c2), c2.ref = Qg(a2, null, b2), c2.return = a2, c2;
            case ta:
              return b2 = Wg(b2, a2.mode, c2), b2.return = a2, b2;
          }
          if (Pg(b2) || La(b2))
            return b2 = Xg(b2, a2.mode, c2, null), b2.return = a2, b2;
          Rg(a2, b2);
        }
        return null;
      }
      function p(a2, b2, c2, d2) {
        var e2 = b2 !== null ? b2.key : null;
        if (typeof c2 === "string" || typeof c2 === "number")
          return e2 !== null ? null : h(a2, b2, "" + c2, d2);
        if (typeof c2 === "object" && c2 !== null) {
          switch (c2.$$typeof) {
            case sa:
              return c2.key === e2 ? c2.type === ua ? n(a2, b2, c2.props.children, d2, e2) : k(a2, b2, c2, d2) : null;
            case ta:
              return c2.key === e2 ? l(a2, b2, c2, d2) : null;
          }
          if (Pg(c2) || La(c2))
            return e2 !== null ? null : n(a2, b2, c2, d2, null);
          Rg(a2, c2);
        }
        return null;
      }
      function C(a2, b2, c2, d2, e2) {
        if (typeof d2 === "string" || typeof d2 === "number")
          return a2 = a2.get(c2) || null, h(b2, a2, "" + d2, e2);
        if (typeof d2 === "object" && d2 !== null) {
          switch (d2.$$typeof) {
            case sa:
              return a2 = a2.get(d2.key === null ? c2 : d2.key) || null, d2.type === ua ? n(b2, a2, d2.props.children, e2, d2.key) : k(b2, a2, d2, e2);
            case ta:
              return a2 = a2.get(d2.key === null ? c2 : d2.key) || null, l(b2, a2, d2, e2);
          }
          if (Pg(d2) || La(d2))
            return a2 = a2.get(c2) || null, n(b2, a2, d2, e2, null);
          Rg(b2, d2);
        }
        return null;
      }
      function x(e2, g2, h2, k2) {
        for (var l2 = null, t = null, u = g2, z = g2 = 0, q = null; u !== null && z < h2.length; z++) {
          u.index > z ? (q = u, u = null) : q = u.sibling;
          var n2 = p(e2, u, h2[z], k2);
          if (n2 === null) {
            u === null && (u = q);
            break;
          }
          a && u && n2.alternate === null && b(e2, u);
          g2 = f(n2, g2, z);
          t === null ? l2 = n2 : t.sibling = n2;
          t = n2;
          u = q;
        }
        if (z === h2.length)
          return c(e2, u), l2;
        if (u === null) {
          for (; z < h2.length; z++)
            u = A(e2, h2[z], k2), u !== null && (g2 = f(u, g2, z), t === null ? l2 = u : t.sibling = u, t = u);
          return l2;
        }
        for (u = d(e2, u); z < h2.length; z++)
          q = C(u, e2, z, h2[z], k2), q !== null && (a && q.alternate !== null && u.delete(q.key === null ? z : q.key), g2 = f(q, g2, z), t === null ? l2 = q : t.sibling = q, t = q);
        a && u.forEach(function(a2) {
          return b(e2, a2);
        });
        return l2;
      }
      function w(e2, g2, h2, k2) {
        var l2 = La(h2);
        if (typeof l2 !== "function")
          throw Error(y(150));
        h2 = l2.call(h2);
        if (h2 == null)
          throw Error(y(151));
        for (var t = l2 = null, u = g2, z = g2 = 0, q = null, n2 = h2.next(); u !== null && !n2.done; z++, n2 = h2.next()) {
          u.index > z ? (q = u, u = null) : q = u.sibling;
          var w2 = p(e2, u, n2.value, k2);
          if (w2 === null) {
            u === null && (u = q);
            break;
          }
          a && u && w2.alternate === null && b(e2, u);
          g2 = f(w2, g2, z);
          t === null ? l2 = w2 : t.sibling = w2;
          t = w2;
          u = q;
        }
        if (n2.done)
          return c(e2, u), l2;
        if (u === null) {
          for (; !n2.done; z++, n2 = h2.next())
            n2 = A(e2, n2.value, k2), n2 !== null && (g2 = f(n2, g2, z), t === null ? l2 = n2 : t.sibling = n2, t = n2);
          return l2;
        }
        for (u = d(e2, u); !n2.done; z++, n2 = h2.next())
          n2 = C(u, e2, z, n2.value, k2), n2 !== null && (a && n2.alternate !== null && u.delete(n2.key === null ? z : n2.key), g2 = f(n2, g2, z), t === null ? l2 = n2 : t.sibling = n2, t = n2);
        a && u.forEach(function(a2) {
          return b(e2, a2);
        });
        return l2;
      }
      return function(a2, d2, f2, h2) {
        var k2 = typeof f2 === "object" && f2 !== null && f2.type === ua && f2.key === null;
        k2 && (f2 = f2.props.children);
        var l2 = typeof f2 === "object" && f2 !== null;
        if (l2)
          switch (f2.$$typeof) {
            case sa:
              a: {
                l2 = f2.key;
                for (k2 = d2; k2 !== null; ) {
                  if (k2.key === l2) {
                    switch (k2.tag) {
                      case 7:
                        if (f2.type === ua) {
                          c(a2, k2.sibling);
                          d2 = e(k2, f2.props.children);
                          d2.return = a2;
                          a2 = d2;
                          break a;
                        }
                        break;
                      default:
                        if (k2.elementType === f2.type) {
                          c(a2, k2.sibling);
                          d2 = e(k2, f2.props);
                          d2.ref = Qg(a2, k2, f2);
                          d2.return = a2;
                          a2 = d2;
                          break a;
                        }
                    }
                    c(a2, k2);
                    break;
                  } else
                    b(a2, k2);
                  k2 = k2.sibling;
                }
                f2.type === ua ? (d2 = Xg(f2.props.children, a2.mode, h2, f2.key), d2.return = a2, a2 = d2) : (h2 = Vg(f2.type, f2.key, f2.props, null, a2.mode, h2), h2.ref = Qg(a2, d2, f2), h2.return = a2, a2 = h2);
              }
              return g(a2);
            case ta:
              a: {
                for (k2 = f2.key; d2 !== null; ) {
                  if (d2.key === k2)
                    if (d2.tag === 4 && d2.stateNode.containerInfo === f2.containerInfo && d2.stateNode.implementation === f2.implementation) {
                      c(a2, d2.sibling);
                      d2 = e(d2, f2.children || []);
                      d2.return = a2;
                      a2 = d2;
                      break a;
                    } else {
                      c(a2, d2);
                      break;
                    }
                  else
                    b(a2, d2);
                  d2 = d2.sibling;
                }
                d2 = Wg(f2, a2.mode, h2);
                d2.return = a2;
                a2 = d2;
              }
              return g(a2);
          }
        if (typeof f2 === "string" || typeof f2 === "number")
          return f2 = "" + f2, d2 !== null && d2.tag === 6 ? (c(a2, d2.sibling), d2 = e(d2, f2), d2.return = a2, a2 = d2) : (c(a2, d2), d2 = Ug(f2, a2.mode, h2), d2.return = a2, a2 = d2), g(a2);
        if (Pg(f2))
          return x(a2, d2, f2, h2);
        if (La(f2))
          return w(a2, d2, f2, h2);
        l2 && Rg(a2, f2);
        if (typeof f2 === "undefined" && !k2)
          switch (a2.tag) {
            case 1:
            case 22:
            case 0:
            case 11:
            case 15:
              throw Error(y(152, Ra(a2.type) || "Component"));
          }
        return c(a2, d2);
      };
    }
    var Yg = Sg(true);
    var Zg = Sg(false);
    var $g = {};
    var ah = Bf($g);
    var bh = Bf($g);
    var ch = Bf($g);
    function dh(a) {
      if (a === $g)
        throw Error(y(174));
      return a;
    }
    function eh(a, b) {
      I(ch, b);
      I(bh, a);
      I(ah, $g);
      a = b.nodeType;
      switch (a) {
        case 9:
        case 11:
          b = (b = b.documentElement) ? b.namespaceURI : mb(null, "");
          break;
        default:
          a = a === 8 ? b.parentNode : b, b = a.namespaceURI || null, a = a.tagName, b = mb(b, a);
      }
      H(ah);
      I(ah, b);
    }
    function fh() {
      H(ah);
      H(bh);
      H(ch);
    }
    function gh(a) {
      dh(ch.current);
      var b = dh(ah.current);
      var c = mb(b, a.type);
      b !== c && (I(bh, a), I(ah, c));
    }
    function hh(a) {
      bh.current === a && (H(ah), H(bh));
    }
    var P = Bf(0);
    function ih(a) {
      for (var b = a; b !== null; ) {
        if (b.tag === 13) {
          var c = b.memoizedState;
          if (c !== null && (c = c.dehydrated, c === null || c.data === "$?" || c.data === "$!"))
            return b;
        } else if (b.tag === 19 && b.memoizedProps.revealOrder !== void 0) {
          if ((b.flags & 64) !== 0)
            return b;
        } else if (b.child !== null) {
          b.child.return = b;
          b = b.child;
          continue;
        }
        if (b === a)
          break;
        for (; b.sibling === null; ) {
          if (b.return === null || b.return === a)
            return null;
          b = b.return;
        }
        b.sibling.return = b.return;
        b = b.sibling;
      }
      return null;
    }
    var jh = null;
    var kh = null;
    var lh = false;
    function mh(a, b) {
      var c = nh(5, null, null, 0);
      c.elementType = "DELETED";
      c.type = "DELETED";
      c.stateNode = b;
      c.return = a;
      c.flags = 8;
      a.lastEffect !== null ? (a.lastEffect.nextEffect = c, a.lastEffect = c) : a.firstEffect = a.lastEffect = c;
    }
    function oh(a, b) {
      switch (a.tag) {
        case 5:
          var c = a.type;
          b = b.nodeType !== 1 || c.toLowerCase() !== b.nodeName.toLowerCase() ? null : b;
          return b !== null ? (a.stateNode = b, true) : false;
        case 6:
          return b = a.pendingProps === "" || b.nodeType !== 3 ? null : b, b !== null ? (a.stateNode = b, true) : false;
        case 13:
          return false;
        default:
          return false;
      }
    }
    function ph(a) {
      if (lh) {
        var b = kh;
        if (b) {
          var c = b;
          if (!oh(a, b)) {
            b = rf(c.nextSibling);
            if (!b || !oh(a, b)) {
              a.flags = a.flags & -1025 | 2;
              lh = false;
              jh = a;
              return;
            }
            mh(jh, c);
          }
          jh = a;
          kh = rf(b.firstChild);
        } else
          a.flags = a.flags & -1025 | 2, lh = false, jh = a;
      }
    }
    function qh(a) {
      for (a = a.return; a !== null && a.tag !== 5 && a.tag !== 3 && a.tag !== 13; )
        a = a.return;
      jh = a;
    }
    function rh(a) {
      if (a !== jh)
        return false;
      if (!lh)
        return qh(a), lh = true, false;
      var b = a.type;
      if (a.tag !== 5 || b !== "head" && b !== "body" && !nf(b, a.memoizedProps))
        for (b = kh; b; )
          mh(a, b), b = rf(b.nextSibling);
      qh(a);
      if (a.tag === 13) {
        a = a.memoizedState;
        a = a !== null ? a.dehydrated : null;
        if (!a)
          throw Error(y(317));
        a: {
          a = a.nextSibling;
          for (b = 0; a; ) {
            if (a.nodeType === 8) {
              var c = a.data;
              if (c === "/$") {
                if (b === 0) {
                  kh = rf(a.nextSibling);
                  break a;
                }
                b--;
              } else
                c !== "$" && c !== "$!" && c !== "$?" || b++;
            }
            a = a.nextSibling;
          }
          kh = null;
        }
      } else
        kh = jh ? rf(a.stateNode.nextSibling) : null;
      return true;
    }
    function sh() {
      kh = jh = null;
      lh = false;
    }
    var th = [];
    function uh() {
      for (var a = 0; a < th.length; a++)
        th[a]._workInProgressVersionPrimary = null;
      th.length = 0;
    }
    var vh = ra.ReactCurrentDispatcher;
    var wh = ra.ReactCurrentBatchConfig;
    var xh = 0;
    var R = null;
    var S = null;
    var T = null;
    var yh = false;
    var zh = false;
    function Ah() {
      throw Error(y(321));
    }
    function Bh(a, b) {
      if (b === null)
        return false;
      for (var c = 0; c < b.length && c < a.length; c++)
        if (!He(a[c], b[c]))
          return false;
      return true;
    }
    function Ch(a, b, c, d, e, f) {
      xh = f;
      R = b;
      b.memoizedState = null;
      b.updateQueue = null;
      b.lanes = 0;
      vh.current = a === null || a.memoizedState === null ? Dh : Eh;
      a = c(d, e);
      if (zh) {
        f = 0;
        do {
          zh = false;
          if (!(25 > f))
            throw Error(y(301));
          f += 1;
          T = S = null;
          b.updateQueue = null;
          vh.current = Fh;
          a = c(d, e);
        } while (zh);
      }
      vh.current = Gh;
      b = S !== null && S.next !== null;
      xh = 0;
      T = S = R = null;
      yh = false;
      if (b)
        throw Error(y(300));
      return a;
    }
    function Hh() {
      var a = {memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null};
      T === null ? R.memoizedState = T = a : T = T.next = a;
      return T;
    }
    function Ih() {
      if (S === null) {
        var a = R.alternate;
        a = a !== null ? a.memoizedState : null;
      } else
        a = S.next;
      var b = T === null ? R.memoizedState : T.next;
      if (b !== null)
        T = b, S = a;
      else {
        if (a === null)
          throw Error(y(310));
        S = a;
        a = {memoizedState: S.memoizedState, baseState: S.baseState, baseQueue: S.baseQueue, queue: S.queue, next: null};
        T === null ? R.memoizedState = T = a : T = T.next = a;
      }
      return T;
    }
    function Jh(a, b) {
      return typeof b === "function" ? b(a) : b;
    }
    function Kh(a) {
      var b = Ih(), c = b.queue;
      if (c === null)
        throw Error(y(311));
      c.lastRenderedReducer = a;
      var d = S, e = d.baseQueue, f = c.pending;
      if (f !== null) {
        if (e !== null) {
          var g = e.next;
          e.next = f.next;
          f.next = g;
        }
        d.baseQueue = e = f;
        c.pending = null;
      }
      if (e !== null) {
        e = e.next;
        d = d.baseState;
        var h = g = f = null, k = e;
        do {
          var l = k.lane;
          if ((xh & l) === l)
            h !== null && (h = h.next = {lane: 0, action: k.action, eagerReducer: k.eagerReducer, eagerState: k.eagerState, next: null}), d = k.eagerReducer === a ? k.eagerState : a(d, k.action);
          else {
            var n = {
              lane: l,
              action: k.action,
              eagerReducer: k.eagerReducer,
              eagerState: k.eagerState,
              next: null
            };
            h === null ? (g = h = n, f = d) : h = h.next = n;
            R.lanes |= l;
            Dg |= l;
          }
          k = k.next;
        } while (k !== null && k !== e);
        h === null ? f = d : h.next = g;
        He(d, b.memoizedState) || (ug = true);
        b.memoizedState = d;
        b.baseState = f;
        b.baseQueue = h;
        c.lastRenderedState = d;
      }
      return [b.memoizedState, c.dispatch];
    }
    function Lh(a) {
      var b = Ih(), c = b.queue;
      if (c === null)
        throw Error(y(311));
      c.lastRenderedReducer = a;
      var d = c.dispatch, e = c.pending, f = b.memoizedState;
      if (e !== null) {
        c.pending = null;
        var g = e = e.next;
        do
          f = a(f, g.action), g = g.next;
        while (g !== e);
        He(f, b.memoizedState) || (ug = true);
        b.memoizedState = f;
        b.baseQueue === null && (b.baseState = f);
        c.lastRenderedState = f;
      }
      return [f, d];
    }
    function Mh(a, b, c) {
      var d = b._getVersion;
      d = d(b._source);
      var e = b._workInProgressVersionPrimary;
      if (e !== null)
        a = e === d;
      else if (a = a.mutableReadLanes, a = (xh & a) === a)
        b._workInProgressVersionPrimary = d, th.push(b);
      if (a)
        return c(b._source);
      th.push(b);
      throw Error(y(350));
    }
    function Nh(a, b, c, d) {
      var e = U;
      if (e === null)
        throw Error(y(349));
      var f = b._getVersion, g = f(b._source), h = vh.current, k = h.useState(function() {
        return Mh(e, b, c);
      }), l = k[1], n = k[0];
      k = T;
      var A = a.memoizedState, p = A.refs, C = p.getSnapshot, x = A.source;
      A = A.subscribe;
      var w = R;
      a.memoizedState = {refs: p, source: b, subscribe: d};
      h.useEffect(function() {
        p.getSnapshot = c;
        p.setSnapshot = l;
        var a2 = f(b._source);
        if (!He(g, a2)) {
          a2 = c(b._source);
          He(n, a2) || (l(a2), a2 = Ig(w), e.mutableReadLanes |= a2 & e.pendingLanes);
          a2 = e.mutableReadLanes;
          e.entangledLanes |= a2;
          for (var d2 = e.entanglements, h2 = a2; 0 < h2; ) {
            var k2 = 31 - Vc(h2), v = 1 << k2;
            d2[k2] |= a2;
            h2 &= ~v;
          }
        }
      }, [c, b, d]);
      h.useEffect(function() {
        return d(b._source, function() {
          var a2 = p.getSnapshot, c2 = p.setSnapshot;
          try {
            c2(a2(b._source));
            var d2 = Ig(w);
            e.mutableReadLanes |= d2 & e.pendingLanes;
          } catch (q) {
            c2(function() {
              throw q;
            });
          }
        });
      }, [b, d]);
      He(C, c) && He(x, b) && He(A, d) || (a = {pending: null, dispatch: null, lastRenderedReducer: Jh, lastRenderedState: n}, a.dispatch = l = Oh.bind(null, R, a), k.queue = a, k.baseQueue = null, n = Mh(e, b, c), k.memoizedState = k.baseState = n);
      return n;
    }
    function Ph(a, b, c) {
      var d = Ih();
      return Nh(d, a, b, c);
    }
    function Qh(a) {
      var b = Hh();
      typeof a === "function" && (a = a());
      b.memoizedState = b.baseState = a;
      a = b.queue = {pending: null, dispatch: null, lastRenderedReducer: Jh, lastRenderedState: a};
      a = a.dispatch = Oh.bind(null, R, a);
      return [b.memoizedState, a];
    }
    function Rh(a, b, c, d) {
      a = {tag: a, create: b, destroy: c, deps: d, next: null};
      b = R.updateQueue;
      b === null ? (b = {lastEffect: null}, R.updateQueue = b, b.lastEffect = a.next = a) : (c = b.lastEffect, c === null ? b.lastEffect = a.next = a : (d = c.next, c.next = a, a.next = d, b.lastEffect = a));
      return a;
    }
    function Sh(a) {
      var b = Hh();
      a = {current: a};
      return b.memoizedState = a;
    }
    function Th() {
      return Ih().memoizedState;
    }
    function Uh(a, b, c, d) {
      var e = Hh();
      R.flags |= a;
      e.memoizedState = Rh(1 | b, c, void 0, d === void 0 ? null : d);
    }
    function Vh(a, b, c, d) {
      var e = Ih();
      d = d === void 0 ? null : d;
      var f = void 0;
      if (S !== null) {
        var g = S.memoizedState;
        f = g.destroy;
        if (d !== null && Bh(d, g.deps)) {
          Rh(b, c, f, d);
          return;
        }
      }
      R.flags |= a;
      e.memoizedState = Rh(1 | b, c, f, d);
    }
    function Wh(a, b) {
      return Uh(516, 4, a, b);
    }
    function Xh(a, b) {
      return Vh(516, 4, a, b);
    }
    function Yh(a, b) {
      return Vh(4, 2, a, b);
    }
    function Zh(a, b) {
      if (typeof b === "function")
        return a = a(), b(a), function() {
          b(null);
        };
      if (b !== null && b !== void 0)
        return a = a(), b.current = a, function() {
          b.current = null;
        };
    }
    function $h(a, b, c) {
      c = c !== null && c !== void 0 ? c.concat([a]) : null;
      return Vh(4, 2, Zh.bind(null, b, a), c);
    }
    function ai() {
    }
    function bi(a, b) {
      var c = Ih();
      b = b === void 0 ? null : b;
      var d = c.memoizedState;
      if (d !== null && b !== null && Bh(b, d[1]))
        return d[0];
      c.memoizedState = [a, b];
      return a;
    }
    function ci(a, b) {
      var c = Ih();
      b = b === void 0 ? null : b;
      var d = c.memoizedState;
      if (d !== null && b !== null && Bh(b, d[1]))
        return d[0];
      a = a();
      c.memoizedState = [a, b];
      return a;
    }
    function di(a, b) {
      var c = eg();
      gg(98 > c ? 98 : c, function() {
        a(true);
      });
      gg(97 < c ? 97 : c, function() {
        var c2 = wh.transition;
        wh.transition = 1;
        try {
          a(false), b();
        } finally {
          wh.transition = c2;
        }
      });
    }
    function Oh(a, b, c) {
      var d = Hg(), e = Ig(a), f = {lane: e, action: c, eagerReducer: null, eagerState: null, next: null}, g = b.pending;
      g === null ? f.next = f : (f.next = g.next, g.next = f);
      b.pending = f;
      g = a.alternate;
      if (a === R || g !== null && g === R)
        zh = yh = true;
      else {
        if (a.lanes === 0 && (g === null || g.lanes === 0) && (g = b.lastRenderedReducer, g !== null))
          try {
            var h = b.lastRenderedState, k = g(h, c);
            f.eagerReducer = g;
            f.eagerState = k;
            if (He(k, h))
              return;
          } catch (l) {
          } finally {
          }
        Jg(a, e, d);
      }
    }
    var Gh = {readContext: vg, useCallback: Ah, useContext: Ah, useEffect: Ah, useImperativeHandle: Ah, useLayoutEffect: Ah, useMemo: Ah, useReducer: Ah, useRef: Ah, useState: Ah, useDebugValue: Ah, useDeferredValue: Ah, useTransition: Ah, useMutableSource: Ah, useOpaqueIdentifier: Ah, unstable_isNewReconciler: false};
    var Dh = {readContext: vg, useCallback: function(a, b) {
      Hh().memoizedState = [a, b === void 0 ? null : b];
      return a;
    }, useContext: vg, useEffect: Wh, useImperativeHandle: function(a, b, c) {
      c = c !== null && c !== void 0 ? c.concat([a]) : null;
      return Uh(4, 2, Zh.bind(null, b, a), c);
    }, useLayoutEffect: function(a, b) {
      return Uh(4, 2, a, b);
    }, useMemo: function(a, b) {
      var c = Hh();
      b = b === void 0 ? null : b;
      a = a();
      c.memoizedState = [a, b];
      return a;
    }, useReducer: function(a, b, c) {
      var d = Hh();
      b = c !== void 0 ? c(b) : b;
      d.memoizedState = d.baseState = b;
      a = d.queue = {pending: null, dispatch: null, lastRenderedReducer: a, lastRenderedState: b};
      a = a.dispatch = Oh.bind(null, R, a);
      return [d.memoizedState, a];
    }, useRef: Sh, useState: Qh, useDebugValue: ai, useDeferredValue: function(a) {
      var b = Qh(a), c = b[0], d = b[1];
      Wh(function() {
        var b2 = wh.transition;
        wh.transition = 1;
        try {
          d(a);
        } finally {
          wh.transition = b2;
        }
      }, [a]);
      return c;
    }, useTransition: function() {
      var a = Qh(false), b = a[0];
      a = di.bind(null, a[1]);
      Sh(a);
      return [a, b];
    }, useMutableSource: function(a, b, c) {
      var d = Hh();
      d.memoizedState = {refs: {getSnapshot: b, setSnapshot: null}, source: a, subscribe: c};
      return Nh(d, a, b, c);
    }, useOpaqueIdentifier: function() {
      if (lh) {
        var a = false, b = uf(function() {
          a || (a = true, c("r:" + (tf++).toString(36)));
          throw Error(y(355));
        }), c = Qh(b)[1];
        (R.mode & 2) === 0 && (R.flags |= 516, Rh(5, function() {
          c("r:" + (tf++).toString(36));
        }, void 0, null));
        return b;
      }
      b = "r:" + (tf++).toString(36);
      Qh(b);
      return b;
    }, unstable_isNewReconciler: false};
    var Eh = {readContext: vg, useCallback: bi, useContext: vg, useEffect: Xh, useImperativeHandle: $h, useLayoutEffect: Yh, useMemo: ci, useReducer: Kh, useRef: Th, useState: function() {
      return Kh(Jh);
    }, useDebugValue: ai, useDeferredValue: function(a) {
      var b = Kh(Jh), c = b[0], d = b[1];
      Xh(function() {
        var b2 = wh.transition;
        wh.transition = 1;
        try {
          d(a);
        } finally {
          wh.transition = b2;
        }
      }, [a]);
      return c;
    }, useTransition: function() {
      var a = Kh(Jh)[0];
      return [
        Th().current,
        a
      ];
    }, useMutableSource: Ph, useOpaqueIdentifier: function() {
      return Kh(Jh)[0];
    }, unstable_isNewReconciler: false};
    var Fh = {readContext: vg, useCallback: bi, useContext: vg, useEffect: Xh, useImperativeHandle: $h, useLayoutEffect: Yh, useMemo: ci, useReducer: Lh, useRef: Th, useState: function() {
      return Lh(Jh);
    }, useDebugValue: ai, useDeferredValue: function(a) {
      var b = Lh(Jh), c = b[0], d = b[1];
      Xh(function() {
        var b2 = wh.transition;
        wh.transition = 1;
        try {
          d(a);
        } finally {
          wh.transition = b2;
        }
      }, [a]);
      return c;
    }, useTransition: function() {
      var a = Lh(Jh)[0];
      return [
        Th().current,
        a
      ];
    }, useMutableSource: Ph, useOpaqueIdentifier: function() {
      return Lh(Jh)[0];
    }, unstable_isNewReconciler: false};
    var ei = ra.ReactCurrentOwner;
    var ug = false;
    function fi(a, b, c, d) {
      b.child = a === null ? Zg(b, null, c, d) : Yg(b, a.child, c, d);
    }
    function gi(a, b, c, d, e) {
      c = c.render;
      var f = b.ref;
      tg(b, e);
      d = Ch(a, b, c, d, f, e);
      if (a !== null && !ug)
        return b.updateQueue = a.updateQueue, b.flags &= -517, a.lanes &= ~e, hi(a, b, e);
      b.flags |= 1;
      fi(a, b, d, e);
      return b.child;
    }
    function ii(a, b, c, d, e, f) {
      if (a === null) {
        var g = c.type;
        if (typeof g === "function" && !ji(g) && g.defaultProps === void 0 && c.compare === null && c.defaultProps === void 0)
          return b.tag = 15, b.type = g, ki(a, b, g, d, e, f);
        a = Vg(c.type, null, d, b, b.mode, f);
        a.ref = b.ref;
        a.return = b;
        return b.child = a;
      }
      g = a.child;
      if ((e & f) === 0 && (e = g.memoizedProps, c = c.compare, c = c !== null ? c : Je, c(e, d) && a.ref === b.ref))
        return hi(a, b, f);
      b.flags |= 1;
      a = Tg(g, d);
      a.ref = b.ref;
      a.return = b;
      return b.child = a;
    }
    function ki(a, b, c, d, e, f) {
      if (a !== null && Je(a.memoizedProps, d) && a.ref === b.ref)
        if (ug = false, (f & e) !== 0)
          (a.flags & 16384) !== 0 && (ug = true);
        else
          return b.lanes = a.lanes, hi(a, b, f);
      return li(a, b, c, d, f);
    }
    function mi(a, b, c) {
      var d = b.pendingProps, e = d.children, f = a !== null ? a.memoizedState : null;
      if (d.mode === "hidden" || d.mode === "unstable-defer-without-hiding")
        if ((b.mode & 4) === 0)
          b.memoizedState = {baseLanes: 0}, ni(b, c);
        else if ((c & 1073741824) !== 0)
          b.memoizedState = {baseLanes: 0}, ni(b, f !== null ? f.baseLanes : c);
        else
          return a = f !== null ? f.baseLanes | c : c, b.lanes = b.childLanes = 1073741824, b.memoizedState = {baseLanes: a}, ni(b, a), null;
      else
        f !== null ? (d = f.baseLanes | c, b.memoizedState = null) : d = c, ni(b, d);
      fi(a, b, e, c);
      return b.child;
    }
    function oi(a, b) {
      var c = b.ref;
      if (a === null && c !== null || a !== null && a.ref !== c)
        b.flags |= 128;
    }
    function li(a, b, c, d, e) {
      var f = Ff(c) ? Df : M.current;
      f = Ef(b, f);
      tg(b, e);
      c = Ch(a, b, c, d, f, e);
      if (a !== null && !ug)
        return b.updateQueue = a.updateQueue, b.flags &= -517, a.lanes &= ~e, hi(a, b, e);
      b.flags |= 1;
      fi(a, b, c, e);
      return b.child;
    }
    function pi(a, b, c, d, e) {
      if (Ff(c)) {
        var f = true;
        Jf(b);
      } else
        f = false;
      tg(b, e);
      if (b.stateNode === null)
        a !== null && (a.alternate = null, b.alternate = null, b.flags |= 2), Mg(b, c, d), Og(b, c, d, e), d = true;
      else if (a === null) {
        var g = b.stateNode, h = b.memoizedProps;
        g.props = h;
        var k = g.context, l = c.contextType;
        typeof l === "object" && l !== null ? l = vg(l) : (l = Ff(c) ? Df : M.current, l = Ef(b, l));
        var n = c.getDerivedStateFromProps, A = typeof n === "function" || typeof g.getSnapshotBeforeUpdate === "function";
        A || typeof g.UNSAFE_componentWillReceiveProps !== "function" && typeof g.componentWillReceiveProps !== "function" || (h !== d || k !== l) && Ng(b, g, d, l);
        wg = false;
        var p = b.memoizedState;
        g.state = p;
        Cg(b, d, g, e);
        k = b.memoizedState;
        h !== d || p !== k || N.current || wg ? (typeof n === "function" && (Gg(b, c, n, d), k = b.memoizedState), (h = wg || Lg(b, c, h, d, p, k, l)) ? (A || typeof g.UNSAFE_componentWillMount !== "function" && typeof g.componentWillMount !== "function" || (typeof g.componentWillMount === "function" && g.componentWillMount(), typeof g.UNSAFE_componentWillMount === "function" && g.UNSAFE_componentWillMount()), typeof g.componentDidMount === "function" && (b.flags |= 4)) : (typeof g.componentDidMount === "function" && (b.flags |= 4), b.memoizedProps = d, b.memoizedState = k), g.props = d, g.state = k, g.context = l, d = h) : (typeof g.componentDidMount === "function" && (b.flags |= 4), d = false);
      } else {
        g = b.stateNode;
        yg(a, b);
        h = b.memoizedProps;
        l = b.type === b.elementType ? h : lg(b.type, h);
        g.props = l;
        A = b.pendingProps;
        p = g.context;
        k = c.contextType;
        typeof k === "object" && k !== null ? k = vg(k) : (k = Ff(c) ? Df : M.current, k = Ef(b, k));
        var C = c.getDerivedStateFromProps;
        (n = typeof C === "function" || typeof g.getSnapshotBeforeUpdate === "function") || typeof g.UNSAFE_componentWillReceiveProps !== "function" && typeof g.componentWillReceiveProps !== "function" || (h !== A || p !== k) && Ng(b, g, d, k);
        wg = false;
        p = b.memoizedState;
        g.state = p;
        Cg(b, d, g, e);
        var x = b.memoizedState;
        h !== A || p !== x || N.current || wg ? (typeof C === "function" && (Gg(b, c, C, d), x = b.memoizedState), (l = wg || Lg(b, c, l, d, p, x, k)) ? (n || typeof g.UNSAFE_componentWillUpdate !== "function" && typeof g.componentWillUpdate !== "function" || (typeof g.componentWillUpdate === "function" && g.componentWillUpdate(d, x, k), typeof g.UNSAFE_componentWillUpdate === "function" && g.UNSAFE_componentWillUpdate(d, x, k)), typeof g.componentDidUpdate === "function" && (b.flags |= 4), typeof g.getSnapshotBeforeUpdate === "function" && (b.flags |= 256)) : (typeof g.componentDidUpdate !== "function" || h === a.memoizedProps && p === a.memoizedState || (b.flags |= 4), typeof g.getSnapshotBeforeUpdate !== "function" || h === a.memoizedProps && p === a.memoizedState || (b.flags |= 256), b.memoizedProps = d, b.memoizedState = x), g.props = d, g.state = x, g.context = k, d = l) : (typeof g.componentDidUpdate !== "function" || h === a.memoizedProps && p === a.memoizedState || (b.flags |= 4), typeof g.getSnapshotBeforeUpdate !== "function" || h === a.memoizedProps && p === a.memoizedState || (b.flags |= 256), d = false);
      }
      return qi(a, b, c, d, f, e);
    }
    function qi(a, b, c, d, e, f) {
      oi(a, b);
      var g = (b.flags & 64) !== 0;
      if (!d && !g)
        return e && Kf(b, c, false), hi(a, b, f);
      d = b.stateNode;
      ei.current = b;
      var h = g && typeof c.getDerivedStateFromError !== "function" ? null : d.render();
      b.flags |= 1;
      a !== null && g ? (b.child = Yg(b, a.child, null, f), b.child = Yg(b, null, h, f)) : fi(a, b, h, f);
      b.memoizedState = d.state;
      e && Kf(b, c, true);
      return b.child;
    }
    function ri(a) {
      var b = a.stateNode;
      b.pendingContext ? Hf(a, b.pendingContext, b.pendingContext !== b.context) : b.context && Hf(a, b.context, false);
      eh(a, b.containerInfo);
    }
    var si = {dehydrated: null, retryLane: 0};
    function ti(a, b, c) {
      var d = b.pendingProps, e = P.current, f = false, g;
      (g = (b.flags & 64) !== 0) || (g = a !== null && a.memoizedState === null ? false : (e & 2) !== 0);
      g ? (f = true, b.flags &= -65) : a !== null && a.memoizedState === null || d.fallback === void 0 || d.unstable_avoidThisFallback === true || (e |= 1);
      I(P, e & 1);
      if (a === null) {
        d.fallback !== void 0 && ph(b);
        a = d.children;
        e = d.fallback;
        if (f)
          return a = ui(b, a, e, c), b.child.memoizedState = {baseLanes: c}, b.memoizedState = si, a;
        if (typeof d.unstable_expectedLoadTime === "number")
          return a = ui(b, a, e, c), b.child.memoizedState = {baseLanes: c}, b.memoizedState = si, b.lanes = 33554432, a;
        c = vi({mode: "visible", children: a}, b.mode, c, null);
        c.return = b;
        return b.child = c;
      }
      if (a.memoizedState !== null) {
        if (f)
          return d = wi(a, b, d.children, d.fallback, c), f = b.child, e = a.child.memoizedState, f.memoizedState = e === null ? {baseLanes: c} : {baseLanes: e.baseLanes | c}, f.childLanes = a.childLanes & ~c, b.memoizedState = si, d;
        c = xi(a, b, d.children, c);
        b.memoizedState = null;
        return c;
      }
      if (f)
        return d = wi(a, b, d.children, d.fallback, c), f = b.child, e = a.child.memoizedState, f.memoizedState = e === null ? {baseLanes: c} : {baseLanes: e.baseLanes | c}, f.childLanes = a.childLanes & ~c, b.memoizedState = si, d;
      c = xi(a, b, d.children, c);
      b.memoizedState = null;
      return c;
    }
    function ui(a, b, c, d) {
      var e = a.mode, f = a.child;
      b = {mode: "hidden", children: b};
      (e & 2) === 0 && f !== null ? (f.childLanes = 0, f.pendingProps = b) : f = vi(b, e, 0, null);
      c = Xg(c, e, d, null);
      f.return = a;
      c.return = a;
      f.sibling = c;
      a.child = f;
      return c;
    }
    function xi(a, b, c, d) {
      var e = a.child;
      a = e.sibling;
      c = Tg(e, {mode: "visible", children: c});
      (b.mode & 2) === 0 && (c.lanes = d);
      c.return = b;
      c.sibling = null;
      a !== null && (a.nextEffect = null, a.flags = 8, b.firstEffect = b.lastEffect = a);
      return b.child = c;
    }
    function wi(a, b, c, d, e) {
      var f = b.mode, g = a.child;
      a = g.sibling;
      var h = {mode: "hidden", children: c};
      (f & 2) === 0 && b.child !== g ? (c = b.child, c.childLanes = 0, c.pendingProps = h, g = c.lastEffect, g !== null ? (b.firstEffect = c.firstEffect, b.lastEffect = g, g.nextEffect = null) : b.firstEffect = b.lastEffect = null) : c = Tg(g, h);
      a !== null ? d = Tg(a, d) : (d = Xg(d, f, e, null), d.flags |= 2);
      d.return = b;
      c.return = b;
      c.sibling = d;
      b.child = c;
      return d;
    }
    function yi(a, b) {
      a.lanes |= b;
      var c = a.alternate;
      c !== null && (c.lanes |= b);
      sg(a.return, b);
    }
    function zi(a, b, c, d, e, f) {
      var g = a.memoizedState;
      g === null ? a.memoizedState = {isBackwards: b, rendering: null, renderingStartTime: 0, last: d, tail: c, tailMode: e, lastEffect: f} : (g.isBackwards = b, g.rendering = null, g.renderingStartTime = 0, g.last = d, g.tail = c, g.tailMode = e, g.lastEffect = f);
    }
    function Ai(a, b, c) {
      var d = b.pendingProps, e = d.revealOrder, f = d.tail;
      fi(a, b, d.children, c);
      d = P.current;
      if ((d & 2) !== 0)
        d = d & 1 | 2, b.flags |= 64;
      else {
        if (a !== null && (a.flags & 64) !== 0)
          a:
            for (a = b.child; a !== null; ) {
              if (a.tag === 13)
                a.memoizedState !== null && yi(a, c);
              else if (a.tag === 19)
                yi(a, c);
              else if (a.child !== null) {
                a.child.return = a;
                a = a.child;
                continue;
              }
              if (a === b)
                break a;
              for (; a.sibling === null; ) {
                if (a.return === null || a.return === b)
                  break a;
                a = a.return;
              }
              a.sibling.return = a.return;
              a = a.sibling;
            }
        d &= 1;
      }
      I(P, d);
      if ((b.mode & 2) === 0)
        b.memoizedState = null;
      else
        switch (e) {
          case "forwards":
            c = b.child;
            for (e = null; c !== null; )
              a = c.alternate, a !== null && ih(a) === null && (e = c), c = c.sibling;
            c = e;
            c === null ? (e = b.child, b.child = null) : (e = c.sibling, c.sibling = null);
            zi(b, false, e, c, f, b.lastEffect);
            break;
          case "backwards":
            c = null;
            e = b.child;
            for (b.child = null; e !== null; ) {
              a = e.alternate;
              if (a !== null && ih(a) === null) {
                b.child = e;
                break;
              }
              a = e.sibling;
              e.sibling = c;
              c = e;
              e = a;
            }
            zi(b, true, c, null, f, b.lastEffect);
            break;
          case "together":
            zi(b, false, null, null, void 0, b.lastEffect);
            break;
          default:
            b.memoizedState = null;
        }
      return b.child;
    }
    function hi(a, b, c) {
      a !== null && (b.dependencies = a.dependencies);
      Dg |= b.lanes;
      if ((c & b.childLanes) !== 0) {
        if (a !== null && b.child !== a.child)
          throw Error(y(153));
        if (b.child !== null) {
          a = b.child;
          c = Tg(a, a.pendingProps);
          b.child = c;
          for (c.return = b; a.sibling !== null; )
            a = a.sibling, c = c.sibling = Tg(a, a.pendingProps), c.return = b;
          c.sibling = null;
        }
        return b.child;
      }
      return null;
    }
    var Bi;
    var Ci;
    var Di;
    var Ei;
    Bi = function(a, b) {
      for (var c = b.child; c !== null; ) {
        if (c.tag === 5 || c.tag === 6)
          a.appendChild(c.stateNode);
        else if (c.tag !== 4 && c.child !== null) {
          c.child.return = c;
          c = c.child;
          continue;
        }
        if (c === b)
          break;
        for (; c.sibling === null; ) {
          if (c.return === null || c.return === b)
            return;
          c = c.return;
        }
        c.sibling.return = c.return;
        c = c.sibling;
      }
    };
    Ci = function() {
    };
    Di = function(a, b, c, d) {
      var e = a.memoizedProps;
      if (e !== d) {
        a = b.stateNode;
        dh(ah.current);
        var f = null;
        switch (c) {
          case "input":
            e = Ya(a, e);
            d = Ya(a, d);
            f = [];
            break;
          case "option":
            e = eb(a, e);
            d = eb(a, d);
            f = [];
            break;
          case "select":
            e = m({}, e, {value: void 0});
            d = m({}, d, {value: void 0});
            f = [];
            break;
          case "textarea":
            e = gb(a, e);
            d = gb(a, d);
            f = [];
            break;
          default:
            typeof e.onClick !== "function" && typeof d.onClick === "function" && (a.onclick = jf);
        }
        vb(c, d);
        var g;
        c = null;
        for (l in e)
          if (!d.hasOwnProperty(l) && e.hasOwnProperty(l) && e[l] != null)
            if (l === "style") {
              var h = e[l];
              for (g in h)
                h.hasOwnProperty(g) && (c || (c = {}), c[g] = "");
            } else
              l !== "dangerouslySetInnerHTML" && l !== "children" && l !== "suppressContentEditableWarning" && l !== "suppressHydrationWarning" && l !== "autoFocus" && (ca.hasOwnProperty(l) ? f || (f = []) : (f = f || []).push(l, null));
        for (l in d) {
          var k = d[l];
          h = e != null ? e[l] : void 0;
          if (d.hasOwnProperty(l) && k !== h && (k != null || h != null))
            if (l === "style")
              if (h) {
                for (g in h)
                  !h.hasOwnProperty(g) || k && k.hasOwnProperty(g) || (c || (c = {}), c[g] = "");
                for (g in k)
                  k.hasOwnProperty(g) && h[g] !== k[g] && (c || (c = {}), c[g] = k[g]);
              } else
                c || (f || (f = []), f.push(l, c)), c = k;
            else
              l === "dangerouslySetInnerHTML" ? (k = k ? k.__html : void 0, h = h ? h.__html : void 0, k != null && h !== k && (f = f || []).push(l, k)) : l === "children" ? typeof k !== "string" && typeof k !== "number" || (f = f || []).push(l, "" + k) : l !== "suppressContentEditableWarning" && l !== "suppressHydrationWarning" && (ca.hasOwnProperty(l) ? (k != null && l === "onScroll" && G("scroll", a), f || h === k || (f = [])) : typeof k === "object" && k !== null && k.$$typeof === Ga ? k.toString() : (f = f || []).push(l, k));
        }
        c && (f = f || []).push("style", c);
        var l = f;
        if (b.updateQueue = l)
          b.flags |= 4;
      }
    };
    Ei = function(a, b, c, d) {
      c !== d && (b.flags |= 4);
    };
    function Fi(a, b) {
      if (!lh)
        switch (a.tailMode) {
          case "hidden":
            b = a.tail;
            for (var c = null; b !== null; )
              b.alternate !== null && (c = b), b = b.sibling;
            c === null ? a.tail = null : c.sibling = null;
            break;
          case "collapsed":
            c = a.tail;
            for (var d = null; c !== null; )
              c.alternate !== null && (d = c), c = c.sibling;
            d === null ? b || a.tail === null ? a.tail = null : a.tail.sibling = null : d.sibling = null;
        }
    }
    function Gi(a, b, c) {
      var d = b.pendingProps;
      switch (b.tag) {
        case 2:
        case 16:
        case 15:
        case 0:
        case 11:
        case 7:
        case 8:
        case 12:
        case 9:
        case 14:
          return null;
        case 1:
          return Ff(b.type) && Gf(), null;
        case 3:
          fh();
          H(N);
          H(M);
          uh();
          d = b.stateNode;
          d.pendingContext && (d.context = d.pendingContext, d.pendingContext = null);
          if (a === null || a.child === null)
            rh(b) ? b.flags |= 4 : d.hydrate || (b.flags |= 256);
          Ci(b);
          return null;
        case 5:
          hh(b);
          var e = dh(ch.current);
          c = b.type;
          if (a !== null && b.stateNode != null)
            Di(a, b, c, d, e), a.ref !== b.ref && (b.flags |= 128);
          else {
            if (!d) {
              if (b.stateNode === null)
                throw Error(y(166));
              return null;
            }
            a = dh(ah.current);
            if (rh(b)) {
              d = b.stateNode;
              c = b.type;
              var f = b.memoizedProps;
              d[wf] = b;
              d[xf] = f;
              switch (c) {
                case "dialog":
                  G("cancel", d);
                  G("close", d);
                  break;
                case "iframe":
                case "object":
                case "embed":
                  G("load", d);
                  break;
                case "video":
                case "audio":
                  for (a = 0; a < Xe.length; a++)
                    G(Xe[a], d);
                  break;
                case "source":
                  G("error", d);
                  break;
                case "img":
                case "image":
                case "link":
                  G("error", d);
                  G("load", d);
                  break;
                case "details":
                  G("toggle", d);
                  break;
                case "input":
                  Za(d, f);
                  G("invalid", d);
                  break;
                case "select":
                  d._wrapperState = {wasMultiple: !!f.multiple};
                  G("invalid", d);
                  break;
                case "textarea":
                  hb(d, f), G("invalid", d);
              }
              vb(c, f);
              a = null;
              for (var g in f)
                f.hasOwnProperty(g) && (e = f[g], g === "children" ? typeof e === "string" ? d.textContent !== e && (a = ["children", e]) : typeof e === "number" && d.textContent !== "" + e && (a = ["children", "" + e]) : ca.hasOwnProperty(g) && e != null && g === "onScroll" && G("scroll", d));
              switch (c) {
                case "input":
                  Va(d);
                  cb(d, f, true);
                  break;
                case "textarea":
                  Va(d);
                  jb(d);
                  break;
                case "select":
                case "option":
                  break;
                default:
                  typeof f.onClick === "function" && (d.onclick = jf);
              }
              d = a;
              b.updateQueue = d;
              d !== null && (b.flags |= 4);
            } else {
              g = e.nodeType === 9 ? e : e.ownerDocument;
              a === kb.html && (a = lb(c));
              a === kb.html ? c === "script" ? (a = g.createElement("div"), a.innerHTML = "<script></script>", a = a.removeChild(a.firstChild)) : typeof d.is === "string" ? a = g.createElement(c, {is: d.is}) : (a = g.createElement(c), c === "select" && (g = a, d.multiple ? g.multiple = true : d.size && (g.size = d.size))) : a = g.createElementNS(a, c);
              a[wf] = b;
              a[xf] = d;
              Bi(a, b, false, false);
              b.stateNode = a;
              g = wb(c, d);
              switch (c) {
                case "dialog":
                  G("cancel", a);
                  G("close", a);
                  e = d;
                  break;
                case "iframe":
                case "object":
                case "embed":
                  G("load", a);
                  e = d;
                  break;
                case "video":
                case "audio":
                  for (e = 0; e < Xe.length; e++)
                    G(Xe[e], a);
                  e = d;
                  break;
                case "source":
                  G("error", a);
                  e = d;
                  break;
                case "img":
                case "image":
                case "link":
                  G("error", a);
                  G("load", a);
                  e = d;
                  break;
                case "details":
                  G("toggle", a);
                  e = d;
                  break;
                case "input":
                  Za(a, d);
                  e = Ya(a, d);
                  G("invalid", a);
                  break;
                case "option":
                  e = eb(a, d);
                  break;
                case "select":
                  a._wrapperState = {wasMultiple: !!d.multiple};
                  e = m({}, d, {value: void 0});
                  G("invalid", a);
                  break;
                case "textarea":
                  hb(a, d);
                  e = gb(a, d);
                  G("invalid", a);
                  break;
                default:
                  e = d;
              }
              vb(c, e);
              var h = e;
              for (f in h)
                if (h.hasOwnProperty(f)) {
                  var k = h[f];
                  f === "style" ? tb(a, k) : f === "dangerouslySetInnerHTML" ? (k = k ? k.__html : void 0, k != null && ob(a, k)) : f === "children" ? typeof k === "string" ? (c !== "textarea" || k !== "") && pb(a, k) : typeof k === "number" && pb(a, "" + k) : f !== "suppressContentEditableWarning" && f !== "suppressHydrationWarning" && f !== "autoFocus" && (ca.hasOwnProperty(f) ? k != null && f === "onScroll" && G("scroll", a) : k != null && qa(a, f, k, g));
                }
              switch (c) {
                case "input":
                  Va(a);
                  cb(a, d, false);
                  break;
                case "textarea":
                  Va(a);
                  jb(a);
                  break;
                case "option":
                  d.value != null && a.setAttribute("value", "" + Sa(d.value));
                  break;
                case "select":
                  a.multiple = !!d.multiple;
                  f = d.value;
                  f != null ? fb(a, !!d.multiple, f, false) : d.defaultValue != null && fb(a, !!d.multiple, d.defaultValue, true);
                  break;
                default:
                  typeof e.onClick === "function" && (a.onclick = jf);
              }
              mf(c, d) && (b.flags |= 4);
            }
            b.ref !== null && (b.flags |= 128);
          }
          return null;
        case 6:
          if (a && b.stateNode != null)
            Ei(a, b, a.memoizedProps, d);
          else {
            if (typeof d !== "string" && b.stateNode === null)
              throw Error(y(166));
            c = dh(ch.current);
            dh(ah.current);
            rh(b) ? (d = b.stateNode, c = b.memoizedProps, d[wf] = b, d.nodeValue !== c && (b.flags |= 4)) : (d = (c.nodeType === 9 ? c : c.ownerDocument).createTextNode(d), d[wf] = b, b.stateNode = d);
          }
          return null;
        case 13:
          H(P);
          d = b.memoizedState;
          if ((b.flags & 64) !== 0)
            return b.lanes = c, b;
          d = d !== null;
          c = false;
          a === null ? b.memoizedProps.fallback !== void 0 && rh(b) : c = a.memoizedState !== null;
          if (d && !c && (b.mode & 2) !== 0)
            if (a === null && b.memoizedProps.unstable_avoidThisFallback !== true || (P.current & 1) !== 0)
              V === 0 && (V = 3);
            else {
              if (V === 0 || V === 3)
                V = 4;
              U === null || (Dg & 134217727) === 0 && (Hi & 134217727) === 0 || Ii(U, W);
            }
          if (d || c)
            b.flags |= 4;
          return null;
        case 4:
          return fh(), Ci(b), a === null && cf(b.stateNode.containerInfo), null;
        case 10:
          return rg(b), null;
        case 17:
          return Ff(b.type) && Gf(), null;
        case 19:
          H(P);
          d = b.memoizedState;
          if (d === null)
            return null;
          f = (b.flags & 64) !== 0;
          g = d.rendering;
          if (g === null)
            if (f)
              Fi(d, false);
            else {
              if (V !== 0 || a !== null && (a.flags & 64) !== 0)
                for (a = b.child; a !== null; ) {
                  g = ih(a);
                  if (g !== null) {
                    b.flags |= 64;
                    Fi(d, false);
                    f = g.updateQueue;
                    f !== null && (b.updateQueue = f, b.flags |= 4);
                    d.lastEffect === null && (b.firstEffect = null);
                    b.lastEffect = d.lastEffect;
                    d = c;
                    for (c = b.child; c !== null; )
                      f = c, a = d, f.flags &= 2, f.nextEffect = null, f.firstEffect = null, f.lastEffect = null, g = f.alternate, g === null ? (f.childLanes = 0, f.lanes = a, f.child = null, f.memoizedProps = null, f.memoizedState = null, f.updateQueue = null, f.dependencies = null, f.stateNode = null) : (f.childLanes = g.childLanes, f.lanes = g.lanes, f.child = g.child, f.memoizedProps = g.memoizedProps, f.memoizedState = g.memoizedState, f.updateQueue = g.updateQueue, f.type = g.type, a = g.dependencies, f.dependencies = a === null ? null : {lanes: a.lanes, firstContext: a.firstContext}), c = c.sibling;
                    I(P, P.current & 1 | 2);
                    return b.child;
                  }
                  a = a.sibling;
                }
              d.tail !== null && O() > Ji && (b.flags |= 64, f = true, Fi(d, false), b.lanes = 33554432);
            }
          else {
            if (!f)
              if (a = ih(g), a !== null) {
                if (b.flags |= 64, f = true, c = a.updateQueue, c !== null && (b.updateQueue = c, b.flags |= 4), Fi(d, true), d.tail === null && d.tailMode === "hidden" && !g.alternate && !lh)
                  return b = b.lastEffect = d.lastEffect, b !== null && (b.nextEffect = null), null;
              } else
                2 * O() - d.renderingStartTime > Ji && c !== 1073741824 && (b.flags |= 64, f = true, Fi(d, false), b.lanes = 33554432);
            d.isBackwards ? (g.sibling = b.child, b.child = g) : (c = d.last, c !== null ? c.sibling = g : b.child = g, d.last = g);
          }
          return d.tail !== null ? (c = d.tail, d.rendering = c, d.tail = c.sibling, d.lastEffect = b.lastEffect, d.renderingStartTime = O(), c.sibling = null, b = P.current, I(P, f ? b & 1 | 2 : b & 1), c) : null;
        case 23:
        case 24:
          return Ki(), a !== null && a.memoizedState !== null !== (b.memoizedState !== null) && d.mode !== "unstable-defer-without-hiding" && (b.flags |= 4), null;
      }
      throw Error(y(156, b.tag));
    }
    function Li(a) {
      switch (a.tag) {
        case 1:
          Ff(a.type) && Gf();
          var b = a.flags;
          return b & 4096 ? (a.flags = b & -4097 | 64, a) : null;
        case 3:
          fh();
          H(N);
          H(M);
          uh();
          b = a.flags;
          if ((b & 64) !== 0)
            throw Error(y(285));
          a.flags = b & -4097 | 64;
          return a;
        case 5:
          return hh(a), null;
        case 13:
          return H(P), b = a.flags, b & 4096 ? (a.flags = b & -4097 | 64, a) : null;
        case 19:
          return H(P), null;
        case 4:
          return fh(), null;
        case 10:
          return rg(a), null;
        case 23:
        case 24:
          return Ki(), null;
        default:
          return null;
      }
    }
    function Mi(a, b) {
      try {
        var c = "", d = b;
        do
          c += Qa(d), d = d.return;
        while (d);
        var e = c;
      } catch (f) {
        e = "\nError generating stack: " + f.message + "\n" + f.stack;
      }
      return {value: a, source: b, stack: e};
    }
    function Ni(a, b) {
      try {
        console.error(b.value);
      } catch (c) {
        setTimeout(function() {
          throw c;
        });
      }
    }
    var Oi = typeof WeakMap === "function" ? WeakMap : Map;
    function Pi(a, b, c) {
      c = zg(-1, c);
      c.tag = 3;
      c.payload = {element: null};
      var d = b.value;
      c.callback = function() {
        Qi || (Qi = true, Ri = d);
        Ni(a, b);
      };
      return c;
    }
    function Si(a, b, c) {
      c = zg(-1, c);
      c.tag = 3;
      var d = a.type.getDerivedStateFromError;
      if (typeof d === "function") {
        var e = b.value;
        c.payload = function() {
          Ni(a, b);
          return d(e);
        };
      }
      var f = a.stateNode;
      f !== null && typeof f.componentDidCatch === "function" && (c.callback = function() {
        typeof d !== "function" && (Ti === null ? Ti = new Set([this]) : Ti.add(this), Ni(a, b));
        var c2 = b.stack;
        this.componentDidCatch(b.value, {componentStack: c2 !== null ? c2 : ""});
      });
      return c;
    }
    var Ui = typeof WeakSet === "function" ? WeakSet : Set;
    function Vi(a) {
      var b = a.ref;
      if (b !== null)
        if (typeof b === "function")
          try {
            b(null);
          } catch (c) {
            Wi(a, c);
          }
        else
          b.current = null;
    }
    function Xi(a, b) {
      switch (b.tag) {
        case 0:
        case 11:
        case 15:
        case 22:
          return;
        case 1:
          if (b.flags & 256 && a !== null) {
            var c = a.memoizedProps, d = a.memoizedState;
            a = b.stateNode;
            b = a.getSnapshotBeforeUpdate(b.elementType === b.type ? c : lg(b.type, c), d);
            a.__reactInternalSnapshotBeforeUpdate = b;
          }
          return;
        case 3:
          b.flags & 256 && qf(b.stateNode.containerInfo);
          return;
        case 5:
        case 6:
        case 4:
        case 17:
          return;
      }
      throw Error(y(163));
    }
    function Yi(a, b, c) {
      switch (c.tag) {
        case 0:
        case 11:
        case 15:
        case 22:
          b = c.updateQueue;
          b = b !== null ? b.lastEffect : null;
          if (b !== null) {
            a = b = b.next;
            do {
              if ((a.tag & 3) === 3) {
                var d = a.create;
                a.destroy = d();
              }
              a = a.next;
            } while (a !== b);
          }
          b = c.updateQueue;
          b = b !== null ? b.lastEffect : null;
          if (b !== null) {
            a = b = b.next;
            do {
              var e = a;
              d = e.next;
              e = e.tag;
              (e & 4) !== 0 && (e & 1) !== 0 && (Zi(c, a), $i(c, a));
              a = d;
            } while (a !== b);
          }
          return;
        case 1:
          a = c.stateNode;
          c.flags & 4 && (b === null ? a.componentDidMount() : (d = c.elementType === c.type ? b.memoizedProps : lg(c.type, b.memoizedProps), a.componentDidUpdate(d, b.memoizedState, a.__reactInternalSnapshotBeforeUpdate)));
          b = c.updateQueue;
          b !== null && Eg(c, b, a);
          return;
        case 3:
          b = c.updateQueue;
          if (b !== null) {
            a = null;
            if (c.child !== null)
              switch (c.child.tag) {
                case 5:
                  a = c.child.stateNode;
                  break;
                case 1:
                  a = c.child.stateNode;
              }
            Eg(c, b, a);
          }
          return;
        case 5:
          a = c.stateNode;
          b === null && c.flags & 4 && mf(c.type, c.memoizedProps) && a.focus();
          return;
        case 6:
          return;
        case 4:
          return;
        case 12:
          return;
        case 13:
          c.memoizedState === null && (c = c.alternate, c !== null && (c = c.memoizedState, c !== null && (c = c.dehydrated, c !== null && Cc(c))));
          return;
        case 19:
        case 17:
        case 20:
        case 21:
        case 23:
        case 24:
          return;
      }
      throw Error(y(163));
    }
    function aj(a, b) {
      for (var c = a; ; ) {
        if (c.tag === 5) {
          var d = c.stateNode;
          if (b)
            d = d.style, typeof d.setProperty === "function" ? d.setProperty("display", "none", "important") : d.display = "none";
          else {
            d = c.stateNode;
            var e = c.memoizedProps.style;
            e = e !== void 0 && e !== null && e.hasOwnProperty("display") ? e.display : null;
            d.style.display = sb("display", e);
          }
        } else if (c.tag === 6)
          c.stateNode.nodeValue = b ? "" : c.memoizedProps;
        else if ((c.tag !== 23 && c.tag !== 24 || c.memoizedState === null || c === a) && c.child !== null) {
          c.child.return = c;
          c = c.child;
          continue;
        }
        if (c === a)
          break;
        for (; c.sibling === null; ) {
          if (c.return === null || c.return === a)
            return;
          c = c.return;
        }
        c.sibling.return = c.return;
        c = c.sibling;
      }
    }
    function bj(a, b) {
      if (Mf && typeof Mf.onCommitFiberUnmount === "function")
        try {
          Mf.onCommitFiberUnmount(Lf, b);
        } catch (f) {
        }
      switch (b.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
        case 22:
          a = b.updateQueue;
          if (a !== null && (a = a.lastEffect, a !== null)) {
            var c = a = a.next;
            do {
              var d = c, e = d.destroy;
              d = d.tag;
              if (e !== void 0)
                if ((d & 4) !== 0)
                  Zi(b, c);
                else {
                  d = b;
                  try {
                    e();
                  } catch (f) {
                    Wi(d, f);
                  }
                }
              c = c.next;
            } while (c !== a);
          }
          break;
        case 1:
          Vi(b);
          a = b.stateNode;
          if (typeof a.componentWillUnmount === "function")
            try {
              a.props = b.memoizedProps, a.state = b.memoizedState, a.componentWillUnmount();
            } catch (f) {
              Wi(b, f);
            }
          break;
        case 5:
          Vi(b);
          break;
        case 4:
          cj(a, b);
      }
    }
    function dj(a) {
      a.alternate = null;
      a.child = null;
      a.dependencies = null;
      a.firstEffect = null;
      a.lastEffect = null;
      a.memoizedProps = null;
      a.memoizedState = null;
      a.pendingProps = null;
      a.return = null;
      a.updateQueue = null;
    }
    function ej(a) {
      return a.tag === 5 || a.tag === 3 || a.tag === 4;
    }
    function fj(a) {
      a: {
        for (var b = a.return; b !== null; ) {
          if (ej(b))
            break a;
          b = b.return;
        }
        throw Error(y(160));
      }
      var c = b;
      b = c.stateNode;
      switch (c.tag) {
        case 5:
          var d = false;
          break;
        case 3:
          b = b.containerInfo;
          d = true;
          break;
        case 4:
          b = b.containerInfo;
          d = true;
          break;
        default:
          throw Error(y(161));
      }
      c.flags & 16 && (pb(b, ""), c.flags &= -17);
      a:
        b:
          for (c = a; ; ) {
            for (; c.sibling === null; ) {
              if (c.return === null || ej(c.return)) {
                c = null;
                break a;
              }
              c = c.return;
            }
            c.sibling.return = c.return;
            for (c = c.sibling; c.tag !== 5 && c.tag !== 6 && c.tag !== 18; ) {
              if (c.flags & 2)
                continue b;
              if (c.child === null || c.tag === 4)
                continue b;
              else
                c.child.return = c, c = c.child;
            }
            if (!(c.flags & 2)) {
              c = c.stateNode;
              break a;
            }
          }
      d ? gj(a, c, b) : hj(a, c, b);
    }
    function gj(a, b, c) {
      var d = a.tag, e = d === 5 || d === 6;
      if (e)
        a = e ? a.stateNode : a.stateNode.instance, b ? c.nodeType === 8 ? c.parentNode.insertBefore(a, b) : c.insertBefore(a, b) : (c.nodeType === 8 ? (b = c.parentNode, b.insertBefore(a, c)) : (b = c, b.appendChild(a)), c = c._reactRootContainer, c !== null && c !== void 0 || b.onclick !== null || (b.onclick = jf));
      else if (d !== 4 && (a = a.child, a !== null))
        for (gj(a, b, c), a = a.sibling; a !== null; )
          gj(a, b, c), a = a.sibling;
    }
    function hj(a, b, c) {
      var d = a.tag, e = d === 5 || d === 6;
      if (e)
        a = e ? a.stateNode : a.stateNode.instance, b ? c.insertBefore(a, b) : c.appendChild(a);
      else if (d !== 4 && (a = a.child, a !== null))
        for (hj(a, b, c), a = a.sibling; a !== null; )
          hj(a, b, c), a = a.sibling;
    }
    function cj(a, b) {
      for (var c = b, d = false, e, f; ; ) {
        if (!d) {
          d = c.return;
          a:
            for (; ; ) {
              if (d === null)
                throw Error(y(160));
              e = d.stateNode;
              switch (d.tag) {
                case 5:
                  f = false;
                  break a;
                case 3:
                  e = e.containerInfo;
                  f = true;
                  break a;
                case 4:
                  e = e.containerInfo;
                  f = true;
                  break a;
              }
              d = d.return;
            }
          d = true;
        }
        if (c.tag === 5 || c.tag === 6) {
          a:
            for (var g = a, h = c, k = h; ; )
              if (bj(g, k), k.child !== null && k.tag !== 4)
                k.child.return = k, k = k.child;
              else {
                if (k === h)
                  break a;
                for (; k.sibling === null; ) {
                  if (k.return === null || k.return === h)
                    break a;
                  k = k.return;
                }
                k.sibling.return = k.return;
                k = k.sibling;
              }
          f ? (g = e, h = c.stateNode, g.nodeType === 8 ? g.parentNode.removeChild(h) : g.removeChild(h)) : e.removeChild(c.stateNode);
        } else if (c.tag === 4) {
          if (c.child !== null) {
            e = c.stateNode.containerInfo;
            f = true;
            c.child.return = c;
            c = c.child;
            continue;
          }
        } else if (bj(a, c), c.child !== null) {
          c.child.return = c;
          c = c.child;
          continue;
        }
        if (c === b)
          break;
        for (; c.sibling === null; ) {
          if (c.return === null || c.return === b)
            return;
          c = c.return;
          c.tag === 4 && (d = false);
        }
        c.sibling.return = c.return;
        c = c.sibling;
      }
    }
    function ij(a, b) {
      switch (b.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
        case 22:
          var c = b.updateQueue;
          c = c !== null ? c.lastEffect : null;
          if (c !== null) {
            var d = c = c.next;
            do
              (d.tag & 3) === 3 && (a = d.destroy, d.destroy = void 0, a !== void 0 && a()), d = d.next;
            while (d !== c);
          }
          return;
        case 1:
          return;
        case 5:
          c = b.stateNode;
          if (c != null) {
            d = b.memoizedProps;
            var e = a !== null ? a.memoizedProps : d;
            a = b.type;
            var f = b.updateQueue;
            b.updateQueue = null;
            if (f !== null) {
              c[xf] = d;
              a === "input" && d.type === "radio" && d.name != null && $a(c, d);
              wb(a, e);
              b = wb(a, d);
              for (e = 0; e < f.length; e += 2) {
                var g = f[e], h = f[e + 1];
                g === "style" ? tb(c, h) : g === "dangerouslySetInnerHTML" ? ob(c, h) : g === "children" ? pb(c, h) : qa(c, g, h, b);
              }
              switch (a) {
                case "input":
                  ab(c, d);
                  break;
                case "textarea":
                  ib(c, d);
                  break;
                case "select":
                  a = c._wrapperState.wasMultiple, c._wrapperState.wasMultiple = !!d.multiple, f = d.value, f != null ? fb(c, !!d.multiple, f, false) : a !== !!d.multiple && (d.defaultValue != null ? fb(c, !!d.multiple, d.defaultValue, true) : fb(c, !!d.multiple, d.multiple ? [] : "", false));
              }
            }
          }
          return;
        case 6:
          if (b.stateNode === null)
            throw Error(y(162));
          b.stateNode.nodeValue = b.memoizedProps;
          return;
        case 3:
          c = b.stateNode;
          c.hydrate && (c.hydrate = false, Cc(c.containerInfo));
          return;
        case 12:
          return;
        case 13:
          b.memoizedState !== null && (jj = O(), aj(b.child, true));
          kj(b);
          return;
        case 19:
          kj(b);
          return;
        case 17:
          return;
        case 23:
        case 24:
          aj(b, b.memoizedState !== null);
          return;
      }
      throw Error(y(163));
    }
    function kj(a) {
      var b = a.updateQueue;
      if (b !== null) {
        a.updateQueue = null;
        var c = a.stateNode;
        c === null && (c = a.stateNode = new Ui());
        b.forEach(function(b2) {
          var d = lj.bind(null, a, b2);
          c.has(b2) || (c.add(b2), b2.then(d, d));
        });
      }
    }
    function mj(a, b) {
      return a !== null && (a = a.memoizedState, a === null || a.dehydrated !== null) ? (b = b.memoizedState, b !== null && b.dehydrated === null) : false;
    }
    var nj = Math.ceil;
    var oj = ra.ReactCurrentDispatcher;
    var pj = ra.ReactCurrentOwner;
    var X = 0;
    var U = null;
    var Y = null;
    var W = 0;
    var qj = 0;
    var rj = Bf(0);
    var V = 0;
    var sj = null;
    var tj = 0;
    var Dg = 0;
    var Hi = 0;
    var uj = 0;
    var vj = null;
    var jj = 0;
    var Ji = Infinity;
    function wj() {
      Ji = O() + 500;
    }
    var Z = null;
    var Qi = false;
    var Ri = null;
    var Ti = null;
    var xj = false;
    var yj = null;
    var zj = 90;
    var Aj = [];
    var Bj = [];
    var Cj = null;
    var Dj = 0;
    var Ej = null;
    var Fj = -1;
    var Gj = 0;
    var Hj = 0;
    var Ij = null;
    var Jj = false;
    function Hg() {
      return (X & 48) !== 0 ? O() : Fj !== -1 ? Fj : Fj = O();
    }
    function Ig(a) {
      a = a.mode;
      if ((a & 2) === 0)
        return 1;
      if ((a & 4) === 0)
        return eg() === 99 ? 1 : 2;
      Gj === 0 && (Gj = tj);
      if (kg.transition !== 0) {
        Hj !== 0 && (Hj = vj !== null ? vj.pendingLanes : 0);
        a = Gj;
        var b = 4186112 & ~Hj;
        b &= -b;
        b === 0 && (a = 4186112 & ~a, b = a & -a, b === 0 && (b = 8192));
        return b;
      }
      a = eg();
      (X & 4) !== 0 && a === 98 ? a = Xc(12, Gj) : (a = Sc(a), a = Xc(a, Gj));
      return a;
    }
    function Jg(a, b, c) {
      if (50 < Dj)
        throw Dj = 0, Ej = null, Error(y(185));
      a = Kj(a, b);
      if (a === null)
        return null;
      $c(a, b, c);
      a === U && (Hi |= b, V === 4 && Ii(a, W));
      var d = eg();
      b === 1 ? (X & 8) !== 0 && (X & 48) === 0 ? Lj(a) : (Mj(a, c), X === 0 && (wj(), ig())) : ((X & 4) === 0 || d !== 98 && d !== 99 || (Cj === null ? Cj = new Set([a]) : Cj.add(a)), Mj(a, c));
      vj = a;
    }
    function Kj(a, b) {
      a.lanes |= b;
      var c = a.alternate;
      c !== null && (c.lanes |= b);
      c = a;
      for (a = a.return; a !== null; )
        a.childLanes |= b, c = a.alternate, c !== null && (c.childLanes |= b), c = a, a = a.return;
      return c.tag === 3 ? c.stateNode : null;
    }
    function Mj(a, b) {
      for (var c = a.callbackNode, d = a.suspendedLanes, e = a.pingedLanes, f = a.expirationTimes, g = a.pendingLanes; 0 < g; ) {
        var h = 31 - Vc(g), k = 1 << h, l = f[h];
        if (l === -1) {
          if ((k & d) === 0 || (k & e) !== 0) {
            l = b;
            Rc(k);
            var n = F;
            f[h] = 10 <= n ? l + 250 : 6 <= n ? l + 5e3 : -1;
          }
        } else
          l <= b && (a.expiredLanes |= k);
        g &= ~k;
      }
      d = Uc(a, a === U ? W : 0);
      b = F;
      if (d === 0)
        c !== null && (c !== Zf && Pf(c), a.callbackNode = null, a.callbackPriority = 0);
      else {
        if (c !== null) {
          if (a.callbackPriority === b)
            return;
          c !== Zf && Pf(c);
        }
        b === 15 ? (c = Lj.bind(null, a), ag === null ? (ag = [c], bg = Of(Uf, jg)) : ag.push(c), c = Zf) : b === 14 ? c = hg(99, Lj.bind(null, a)) : (c = Tc(b), c = hg(c, Nj.bind(null, a)));
        a.callbackPriority = b;
        a.callbackNode = c;
      }
    }
    function Nj(a) {
      Fj = -1;
      Hj = Gj = 0;
      if ((X & 48) !== 0)
        throw Error(y(327));
      var b = a.callbackNode;
      if (Oj() && a.callbackNode !== b)
        return null;
      var c = Uc(a, a === U ? W : 0);
      if (c === 0)
        return null;
      var d = c;
      var e = X;
      X |= 16;
      var f = Pj();
      if (U !== a || W !== d)
        wj(), Qj(a, d);
      do
        try {
          Rj();
          break;
        } catch (h) {
          Sj(a, h);
        }
      while (1);
      qg();
      oj.current = f;
      X = e;
      Y !== null ? d = 0 : (U = null, W = 0, d = V);
      if ((tj & Hi) !== 0)
        Qj(a, 0);
      else if (d !== 0) {
        d === 2 && (X |= 64, a.hydrate && (a.hydrate = false, qf(a.containerInfo)), c = Wc(a), c !== 0 && (d = Tj(a, c)));
        if (d === 1)
          throw b = sj, Qj(a, 0), Ii(a, c), Mj(a, O()), b;
        a.finishedWork = a.current.alternate;
        a.finishedLanes = c;
        switch (d) {
          case 0:
          case 1:
            throw Error(y(345));
          case 2:
            Uj(a);
            break;
          case 3:
            Ii(a, c);
            if ((c & 62914560) === c && (d = jj + 500 - O(), 10 < d)) {
              if (Uc(a, 0) !== 0)
                break;
              e = a.suspendedLanes;
              if ((e & c) !== c) {
                Hg();
                a.pingedLanes |= a.suspendedLanes & e;
                break;
              }
              a.timeoutHandle = of(Uj.bind(null, a), d);
              break;
            }
            Uj(a);
            break;
          case 4:
            Ii(a, c);
            if ((c & 4186112) === c)
              break;
            d = a.eventTimes;
            for (e = -1; 0 < c; ) {
              var g = 31 - Vc(c);
              f = 1 << g;
              g = d[g];
              g > e && (e = g);
              c &= ~f;
            }
            c = e;
            c = O() - c;
            c = (120 > c ? 120 : 480 > c ? 480 : 1080 > c ? 1080 : 1920 > c ? 1920 : 3e3 > c ? 3e3 : 4320 > c ? 4320 : 1960 * nj(c / 1960)) - c;
            if (10 < c) {
              a.timeoutHandle = of(Uj.bind(null, a), c);
              break;
            }
            Uj(a);
            break;
          case 5:
            Uj(a);
            break;
          default:
            throw Error(y(329));
        }
      }
      Mj(a, O());
      return a.callbackNode === b ? Nj.bind(null, a) : null;
    }
    function Ii(a, b) {
      b &= ~uj;
      b &= ~Hi;
      a.suspendedLanes |= b;
      a.pingedLanes &= ~b;
      for (a = a.expirationTimes; 0 < b; ) {
        var c = 31 - Vc(b), d = 1 << c;
        a[c] = -1;
        b &= ~d;
      }
    }
    function Lj(a) {
      if ((X & 48) !== 0)
        throw Error(y(327));
      Oj();
      if (a === U && (a.expiredLanes & W) !== 0) {
        var b = W;
        var c = Tj(a, b);
        (tj & Hi) !== 0 && (b = Uc(a, b), c = Tj(a, b));
      } else
        b = Uc(a, 0), c = Tj(a, b);
      a.tag !== 0 && c === 2 && (X |= 64, a.hydrate && (a.hydrate = false, qf(a.containerInfo)), b = Wc(a), b !== 0 && (c = Tj(a, b)));
      if (c === 1)
        throw c = sj, Qj(a, 0), Ii(a, b), Mj(a, O()), c;
      a.finishedWork = a.current.alternate;
      a.finishedLanes = b;
      Uj(a);
      Mj(a, O());
      return null;
    }
    function Vj() {
      if (Cj !== null) {
        var a = Cj;
        Cj = null;
        a.forEach(function(a2) {
          a2.expiredLanes |= 24 & a2.pendingLanes;
          Mj(a2, O());
        });
      }
      ig();
    }
    function Wj(a, b) {
      var c = X;
      X |= 1;
      try {
        return a(b);
      } finally {
        X = c, X === 0 && (wj(), ig());
      }
    }
    function Xj(a, b) {
      var c = X;
      X &= -2;
      X |= 8;
      try {
        return a(b);
      } finally {
        X = c, X === 0 && (wj(), ig());
      }
    }
    function ni(a, b) {
      I(rj, qj);
      qj |= b;
      tj |= b;
    }
    function Ki() {
      qj = rj.current;
      H(rj);
    }
    function Qj(a, b) {
      a.finishedWork = null;
      a.finishedLanes = 0;
      var c = a.timeoutHandle;
      c !== -1 && (a.timeoutHandle = -1, pf(c));
      if (Y !== null)
        for (c = Y.return; c !== null; ) {
          var d = c;
          switch (d.tag) {
            case 1:
              d = d.type.childContextTypes;
              d !== null && d !== void 0 && Gf();
              break;
            case 3:
              fh();
              H(N);
              H(M);
              uh();
              break;
            case 5:
              hh(d);
              break;
            case 4:
              fh();
              break;
            case 13:
              H(P);
              break;
            case 19:
              H(P);
              break;
            case 10:
              rg(d);
              break;
            case 23:
            case 24:
              Ki();
          }
          c = c.return;
        }
      U = a;
      Y = Tg(a.current, null);
      W = qj = tj = b;
      V = 0;
      sj = null;
      uj = Hi = Dg = 0;
    }
    function Sj(a, b) {
      do {
        var c = Y;
        try {
          qg();
          vh.current = Gh;
          if (yh) {
            for (var d = R.memoizedState; d !== null; ) {
              var e = d.queue;
              e !== null && (e.pending = null);
              d = d.next;
            }
            yh = false;
          }
          xh = 0;
          T = S = R = null;
          zh = false;
          pj.current = null;
          if (c === null || c.return === null) {
            V = 1;
            sj = b;
            Y = null;
            break;
          }
          a: {
            var f = a, g = c.return, h = c, k = b;
            b = W;
            h.flags |= 2048;
            h.firstEffect = h.lastEffect = null;
            if (k !== null && typeof k === "object" && typeof k.then === "function") {
              var l = k;
              if ((h.mode & 2) === 0) {
                var n = h.alternate;
                n ? (h.updateQueue = n.updateQueue, h.memoizedState = n.memoizedState, h.lanes = n.lanes) : (h.updateQueue = null, h.memoizedState = null);
              }
              var A = (P.current & 1) !== 0, p = g;
              do {
                var C;
                if (C = p.tag === 13) {
                  var x = p.memoizedState;
                  if (x !== null)
                    C = x.dehydrated !== null ? true : false;
                  else {
                    var w = p.memoizedProps;
                    C = w.fallback === void 0 ? false : w.unstable_avoidThisFallback !== true ? true : A ? false : true;
                  }
                }
                if (C) {
                  var z = p.updateQueue;
                  if (z === null) {
                    var u = new Set();
                    u.add(l);
                    p.updateQueue = u;
                  } else
                    z.add(l);
                  if ((p.mode & 2) === 0) {
                    p.flags |= 64;
                    h.flags |= 16384;
                    h.flags &= -2981;
                    if (h.tag === 1)
                      if (h.alternate === null)
                        h.tag = 17;
                      else {
                        var t = zg(-1, 1);
                        t.tag = 2;
                        Ag(h, t);
                      }
                    h.lanes |= 1;
                    break a;
                  }
                  k = void 0;
                  h = b;
                  var q = f.pingCache;
                  q === null ? (q = f.pingCache = new Oi(), k = new Set(), q.set(l, k)) : (k = q.get(l), k === void 0 && (k = new Set(), q.set(l, k)));
                  if (!k.has(h)) {
                    k.add(h);
                    var v = Yj.bind(null, f, l, h);
                    l.then(v, v);
                  }
                  p.flags |= 4096;
                  p.lanes = b;
                  break a;
                }
                p = p.return;
              } while (p !== null);
              k = Error((Ra(h.type) || "A React component") + " suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display.");
            }
            V !== 5 && (V = 2);
            k = Mi(k, h);
            p = g;
            do {
              switch (p.tag) {
                case 3:
                  f = k;
                  p.flags |= 4096;
                  b &= -b;
                  p.lanes |= b;
                  var J = Pi(p, f, b);
                  Bg(p, J);
                  break a;
                case 1:
                  f = k;
                  var K = p.type, Q = p.stateNode;
                  if ((p.flags & 64) === 0 && (typeof K.getDerivedStateFromError === "function" || Q !== null && typeof Q.componentDidCatch === "function" && (Ti === null || !Ti.has(Q)))) {
                    p.flags |= 4096;
                    b &= -b;
                    p.lanes |= b;
                    var L = Si(p, f, b);
                    Bg(p, L);
                    break a;
                  }
              }
              p = p.return;
            } while (p !== null);
          }
          Zj(c);
        } catch (va) {
          b = va;
          Y === c && c !== null && (Y = c = c.return);
          continue;
        }
        break;
      } while (1);
    }
    function Pj() {
      var a = oj.current;
      oj.current = Gh;
      return a === null ? Gh : a;
    }
    function Tj(a, b) {
      var c = X;
      X |= 16;
      var d = Pj();
      U === a && W === b || Qj(a, b);
      do
        try {
          ak();
          break;
        } catch (e) {
          Sj(a, e);
        }
      while (1);
      qg();
      X = c;
      oj.current = d;
      if (Y !== null)
        throw Error(y(261));
      U = null;
      W = 0;
      return V;
    }
    function ak() {
      for (; Y !== null; )
        bk(Y);
    }
    function Rj() {
      for (; Y !== null && !Qf(); )
        bk(Y);
    }
    function bk(a) {
      var b = ck(a.alternate, a, qj);
      a.memoizedProps = a.pendingProps;
      b === null ? Zj(a) : Y = b;
      pj.current = null;
    }
    function Zj(a) {
      var b = a;
      do {
        var c = b.alternate;
        a = b.return;
        if ((b.flags & 2048) === 0) {
          c = Gi(c, b, qj);
          if (c !== null) {
            Y = c;
            return;
          }
          c = b;
          if (c.tag !== 24 && c.tag !== 23 || c.memoizedState === null || (qj & 1073741824) !== 0 || (c.mode & 4) === 0) {
            for (var d = 0, e = c.child; e !== null; )
              d |= e.lanes | e.childLanes, e = e.sibling;
            c.childLanes = d;
          }
          a !== null && (a.flags & 2048) === 0 && (a.firstEffect === null && (a.firstEffect = b.firstEffect), b.lastEffect !== null && (a.lastEffect !== null && (a.lastEffect.nextEffect = b.firstEffect), a.lastEffect = b.lastEffect), 1 < b.flags && (a.lastEffect !== null ? a.lastEffect.nextEffect = b : a.firstEffect = b, a.lastEffect = b));
        } else {
          c = Li(b);
          if (c !== null) {
            c.flags &= 2047;
            Y = c;
            return;
          }
          a !== null && (a.firstEffect = a.lastEffect = null, a.flags |= 2048);
        }
        b = b.sibling;
        if (b !== null) {
          Y = b;
          return;
        }
        Y = b = a;
      } while (b !== null);
      V === 0 && (V = 5);
    }
    function Uj(a) {
      var b = eg();
      gg(99, dk.bind(null, a, b));
      return null;
    }
    function dk(a, b) {
      do
        Oj();
      while (yj !== null);
      if ((X & 48) !== 0)
        throw Error(y(327));
      var c = a.finishedWork;
      if (c === null)
        return null;
      a.finishedWork = null;
      a.finishedLanes = 0;
      if (c === a.current)
        throw Error(y(177));
      a.callbackNode = null;
      var d = c.lanes | c.childLanes, e = d, f = a.pendingLanes & ~e;
      a.pendingLanes = e;
      a.suspendedLanes = 0;
      a.pingedLanes = 0;
      a.expiredLanes &= e;
      a.mutableReadLanes &= e;
      a.entangledLanes &= e;
      e = a.entanglements;
      for (var g = a.eventTimes, h = a.expirationTimes; 0 < f; ) {
        var k = 31 - Vc(f), l = 1 << k;
        e[k] = 0;
        g[k] = -1;
        h[k] = -1;
        f &= ~l;
      }
      Cj !== null && (d & 24) === 0 && Cj.has(a) && Cj.delete(a);
      a === U && (Y = U = null, W = 0);
      1 < c.flags ? c.lastEffect !== null ? (c.lastEffect.nextEffect = c, d = c.firstEffect) : d = c : d = c.firstEffect;
      if (d !== null) {
        e = X;
        X |= 32;
        pj.current = null;
        kf = fd;
        g = Ne();
        if (Oe(g)) {
          if ("selectionStart" in g)
            h = {start: g.selectionStart, end: g.selectionEnd};
          else
            a:
              if (h = (h = g.ownerDocument) && h.defaultView || window, (l = h.getSelection && h.getSelection()) && l.rangeCount !== 0) {
                h = l.anchorNode;
                f = l.anchorOffset;
                k = l.focusNode;
                l = l.focusOffset;
                try {
                  h.nodeType, k.nodeType;
                } catch (va) {
                  h = null;
                  break a;
                }
                var n = 0, A = -1, p = -1, C = 0, x = 0, w = g, z = null;
                b:
                  for (; ; ) {
                    for (var u; ; ) {
                      w !== h || f !== 0 && w.nodeType !== 3 || (A = n + f);
                      w !== k || l !== 0 && w.nodeType !== 3 || (p = n + l);
                      w.nodeType === 3 && (n += w.nodeValue.length);
                      if ((u = w.firstChild) === null)
                        break;
                      z = w;
                      w = u;
                    }
                    for (; ; ) {
                      if (w === g)
                        break b;
                      z === h && ++C === f && (A = n);
                      z === k && ++x === l && (p = n);
                      if ((u = w.nextSibling) !== null)
                        break;
                      w = z;
                      z = w.parentNode;
                    }
                    w = u;
                  }
                h = A === -1 || p === -1 ? null : {start: A, end: p};
              } else
                h = null;
          h = h || {start: 0, end: 0};
        } else
          h = null;
        lf = {focusedElem: g, selectionRange: h};
        fd = false;
        Ij = null;
        Jj = false;
        Z = d;
        do
          try {
            ek();
          } catch (va) {
            if (Z === null)
              throw Error(y(330));
            Wi(Z, va);
            Z = Z.nextEffect;
          }
        while (Z !== null);
        Ij = null;
        Z = d;
        do
          try {
            for (g = a; Z !== null; ) {
              var t = Z.flags;
              t & 16 && pb(Z.stateNode, "");
              if (t & 128) {
                var q = Z.alternate;
                if (q !== null) {
                  var v = q.ref;
                  v !== null && (typeof v === "function" ? v(null) : v.current = null);
                }
              }
              switch (t & 1038) {
                case 2:
                  fj(Z);
                  Z.flags &= -3;
                  break;
                case 6:
                  fj(Z);
                  Z.flags &= -3;
                  ij(Z.alternate, Z);
                  break;
                case 1024:
                  Z.flags &= -1025;
                  break;
                case 1028:
                  Z.flags &= -1025;
                  ij(Z.alternate, Z);
                  break;
                case 4:
                  ij(Z.alternate, Z);
                  break;
                case 8:
                  h = Z;
                  cj(g, h);
                  var J = h.alternate;
                  dj(h);
                  J !== null && dj(J);
              }
              Z = Z.nextEffect;
            }
          } catch (va) {
            if (Z === null)
              throw Error(y(330));
            Wi(Z, va);
            Z = Z.nextEffect;
          }
        while (Z !== null);
        v = lf;
        q = Ne();
        t = v.focusedElem;
        g = v.selectionRange;
        if (q !== t && t && t.ownerDocument && Me(t.ownerDocument.documentElement, t)) {
          g !== null && Oe(t) && (q = g.start, v = g.end, v === void 0 && (v = q), "selectionStart" in t ? (t.selectionStart = q, t.selectionEnd = Math.min(v, t.value.length)) : (v = (q = t.ownerDocument || document) && q.defaultView || window, v.getSelection && (v = v.getSelection(), h = t.textContent.length, J = Math.min(g.start, h), g = g.end === void 0 ? J : Math.min(g.end, h), !v.extend && J > g && (h = g, g = J, J = h), h = Le(t, J), f = Le(t, g), h && f && (v.rangeCount !== 1 || v.anchorNode !== h.node || v.anchorOffset !== h.offset || v.focusNode !== f.node || v.focusOffset !== f.offset) && (q = q.createRange(), q.setStart(h.node, h.offset), v.removeAllRanges(), J > g ? (v.addRange(q), v.extend(f.node, f.offset)) : (q.setEnd(f.node, f.offset), v.addRange(q))))));
          q = [];
          for (v = t; v = v.parentNode; )
            v.nodeType === 1 && q.push({element: v, left: v.scrollLeft, top: v.scrollTop});
          typeof t.focus === "function" && t.focus();
          for (t = 0; t < q.length; t++)
            v = q[t], v.element.scrollLeft = v.left, v.element.scrollTop = v.top;
        }
        fd = !!kf;
        lf = kf = null;
        a.current = c;
        Z = d;
        do
          try {
            for (t = a; Z !== null; ) {
              var K = Z.flags;
              K & 36 && Yi(t, Z.alternate, Z);
              if (K & 128) {
                q = void 0;
                var Q = Z.ref;
                if (Q !== null) {
                  var L = Z.stateNode;
                  switch (Z.tag) {
                    case 5:
                      q = L;
                      break;
                    default:
                      q = L;
                  }
                  typeof Q === "function" ? Q(q) : Q.current = q;
                }
              }
              Z = Z.nextEffect;
            }
          } catch (va) {
            if (Z === null)
              throw Error(y(330));
            Wi(Z, va);
            Z = Z.nextEffect;
          }
        while (Z !== null);
        Z = null;
        $f();
        X = e;
      } else
        a.current = c;
      if (xj)
        xj = false, yj = a, zj = b;
      else
        for (Z = d; Z !== null; )
          b = Z.nextEffect, Z.nextEffect = null, Z.flags & 8 && (K = Z, K.sibling = null, K.stateNode = null), Z = b;
      d = a.pendingLanes;
      d === 0 && (Ti = null);
      d === 1 ? a === Ej ? Dj++ : (Dj = 0, Ej = a) : Dj = 0;
      c = c.stateNode;
      if (Mf && typeof Mf.onCommitFiberRoot === "function")
        try {
          Mf.onCommitFiberRoot(Lf, c, void 0, (c.current.flags & 64) === 64);
        } catch (va) {
        }
      Mj(a, O());
      if (Qi)
        throw Qi = false, a = Ri, Ri = null, a;
      if ((X & 8) !== 0)
        return null;
      ig();
      return null;
    }
    function ek() {
      for (; Z !== null; ) {
        var a = Z.alternate;
        Jj || Ij === null || ((Z.flags & 8) !== 0 ? dc(Z, Ij) && (Jj = true) : Z.tag === 13 && mj(a, Z) && dc(Z, Ij) && (Jj = true));
        var b = Z.flags;
        (b & 256) !== 0 && Xi(a, Z);
        (b & 512) === 0 || xj || (xj = true, hg(97, function() {
          Oj();
          return null;
        }));
        Z = Z.nextEffect;
      }
    }
    function Oj() {
      if (zj !== 90) {
        var a = 97 < zj ? 97 : zj;
        zj = 90;
        return gg(a, fk);
      }
      return false;
    }
    function $i(a, b) {
      Aj.push(b, a);
      xj || (xj = true, hg(97, function() {
        Oj();
        return null;
      }));
    }
    function Zi(a, b) {
      Bj.push(b, a);
      xj || (xj = true, hg(97, function() {
        Oj();
        return null;
      }));
    }
    function fk() {
      if (yj === null)
        return false;
      var a = yj;
      yj = null;
      if ((X & 48) !== 0)
        throw Error(y(331));
      var b = X;
      X |= 32;
      var c = Bj;
      Bj = [];
      for (var d = 0; d < c.length; d += 2) {
        var e = c[d], f = c[d + 1], g = e.destroy;
        e.destroy = void 0;
        if (typeof g === "function")
          try {
            g();
          } catch (k) {
            if (f === null)
              throw Error(y(330));
            Wi(f, k);
          }
      }
      c = Aj;
      Aj = [];
      for (d = 0; d < c.length; d += 2) {
        e = c[d];
        f = c[d + 1];
        try {
          var h = e.create;
          e.destroy = h();
        } catch (k) {
          if (f === null)
            throw Error(y(330));
          Wi(f, k);
        }
      }
      for (h = a.current.firstEffect; h !== null; )
        a = h.nextEffect, h.nextEffect = null, h.flags & 8 && (h.sibling = null, h.stateNode = null), h = a;
      X = b;
      ig();
      return true;
    }
    function gk(a, b, c) {
      b = Mi(c, b);
      b = Pi(a, b, 1);
      Ag(a, b);
      b = Hg();
      a = Kj(a, 1);
      a !== null && ($c(a, 1, b), Mj(a, b));
    }
    function Wi(a, b) {
      if (a.tag === 3)
        gk(a, a, b);
      else
        for (var c = a.return; c !== null; ) {
          if (c.tag === 3) {
            gk(c, a, b);
            break;
          } else if (c.tag === 1) {
            var d = c.stateNode;
            if (typeof c.type.getDerivedStateFromError === "function" || typeof d.componentDidCatch === "function" && (Ti === null || !Ti.has(d))) {
              a = Mi(b, a);
              var e = Si(c, a, 1);
              Ag(c, e);
              e = Hg();
              c = Kj(c, 1);
              if (c !== null)
                $c(c, 1, e), Mj(c, e);
              else if (typeof d.componentDidCatch === "function" && (Ti === null || !Ti.has(d)))
                try {
                  d.componentDidCatch(b, a);
                } catch (f) {
                }
              break;
            }
          }
          c = c.return;
        }
    }
    function Yj(a, b, c) {
      var d = a.pingCache;
      d !== null && d.delete(b);
      b = Hg();
      a.pingedLanes |= a.suspendedLanes & c;
      U === a && (W & c) === c && (V === 4 || V === 3 && (W & 62914560) === W && 500 > O() - jj ? Qj(a, 0) : uj |= c);
      Mj(a, b);
    }
    function lj(a, b) {
      var c = a.stateNode;
      c !== null && c.delete(b);
      b = 0;
      b === 0 && (b = a.mode, (b & 2) === 0 ? b = 1 : (b & 4) === 0 ? b = eg() === 99 ? 1 : 2 : (Gj === 0 && (Gj = tj), b = Yc(62914560 & ~Gj), b === 0 && (b = 4194304)));
      c = Hg();
      a = Kj(a, b);
      a !== null && ($c(a, b, c), Mj(a, c));
    }
    var ck;
    ck = function(a, b, c) {
      var d = b.lanes;
      if (a !== null)
        if (a.memoizedProps !== b.pendingProps || N.current)
          ug = true;
        else if ((c & d) !== 0)
          ug = (a.flags & 16384) !== 0 ? true : false;
        else {
          ug = false;
          switch (b.tag) {
            case 3:
              ri(b);
              sh();
              break;
            case 5:
              gh(b);
              break;
            case 1:
              Ff(b.type) && Jf(b);
              break;
            case 4:
              eh(b, b.stateNode.containerInfo);
              break;
            case 10:
              d = b.memoizedProps.value;
              var e = b.type._context;
              I(mg, e._currentValue);
              e._currentValue = d;
              break;
            case 13:
              if (b.memoizedState !== null) {
                if ((c & b.child.childLanes) !== 0)
                  return ti(a, b, c);
                I(P, P.current & 1);
                b = hi(a, b, c);
                return b !== null ? b.sibling : null;
              }
              I(P, P.current & 1);
              break;
            case 19:
              d = (c & b.childLanes) !== 0;
              if ((a.flags & 64) !== 0) {
                if (d)
                  return Ai(a, b, c);
                b.flags |= 64;
              }
              e = b.memoizedState;
              e !== null && (e.rendering = null, e.tail = null, e.lastEffect = null);
              I(P, P.current);
              if (d)
                break;
              else
                return null;
            case 23:
            case 24:
              return b.lanes = 0, mi(a, b, c);
          }
          return hi(a, b, c);
        }
      else
        ug = false;
      b.lanes = 0;
      switch (b.tag) {
        case 2:
          d = b.type;
          a !== null && (a.alternate = null, b.alternate = null, b.flags |= 2);
          a = b.pendingProps;
          e = Ef(b, M.current);
          tg(b, c);
          e = Ch(null, b, d, a, e, c);
          b.flags |= 1;
          if (typeof e === "object" && e !== null && typeof e.render === "function" && e.$$typeof === void 0) {
            b.tag = 1;
            b.memoizedState = null;
            b.updateQueue = null;
            if (Ff(d)) {
              var f = true;
              Jf(b);
            } else
              f = false;
            b.memoizedState = e.state !== null && e.state !== void 0 ? e.state : null;
            xg(b);
            var g = d.getDerivedStateFromProps;
            typeof g === "function" && Gg(b, d, g, a);
            e.updater = Kg;
            b.stateNode = e;
            e._reactInternals = b;
            Og(b, d, a, c);
            b = qi(null, b, d, true, f, c);
          } else
            b.tag = 0, fi(null, b, e, c), b = b.child;
          return b;
        case 16:
          e = b.elementType;
          a: {
            a !== null && (a.alternate = null, b.alternate = null, b.flags |= 2);
            a = b.pendingProps;
            f = e._init;
            e = f(e._payload);
            b.type = e;
            f = b.tag = hk(e);
            a = lg(e, a);
            switch (f) {
              case 0:
                b = li(null, b, e, a, c);
                break a;
              case 1:
                b = pi(null, b, e, a, c);
                break a;
              case 11:
                b = gi(null, b, e, a, c);
                break a;
              case 14:
                b = ii(null, b, e, lg(e.type, a), d, c);
                break a;
            }
            throw Error(y(306, e, ""));
          }
          return b;
        case 0:
          return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : lg(d, e), li(a, b, d, e, c);
        case 1:
          return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : lg(d, e), pi(a, b, d, e, c);
        case 3:
          ri(b);
          d = b.updateQueue;
          if (a === null || d === null)
            throw Error(y(282));
          d = b.pendingProps;
          e = b.memoizedState;
          e = e !== null ? e.element : null;
          yg(a, b);
          Cg(b, d, null, c);
          d = b.memoizedState.element;
          if (d === e)
            sh(), b = hi(a, b, c);
          else {
            e = b.stateNode;
            if (f = e.hydrate)
              kh = rf(b.stateNode.containerInfo.firstChild), jh = b, f = lh = true;
            if (f) {
              a = e.mutableSourceEagerHydrationData;
              if (a != null)
                for (e = 0; e < a.length; e += 2)
                  f = a[e], f._workInProgressVersionPrimary = a[e + 1], th.push(f);
              c = Zg(b, null, d, c);
              for (b.child = c; c; )
                c.flags = c.flags & -3 | 1024, c = c.sibling;
            } else
              fi(a, b, d, c), sh();
            b = b.child;
          }
          return b;
        case 5:
          return gh(b), a === null && ph(b), d = b.type, e = b.pendingProps, f = a !== null ? a.memoizedProps : null, g = e.children, nf(d, e) ? g = null : f !== null && nf(d, f) && (b.flags |= 16), oi(a, b), fi(a, b, g, c), b.child;
        case 6:
          return a === null && ph(b), null;
        case 13:
          return ti(a, b, c);
        case 4:
          return eh(b, b.stateNode.containerInfo), d = b.pendingProps, a === null ? b.child = Yg(b, null, d, c) : fi(a, b, d, c), b.child;
        case 11:
          return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : lg(d, e), gi(a, b, d, e, c);
        case 7:
          return fi(a, b, b.pendingProps, c), b.child;
        case 8:
          return fi(a, b, b.pendingProps.children, c), b.child;
        case 12:
          return fi(a, b, b.pendingProps.children, c), b.child;
        case 10:
          a: {
            d = b.type._context;
            e = b.pendingProps;
            g = b.memoizedProps;
            f = e.value;
            var h = b.type._context;
            I(mg, h._currentValue);
            h._currentValue = f;
            if (g !== null)
              if (h = g.value, f = He(h, f) ? 0 : (typeof d._calculateChangedBits === "function" ? d._calculateChangedBits(h, f) : 1073741823) | 0, f === 0) {
                if (g.children === e.children && !N.current) {
                  b = hi(a, b, c);
                  break a;
                }
              } else
                for (h = b.child, h !== null && (h.return = b); h !== null; ) {
                  var k = h.dependencies;
                  if (k !== null) {
                    g = h.child;
                    for (var l = k.firstContext; l !== null; ) {
                      if (l.context === d && (l.observedBits & f) !== 0) {
                        h.tag === 1 && (l = zg(-1, c & -c), l.tag = 2, Ag(h, l));
                        h.lanes |= c;
                        l = h.alternate;
                        l !== null && (l.lanes |= c);
                        sg(h.return, c);
                        k.lanes |= c;
                        break;
                      }
                      l = l.next;
                    }
                  } else
                    g = h.tag === 10 ? h.type === b.type ? null : h.child : h.child;
                  if (g !== null)
                    g.return = h;
                  else
                    for (g = h; g !== null; ) {
                      if (g === b) {
                        g = null;
                        break;
                      }
                      h = g.sibling;
                      if (h !== null) {
                        h.return = g.return;
                        g = h;
                        break;
                      }
                      g = g.return;
                    }
                  h = g;
                }
            fi(a, b, e.children, c);
            b = b.child;
          }
          return b;
        case 9:
          return e = b.type, f = b.pendingProps, d = f.children, tg(b, c), e = vg(e, f.unstable_observedBits), d = d(e), b.flags |= 1, fi(a, b, d, c), b.child;
        case 14:
          return e = b.type, f = lg(e, b.pendingProps), f = lg(e.type, f), ii(a, b, e, f, d, c);
        case 15:
          return ki(a, b, b.type, b.pendingProps, d, c);
        case 17:
          return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : lg(d, e), a !== null && (a.alternate = null, b.alternate = null, b.flags |= 2), b.tag = 1, Ff(d) ? (a = true, Jf(b)) : a = false, tg(b, c), Mg(b, d, e), Og(b, d, e, c), qi(null, b, d, true, a, c);
        case 19:
          return Ai(a, b, c);
        case 23:
          return mi(a, b, c);
        case 24:
          return mi(a, b, c);
      }
      throw Error(y(156, b.tag));
    };
    function ik(a, b, c, d) {
      this.tag = a;
      this.key = c;
      this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
      this.index = 0;
      this.ref = null;
      this.pendingProps = b;
      this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
      this.mode = d;
      this.flags = 0;
      this.lastEffect = this.firstEffect = this.nextEffect = null;
      this.childLanes = this.lanes = 0;
      this.alternate = null;
    }
    function nh(a, b, c, d) {
      return new ik(a, b, c, d);
    }
    function ji(a) {
      a = a.prototype;
      return !(!a || !a.isReactComponent);
    }
    function hk(a) {
      if (typeof a === "function")
        return ji(a) ? 1 : 0;
      if (a !== void 0 && a !== null) {
        a = a.$$typeof;
        if (a === Aa)
          return 11;
        if (a === Da)
          return 14;
      }
      return 2;
    }
    function Tg(a, b) {
      var c = a.alternate;
      c === null ? (c = nh(a.tag, b, a.key, a.mode), c.elementType = a.elementType, c.type = a.type, c.stateNode = a.stateNode, c.alternate = a, a.alternate = c) : (c.pendingProps = b, c.type = a.type, c.flags = 0, c.nextEffect = null, c.firstEffect = null, c.lastEffect = null);
      c.childLanes = a.childLanes;
      c.lanes = a.lanes;
      c.child = a.child;
      c.memoizedProps = a.memoizedProps;
      c.memoizedState = a.memoizedState;
      c.updateQueue = a.updateQueue;
      b = a.dependencies;
      c.dependencies = b === null ? null : {lanes: b.lanes, firstContext: b.firstContext};
      c.sibling = a.sibling;
      c.index = a.index;
      c.ref = a.ref;
      return c;
    }
    function Vg(a, b, c, d, e, f) {
      var g = 2;
      d = a;
      if (typeof a === "function")
        ji(a) && (g = 1);
      else if (typeof a === "string")
        g = 5;
      else
        a:
          switch (a) {
            case ua:
              return Xg(c.children, e, f, b);
            case Ha:
              g = 8;
              e |= 16;
              break;
            case wa:
              g = 8;
              e |= 1;
              break;
            case xa:
              return a = nh(12, c, b, e | 8), a.elementType = xa, a.type = xa, a.lanes = f, a;
            case Ba:
              return a = nh(13, c, b, e), a.type = Ba, a.elementType = Ba, a.lanes = f, a;
            case Ca:
              return a = nh(19, c, b, e), a.elementType = Ca, a.lanes = f, a;
            case Ia:
              return vi(c, e, f, b);
            case Ja:
              return a = nh(24, c, b, e), a.elementType = Ja, a.lanes = f, a;
            default:
              if (typeof a === "object" && a !== null)
                switch (a.$$typeof) {
                  case ya:
                    g = 10;
                    break a;
                  case za:
                    g = 9;
                    break a;
                  case Aa:
                    g = 11;
                    break a;
                  case Da:
                    g = 14;
                    break a;
                  case Ea:
                    g = 16;
                    d = null;
                    break a;
                  case Fa:
                    g = 22;
                    break a;
                }
              throw Error(y(130, a == null ? a : typeof a, ""));
          }
      b = nh(g, c, b, e);
      b.elementType = a;
      b.type = d;
      b.lanes = f;
      return b;
    }
    function Xg(a, b, c, d) {
      a = nh(7, a, d, b);
      a.lanes = c;
      return a;
    }
    function vi(a, b, c, d) {
      a = nh(23, a, d, b);
      a.elementType = Ia;
      a.lanes = c;
      return a;
    }
    function Ug(a, b, c) {
      a = nh(6, a, null, b);
      a.lanes = c;
      return a;
    }
    function Wg(a, b, c) {
      b = nh(4, a.children !== null ? a.children : [], a.key, b);
      b.lanes = c;
      b.stateNode = {containerInfo: a.containerInfo, pendingChildren: null, implementation: a.implementation};
      return b;
    }
    function jk(a, b, c) {
      this.tag = b;
      this.containerInfo = a;
      this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
      this.timeoutHandle = -1;
      this.pendingContext = this.context = null;
      this.hydrate = c;
      this.callbackNode = null;
      this.callbackPriority = 0;
      this.eventTimes = Zc(0);
      this.expirationTimes = Zc(-1);
      this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
      this.entanglements = Zc(0);
      this.mutableSourceEagerHydrationData = null;
    }
    function kk(a, b, c) {
      var d = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
      return {$$typeof: ta, key: d == null ? null : "" + d, children: a, containerInfo: b, implementation: c};
    }
    function lk(a, b, c, d) {
      var e = b.current, f = Hg(), g = Ig(e);
      a:
        if (c) {
          c = c._reactInternals;
          b: {
            if (Zb(c) !== c || c.tag !== 1)
              throw Error(y(170));
            var h = c;
            do {
              switch (h.tag) {
                case 3:
                  h = h.stateNode.context;
                  break b;
                case 1:
                  if (Ff(h.type)) {
                    h = h.stateNode.__reactInternalMemoizedMergedChildContext;
                    break b;
                  }
              }
              h = h.return;
            } while (h !== null);
            throw Error(y(171));
          }
          if (c.tag === 1) {
            var k = c.type;
            if (Ff(k)) {
              c = If(c, k, h);
              break a;
            }
          }
          c = h;
        } else
          c = Cf;
      b.context === null ? b.context = c : b.pendingContext = c;
      b = zg(f, g);
      b.payload = {element: a};
      d = d === void 0 ? null : d;
      d !== null && (b.callback = d);
      Ag(e, b);
      Jg(e, g, f);
      return g;
    }
    function mk(a) {
      a = a.current;
      if (!a.child)
        return null;
      switch (a.child.tag) {
        case 5:
          return a.child.stateNode;
        default:
          return a.child.stateNode;
      }
    }
    function nk(a, b) {
      a = a.memoizedState;
      if (a !== null && a.dehydrated !== null) {
        var c = a.retryLane;
        a.retryLane = c !== 0 && c < b ? c : b;
      }
    }
    function ok(a, b) {
      nk(a, b);
      (a = a.alternate) && nk(a, b);
    }
    function pk() {
      return null;
    }
    function qk(a, b, c) {
      var d = c != null && c.hydrationOptions != null && c.hydrationOptions.mutableSources || null;
      c = new jk(a, b, c != null && c.hydrate === true);
      b = nh(3, null, null, b === 2 ? 7 : b === 1 ? 3 : 0);
      c.current = b;
      b.stateNode = c;
      xg(b);
      a[ff] = c.current;
      cf(a.nodeType === 8 ? a.parentNode : a);
      if (d)
        for (a = 0; a < d.length; a++) {
          b = d[a];
          var e = b._getVersion;
          e = e(b._source);
          c.mutableSourceEagerHydrationData == null ? c.mutableSourceEagerHydrationData = [b, e] : c.mutableSourceEagerHydrationData.push(b, e);
        }
      this._internalRoot = c;
    }
    qk.prototype.render = function(a) {
      lk(a, this._internalRoot, null, null);
    };
    qk.prototype.unmount = function() {
      var a = this._internalRoot, b = a.containerInfo;
      lk(null, a, null, function() {
        b[ff] = null;
      });
    };
    function rk(a) {
      return !(!a || a.nodeType !== 1 && a.nodeType !== 9 && a.nodeType !== 11 && (a.nodeType !== 8 || a.nodeValue !== " react-mount-point-unstable "));
    }
    function sk(a, b) {
      b || (b = a ? a.nodeType === 9 ? a.documentElement : a.firstChild : null, b = !(!b || b.nodeType !== 1 || !b.hasAttribute("data-reactroot")));
      if (!b)
        for (var c; c = a.lastChild; )
          a.removeChild(c);
      return new qk(a, 0, b ? {hydrate: true} : void 0);
    }
    function tk(a, b, c, d, e) {
      var f = c._reactRootContainer;
      if (f) {
        var g = f._internalRoot;
        if (typeof e === "function") {
          var h = e;
          e = function() {
            var a2 = mk(g);
            h.call(a2);
          };
        }
        lk(b, g, a, e);
      } else {
        f = c._reactRootContainer = sk(c, d);
        g = f._internalRoot;
        if (typeof e === "function") {
          var k = e;
          e = function() {
            var a2 = mk(g);
            k.call(a2);
          };
        }
        Xj(function() {
          lk(b, g, a, e);
        });
      }
      return mk(g);
    }
    ec = function(a) {
      if (a.tag === 13) {
        var b = Hg();
        Jg(a, 4, b);
        ok(a, 4);
      }
    };
    fc = function(a) {
      if (a.tag === 13) {
        var b = Hg();
        Jg(a, 67108864, b);
        ok(a, 67108864);
      }
    };
    gc = function(a) {
      if (a.tag === 13) {
        var b = Hg(), c = Ig(a);
        Jg(a, c, b);
        ok(a, c);
      }
    };
    hc = function(a, b) {
      return b();
    };
    yb = function(a, b, c) {
      switch (b) {
        case "input":
          ab(a, c);
          b = c.name;
          if (c.type === "radio" && b != null) {
            for (c = a; c.parentNode; )
              c = c.parentNode;
            c = c.querySelectorAll("input[name=" + JSON.stringify("" + b) + '][type="radio"]');
            for (b = 0; b < c.length; b++) {
              var d = c[b];
              if (d !== a && d.form === a.form) {
                var e = Db(d);
                if (!e)
                  throw Error(y(90));
                Wa(d);
                ab(d, e);
              }
            }
          }
          break;
        case "textarea":
          ib(a, c);
          break;
        case "select":
          b = c.value, b != null && fb(a, !!c.multiple, b, false);
      }
    };
    Gb = Wj;
    Hb = function(a, b, c, d, e) {
      var f = X;
      X |= 4;
      try {
        return gg(98, a.bind(null, b, c, d, e));
      } finally {
        X = f, X === 0 && (wj(), ig());
      }
    };
    Ib = function() {
      (X & 49) === 0 && (Vj(), Oj());
    };
    Jb = function(a, b) {
      var c = X;
      X |= 2;
      try {
        return a(b);
      } finally {
        X = c, X === 0 && (wj(), ig());
      }
    };
    function uk(a, b) {
      var c = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
      if (!rk(b))
        throw Error(y(200));
      return kk(a, b, null, c);
    }
    var vk = {Events: [Cb, ue, Db, Eb, Fb, Oj, {current: false}]};
    var wk = {findFiberByHostInstance: wc, bundleType: 0, version: "17.0.2", rendererPackageName: "react-dom"};
    var xk = {bundleType: wk.bundleType, version: wk.version, rendererPackageName: wk.rendererPackageName, rendererConfig: wk.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: ra.ReactCurrentDispatcher, findHostInstanceByFiber: function(a) {
      a = cc(a);
      return a === null ? null : a.stateNode;
    }, findFiberByHostInstance: wk.findFiberByHostInstance || pk, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null};
    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined") {
      yk = __REACT_DEVTOOLS_GLOBAL_HOOK__;
      if (!yk.isDisabled && yk.supportsFiber)
        try {
          Lf = yk.inject(xk), Mf = yk;
        } catch (a) {
        }
    }
    var yk;
    exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = vk;
    exports.createPortal = uk;
    exports.findDOMNode = function(a) {
      if (a == null)
        return null;
      if (a.nodeType === 1)
        return a;
      var b = a._reactInternals;
      if (b === void 0) {
        if (typeof a.render === "function")
          throw Error(y(188));
        throw Error(y(268, Object.keys(a)));
      }
      a = cc(b);
      a = a === null ? null : a.stateNode;
      return a;
    };
    exports.flushSync = function(a, b) {
      var c = X;
      if ((c & 48) !== 0)
        return a(b);
      X |= 1;
      try {
        if (a)
          return gg(99, a.bind(null, b));
      } finally {
        X = c, ig();
      }
    };
    exports.hydrate = function(a, b, c) {
      if (!rk(b))
        throw Error(y(200));
      return tk(null, a, b, true, c);
    };
    exports.render = function(a, b, c) {
      if (!rk(b))
        throw Error(y(200));
      return tk(null, a, b, false, c);
    };
    exports.unmountComponentAtNode = function(a) {
      if (!rk(a))
        throw Error(y(40));
      return a._reactRootContainer ? (Xj(function() {
        tk(null, null, a, false, function() {
          a._reactRootContainer = null;
          a[ff] = null;
        });
      }), true) : false;
    };
    exports.unstable_batchedUpdates = Wj;
    exports.unstable_createPortal = function(a, b) {
      return uk(a, b, 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null);
    };
    exports.unstable_renderSubtreeIntoContainer = function(a, b, c, d) {
      if (!rk(c))
        throw Error(y(200));
      if (a == null || a._reactInternals === void 0)
        throw Error(y(38));
      return tk(a, b, c, false, d);
    };
    exports.version = "17.0.2";
  });

  // ../../node_modules/.pnpm/react-dom@17.0.2_react@17.0.2/node_modules/react-dom/index.js
  var require_react_dom = __commonJS((exports, module) => {
    "use strict";
    function checkDCE() {
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
        return;
      }
      if (false) {
        throw new Error("^_^");
      }
      try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
      } catch (err) {
        console.error(err);
      }
    }
    if (true) {
      checkDCE();
      module.exports = require_react_dom_production_min();
    } else {
      module.exports = null;
    }
  });

  // ../../node_modules/.pnpm/@fireproof+core@0.7.2/node_modules/@fireproof/core/dist/src/fireproof.js
  var require_fireproof = __commonJS((exports) => {
    "use strict";
    var encode_1$1 = encode$7;
    var MSB$2 = 128;
    var REST$2 = 127;
    var MSBALL$1 = ~REST$2;
    var INT$1 = Math.pow(2, 31);
    function encode$7(num, out, offset) {
      out = out || [];
      offset = offset || 0;
      var oldOffset = offset;
      while (num >= INT$1) {
        out[offset++] = num & 255 | MSB$2;
        num /= 128;
      }
      while (num & MSBALL$1) {
        out[offset++] = num & 255 | MSB$2;
        num >>>= 7;
      }
      out[offset] = num | 0;
      encode$7.bytes = offset - oldOffset + 1;
      return out;
    }
    var decode$9 = read$2;
    var MSB$1$1 = 128;
    var REST$1$1 = 127;
    function read$2(buf2, offset) {
      var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf2.length;
      do {
        if (counter >= l) {
          read$2.bytes = 0;
          throw new RangeError("Could not decode varint");
        }
        b = buf2[counter++];
        res += shift < 28 ? (b & REST$1$1) << shift : (b & REST$1$1) * Math.pow(2, shift);
        shift += 7;
      } while (b >= MSB$1$1);
      read$2.bytes = counter - offset;
      return res;
    }
    var N1$1 = Math.pow(2, 7);
    var N2$1 = Math.pow(2, 14);
    var N3$1 = Math.pow(2, 21);
    var N4$1 = Math.pow(2, 28);
    var N5$1 = Math.pow(2, 35);
    var N6$1 = Math.pow(2, 42);
    var N7$1 = Math.pow(2, 49);
    var N8$1 = Math.pow(2, 56);
    var N9$1 = Math.pow(2, 63);
    var length$1 = function(value) {
      return value < N1$1 ? 1 : value < N2$1 ? 2 : value < N3$1 ? 3 : value < N4$1 ? 4 : value < N5$1 ? 5 : value < N6$1 ? 6 : value < N7$1 ? 7 : value < N8$1 ? 8 : value < N9$1 ? 9 : 10;
    };
    var varint$1 = {
      encode: encode_1$1,
      decode: decode$9,
      encodingLength: length$1
    };
    var _brrp_varint = varint$1;
    var decode$8 = (data, offset = 0) => {
      const code2 = _brrp_varint.decode(data, offset);
      return [code2, _brrp_varint.decode.bytes];
    };
    var encodeTo = (int, target, offset = 0) => {
      _brrp_varint.encode(int, target, offset);
      return target;
    };
    var encodingLength = (int) => {
      return _brrp_varint.encodingLength(int);
    };
    var equals$1 = (aa, bb) => {
      if (aa === bb)
        return true;
      if (aa.byteLength !== bb.byteLength) {
        return false;
      }
      for (let ii = 0; ii < aa.byteLength; ii++) {
        if (aa[ii] !== bb[ii]) {
          return false;
        }
      }
      return true;
    };
    var coerce = (o) => {
      if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
        return o;
      if (o instanceof ArrayBuffer)
        return new Uint8Array(o);
      if (ArrayBuffer.isView(o)) {
        return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
      }
      throw new Error("Unknown type, must be binary type");
    };
    var create$7 = (code2, digest) => {
      const size = digest.byteLength;
      const sizeOffset = encodingLength(code2);
      const digestOffset = sizeOffset + encodingLength(size);
      const bytes = new Uint8Array(digestOffset + size);
      encodeTo(code2, bytes, 0);
      encodeTo(size, bytes, sizeOffset);
      bytes.set(digest, digestOffset);
      return new Digest(code2, size, digest, bytes);
    };
    var decode$7 = (multihash) => {
      const bytes = coerce(multihash);
      const [code2, sizeOffset] = decode$8(bytes);
      const [size, digestOffset] = decode$8(bytes.subarray(sizeOffset));
      const digest = bytes.subarray(sizeOffset + digestOffset);
      if (digest.byteLength !== size) {
        throw new Error("Incorrect length");
      }
      return new Digest(code2, size, digest, bytes);
    };
    var equals = (a, b) => {
      if (a === b) {
        return true;
      } else {
        const data = b;
        return a.code === data.code && a.size === data.size && data.bytes instanceof Uint8Array && equals$1(a.bytes, data.bytes);
      }
    };
    var Digest = class {
      constructor(code2, size, digest, bytes) {
        this.code = code2;
        this.size = size;
        this.digest = digest;
        this.bytes = bytes;
      }
    };
    function base$2(ALPHABET, name2) {
      if (ALPHABET.length >= 255) {
        throw new TypeError("Alphabet too long");
      }
      var BASE_MAP = new Uint8Array(256);
      for (var j = 0; j < BASE_MAP.length; j++) {
        BASE_MAP[j] = 255;
      }
      for (var i = 0; i < ALPHABET.length; i++) {
        var x = ALPHABET.charAt(i);
        var xc = x.charCodeAt(0);
        if (BASE_MAP[xc] !== 255) {
          throw new TypeError(x + " is ambiguous");
        }
        BASE_MAP[xc] = i;
      }
      var BASE = ALPHABET.length;
      var LEADER = ALPHABET.charAt(0);
      var FACTOR = Math.log(BASE) / Math.log(256);
      var iFACTOR = Math.log(256) / Math.log(BASE);
      function encode2(source) {
        if (source instanceof Uint8Array)
          ;
        else if (ArrayBuffer.isView(source)) {
          source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
        } else if (Array.isArray(source)) {
          source = Uint8Array.from(source);
        }
        if (!(source instanceof Uint8Array)) {
          throw new TypeError("Expected Uint8Array");
        }
        if (source.length === 0) {
          return "";
        }
        var zeroes = 0;
        var length2 = 0;
        var pbegin = 0;
        var pend = source.length;
        while (pbegin !== pend && source[pbegin] === 0) {
          pbegin++;
          zeroes++;
        }
        var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
        var b58 = new Uint8Array(size);
        while (pbegin !== pend) {
          var carry = source[pbegin];
          var i2 = 0;
          for (var it1 = size - 1; (carry !== 0 || i2 < length2) && it1 !== -1; it1--, i2++) {
            carry += 256 * b58[it1] >>> 0;
            b58[it1] = carry % BASE >>> 0;
            carry = carry / BASE >>> 0;
          }
          if (carry !== 0) {
            throw new Error("Non-zero carry");
          }
          length2 = i2;
          pbegin++;
        }
        var it2 = size - length2;
        while (it2 !== size && b58[it2] === 0) {
          it2++;
        }
        var str = LEADER.repeat(zeroes);
        for (; it2 < size; ++it2) {
          str += ALPHABET.charAt(b58[it2]);
        }
        return str;
      }
      function decodeUnsafe(source) {
        if (typeof source !== "string") {
          throw new TypeError("Expected String");
        }
        if (source.length === 0) {
          return new Uint8Array();
        }
        var psz = 0;
        if (source[psz] === " ") {
          return;
        }
        var zeroes = 0;
        var length2 = 0;
        while (source[psz] === LEADER) {
          zeroes++;
          psz++;
        }
        var size = (source.length - psz) * FACTOR + 1 >>> 0;
        var b256 = new Uint8Array(size);
        while (source[psz]) {
          var carry = BASE_MAP[source.charCodeAt(psz)];
          if (carry === 255) {
            return;
          }
          var i2 = 0;
          for (var it3 = size - 1; (carry !== 0 || i2 < length2) && it3 !== -1; it3--, i2++) {
            carry += BASE * b256[it3] >>> 0;
            b256[it3] = carry % 256 >>> 0;
            carry = carry / 256 >>> 0;
          }
          if (carry !== 0) {
            throw new Error("Non-zero carry");
          }
          length2 = i2;
          psz++;
        }
        if (source[psz] === " ") {
          return;
        }
        var it4 = size - length2;
        while (it4 !== size && b256[it4] === 0) {
          it4++;
        }
        var vch = new Uint8Array(zeroes + (size - it4));
        var j2 = zeroes;
        while (it4 !== size) {
          vch[j2++] = b256[it4++];
        }
        return vch;
      }
      function decode2(string) {
        var buffer2 = decodeUnsafe(string);
        if (buffer2) {
          return buffer2;
        }
        throw new Error(`Non-${name2} character`);
      }
      return {
        encode: encode2,
        decodeUnsafe,
        decode: decode2
      };
    }
    var src = base$2;
    var _brrp__multiformats_scope_baseX = src;
    var Encoder = class {
      constructor(name2, prefix, baseEncode) {
        this.name = name2;
        this.prefix = prefix;
        this.baseEncode = baseEncode;
      }
      encode(bytes) {
        if (bytes instanceof Uint8Array) {
          return `${this.prefix}${this.baseEncode(bytes)}`;
        } else {
          throw Error("Unknown type, must be binary type");
        }
      }
    };
    var Decoder = class {
      constructor(name2, prefix, baseDecode) {
        this.name = name2;
        this.prefix = prefix;
        if (prefix.codePointAt(0) === void 0) {
          throw new Error("Invalid prefix character");
        }
        this.prefixCodePoint = prefix.codePointAt(0);
        this.baseDecode = baseDecode;
      }
      decode(text) {
        if (typeof text === "string") {
          if (text.codePointAt(0) !== this.prefixCodePoint) {
            throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
          }
          return this.baseDecode(text.slice(this.prefix.length));
        } else {
          throw Error("Can only multibase decode strings");
        }
      }
      or(decoder) {
        return or(this, decoder);
      }
    };
    var ComposedDecoder = class {
      constructor(decoders2) {
        this.decoders = decoders2;
      }
      or(decoder) {
        return or(this, decoder);
      }
      decode(input) {
        const prefix = input[0];
        const decoder = this.decoders[prefix];
        if (decoder) {
          return decoder.decode(input);
        } else {
          throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
        }
      }
    };
    var or = (left, right) => new ComposedDecoder({
      ...left.decoders || {[left.prefix]: left},
      ...right.decoders || {[right.prefix]: right}
    });
    var Codec = class {
      constructor(name2, prefix, baseEncode, baseDecode) {
        this.name = name2;
        this.prefix = prefix;
        this.baseEncode = baseEncode;
        this.baseDecode = baseDecode;
        this.encoder = new Encoder(name2, prefix, baseEncode);
        this.decoder = new Decoder(name2, prefix, baseDecode);
      }
      encode(input) {
        return this.encoder.encode(input);
      }
      decode(input) {
        return this.decoder.decode(input);
      }
    };
    var from$2 = ({name: name2, prefix, encode: encode2, decode: decode2}) => new Codec(name2, prefix, encode2, decode2);
    var baseX = ({prefix, name: name2, alphabet}) => {
      const {encode: encode2, decode: decode2} = _brrp__multiformats_scope_baseX(alphabet, name2);
      return from$2({
        prefix,
        name: name2,
        encode: encode2,
        decode: (text) => coerce(decode2(text))
      });
    };
    var decode$6 = (string, alphabet, bitsPerChar, name2) => {
      const codes2 = {};
      for (let i = 0; i < alphabet.length; ++i) {
        codes2[alphabet[i]] = i;
      }
      let end = string.length;
      while (string[end - 1] === "=") {
        --end;
      }
      const out = new Uint8Array(end * bitsPerChar / 8 | 0);
      let bits = 0;
      let buffer2 = 0;
      let written = 0;
      for (let i = 0; i < end; ++i) {
        const value = codes2[string[i]];
        if (value === void 0) {
          throw new SyntaxError(`Non-${name2} character`);
        }
        buffer2 = buffer2 << bitsPerChar | value;
        bits += bitsPerChar;
        if (bits >= 8) {
          bits -= 8;
          out[written++] = 255 & buffer2 >> bits;
        }
      }
      if (bits >= bitsPerChar || 255 & buffer2 << 8 - bits) {
        throw new SyntaxError("Unexpected end of data");
      }
      return out;
    };
    var encode$6 = (data, alphabet, bitsPerChar) => {
      const pad2 = alphabet[alphabet.length - 1] === "=";
      const mask2 = (1 << bitsPerChar) - 1;
      let out = "";
      let bits = 0;
      let buffer2 = 0;
      for (let i = 0; i < data.length; ++i) {
        buffer2 = buffer2 << 8 | data[i];
        bits += 8;
        while (bits > bitsPerChar) {
          bits -= bitsPerChar;
          out += alphabet[mask2 & buffer2 >> bits];
        }
      }
      if (bits) {
        out += alphabet[mask2 & buffer2 << bitsPerChar - bits];
      }
      if (pad2) {
        while (out.length * bitsPerChar & 7) {
          out += "=";
        }
      }
      return out;
    };
    var rfc4648 = ({name: name2, prefix, bitsPerChar, alphabet}) => {
      return from$2({
        prefix,
        name: name2,
        encode(input) {
          return encode$6(input, alphabet, bitsPerChar);
        },
        decode(input) {
          return decode$6(input, alphabet, bitsPerChar, name2);
        }
      });
    };
    var base58btc = baseX({
      name: "base58btc",
      prefix: "z",
      alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
    });
    baseX({
      name: "base58flickr",
      prefix: "Z",
      alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
    });
    var base32 = rfc4648({
      prefix: "b",
      name: "base32",
      alphabet: "abcdefghijklmnopqrstuvwxyz234567",
      bitsPerChar: 5
    });
    rfc4648({
      prefix: "B",
      name: "base32upper",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
      bitsPerChar: 5
    });
    rfc4648({
      prefix: "c",
      name: "base32pad",
      alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
      bitsPerChar: 5
    });
    rfc4648({
      prefix: "C",
      name: "base32padupper",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
      bitsPerChar: 5
    });
    rfc4648({
      prefix: "v",
      name: "base32hex",
      alphabet: "0123456789abcdefghijklmnopqrstuv",
      bitsPerChar: 5
    });
    rfc4648({
      prefix: "V",
      name: "base32hexupper",
      alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
      bitsPerChar: 5
    });
    rfc4648({
      prefix: "t",
      name: "base32hexpad",
      alphabet: "0123456789abcdefghijklmnopqrstuv=",
      bitsPerChar: 5
    });
    rfc4648({
      prefix: "T",
      name: "base32hexpadupper",
      alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
      bitsPerChar: 5
    });
    rfc4648({
      prefix: "h",
      name: "base32z",
      alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
      bitsPerChar: 5
    });
    var format$1 = (link, base2) => {
      const {bytes, version: version2} = link;
      switch (version2) {
        case 0:
          return toStringV0(bytes, baseCache(link), base2 || base58btc.encoder);
        default:
          return toStringV1(bytes, baseCache(link), base2 || base32.encoder);
      }
    };
    var cache = new WeakMap();
    var baseCache = (cid) => {
      const baseCache2 = cache.get(cid);
      if (baseCache2 == null) {
        const baseCache3 = new Map();
        cache.set(cid, baseCache3);
        return baseCache3;
      }
      return baseCache2;
    };
    var CID = class {
      constructor(version2, code2, multihash, bytes) {
        this.code = code2;
        this.version = version2;
        this.multihash = multihash;
        this.bytes = bytes;
        this["/"] = bytes;
      }
      get asCID() {
        return this;
      }
      get byteOffset() {
        return this.bytes.byteOffset;
      }
      get byteLength() {
        return this.bytes.byteLength;
      }
      toV0() {
        switch (this.version) {
          case 0: {
            return this;
          }
          case 1: {
            const {code: code2, multihash} = this;
            if (code2 !== DAG_PB_CODE) {
              throw new Error("Cannot convert a non dag-pb CID to CIDv0");
            }
            if (multihash.code !== SHA_256_CODE) {
              throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
            }
            return CID.createV0(multihash);
          }
          default: {
            throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
          }
        }
      }
      toV1() {
        switch (this.version) {
          case 0: {
            const {code: code2, digest} = this.multihash;
            const multihash = create$7(code2, digest);
            return CID.createV1(this.code, multihash);
          }
          case 1: {
            return this;
          }
          default: {
            throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`);
          }
        }
      }
      equals(other) {
        return CID.equals(this, other);
      }
      static equals(self2, other) {
        const unknown = other;
        return unknown && self2.code === unknown.code && self2.version === unknown.version && equals(self2.multihash, unknown.multihash);
      }
      toString(base2) {
        return format$1(this, base2);
      }
      toJSON() {
        return {"/": format$1(this)};
      }
      link() {
        return this;
      }
      get [Symbol.toStringTag]() {
        return "CID";
      }
      [Symbol.for("nodejs.util.inspect.custom")]() {
        return `CID(${this.toString()})`;
      }
      static asCID(input) {
        if (input == null) {
          return null;
        }
        const value = input;
        if (value instanceof CID) {
          return value;
        } else if (value["/"] != null && value["/"] === value.bytes || value.asCID === value) {
          const {version: version2, code: code2, multihash, bytes} = value;
          return new CID(version2, code2, multihash, bytes || encodeCID(version2, code2, multihash.bytes));
        } else if (value[cidSymbol] === true) {
          const {version: version2, multihash, code: code2} = value;
          const digest = decode$7(multihash);
          return CID.create(version2, code2, digest);
        } else {
          return null;
        }
      }
      static create(version2, code2, digest) {
        if (typeof code2 !== "number") {
          throw new Error("String codecs are no longer supported");
        }
        if (!(digest.bytes instanceof Uint8Array)) {
          throw new Error("Invalid digest");
        }
        switch (version2) {
          case 0: {
            if (code2 !== DAG_PB_CODE) {
              throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`);
            } else {
              return new CID(version2, code2, digest, digest.bytes);
            }
          }
          case 1: {
            const bytes = encodeCID(version2, code2, digest.bytes);
            return new CID(version2, code2, digest, bytes);
          }
          default: {
            throw new Error("Invalid version");
          }
        }
      }
      static createV0(digest) {
        return CID.create(0, DAG_PB_CODE, digest);
      }
      static createV1(code2, digest) {
        return CID.create(1, code2, digest);
      }
      static decode(bytes) {
        const [cid, remainder] = CID.decodeFirst(bytes);
        if (remainder.length) {
          throw new Error("Incorrect length");
        }
        return cid;
      }
      static decodeFirst(bytes) {
        const specs = CID.inspectBytes(bytes);
        const prefixSize = specs.size - specs.multihashSize;
        const multihashBytes = coerce(bytes.subarray(prefixSize, prefixSize + specs.multihashSize));
        if (multihashBytes.byteLength !== specs.multihashSize) {
          throw new Error("Incorrect length");
        }
        const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
        const digest = new Digest(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
        const cid = specs.version === 0 ? CID.createV0(digest) : CID.createV1(specs.codec, digest);
        return [cid, bytes.subarray(specs.size)];
      }
      static inspectBytes(initialBytes) {
        let offset = 0;
        const next = () => {
          const [i, length2] = decode$8(initialBytes.subarray(offset));
          offset += length2;
          return i;
        };
        let version2 = next();
        let codec2 = DAG_PB_CODE;
        if (version2 === 18) {
          version2 = 0;
          offset = 0;
        } else {
          codec2 = next();
        }
        if (version2 !== 0 && version2 !== 1) {
          throw new RangeError(`Invalid CID version ${version2}`);
        }
        const prefixSize = offset;
        const multihashCode = next();
        const digestSize = next();
        const size = offset + digestSize;
        const multihashSize = size - prefixSize;
        return {version: version2, codec: codec2, multihashCode, digestSize, multihashSize, size};
      }
      static parse(source, base2) {
        const [prefix, bytes] = parseCIDtoBytes(source, base2);
        const cid = CID.decode(bytes);
        if (cid.version === 0 && source[0] !== "Q") {
          throw Error("Version 0 CID string must not include multibase prefix");
        }
        baseCache(cid).set(prefix, source);
        return cid;
      }
    };
    var parseCIDtoBytes = (source, base2) => {
      switch (source[0]) {
        case "Q": {
          const decoder = base2 || base58btc;
          return [
            base58btc.prefix,
            decoder.decode(`${base58btc.prefix}${source}`)
          ];
        }
        case base58btc.prefix: {
          const decoder = base2 || base58btc;
          return [base58btc.prefix, decoder.decode(source)];
        }
        case base32.prefix: {
          const decoder = base2 || base32;
          return [base32.prefix, decoder.decode(source)];
        }
        default: {
          if (base2 == null) {
            throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");
          }
          return [source[0], base2.decode(source)];
        }
      }
    };
    var toStringV0 = (bytes, cache2, base2) => {
      const {prefix} = base2;
      if (prefix !== base58btc.prefix) {
        throw Error(`Cannot string encode V0 in ${base2.name} encoding`);
      }
      const cid = cache2.get(prefix);
      if (cid == null) {
        const cid2 = base2.encode(bytes).slice(1);
        cache2.set(prefix, cid2);
        return cid2;
      } else {
        return cid;
      }
    };
    var toStringV1 = (bytes, cache2, base2) => {
      const {prefix} = base2;
      const cid = cache2.get(prefix);
      if (cid == null) {
        const cid2 = base2.encode(bytes);
        cache2.set(prefix, cid2);
        return cid2;
      } else {
        return cid;
      }
    };
    var DAG_PB_CODE = 112;
    var SHA_256_CODE = 18;
    var encodeCID = (version2, code2, multihash) => {
      const codeOffset = encodingLength(version2);
      const hashOffset = codeOffset + encodingLength(code2);
      const bytes = new Uint8Array(hashOffset + multihash.byteLength);
      encodeTo(version2, bytes, 0);
      encodeTo(code2, bytes, codeOffset);
      bytes.set(multihash, hashOffset);
      return bytes;
    };
    var cidSymbol = Symbol.for("@ipld/js-cid/CID");
    var from$1 = ({name: name2, code: code2, encode: encode2}) => new Hasher(name2, code2, encode2);
    var Hasher = class {
      constructor(name2, code2, encode2) {
        this.name = name2;
        this.code = code2;
        this.encode = encode2;
      }
      digest(input) {
        if (input instanceof Uint8Array) {
          const result = this.encode(input);
          return result instanceof Uint8Array ? create$7(this.code, result) : result.then((digest) => create$7(this.code, digest));
        } else {
          throw Error("Unknown type, must be binary type");
        }
      }
    };
    function readonly({enumerable = true, configurable = false} = {}) {
      return {enumerable, configurable, writable: false};
    }
    function* linksWithin(path, value) {
      if (value != null && typeof value === "object") {
        if (Array.isArray(value)) {
          for (const [index2, element] of value.entries()) {
            const elementPath = [...path, index2];
            const cid = CID.asCID(element);
            if (cid) {
              yield [elementPath.join("/"), cid];
            } else if (typeof element === "object") {
              yield* links(element, elementPath);
            }
          }
        } else {
          const cid = CID.asCID(value);
          if (cid) {
            yield [path.join("/"), cid];
          } else {
            yield* links(value, path);
          }
        }
      }
    }
    function* links(source, base2) {
      if (source == null || source instanceof Uint8Array) {
        return;
      }
      const cid = CID.asCID(source);
      if (cid) {
        yield [base2.join("/"), cid];
      }
      for (const [key2, value] of Object.entries(source)) {
        const path = [...base2, key2];
        yield* linksWithin(path, value);
      }
    }
    function* treeWithin(path, value) {
      if (Array.isArray(value)) {
        for (const [index2, element] of value.entries()) {
          const elementPath = [...path, index2];
          yield elementPath.join("/");
          if (typeof element === "object" && !CID.asCID(element)) {
            yield* tree(element, elementPath);
          }
        }
      } else {
        yield* tree(value, path);
      }
    }
    function* tree(source, base2) {
      if (source == null || typeof source !== "object") {
        return;
      }
      for (const [key2, value] of Object.entries(source)) {
        const path = [...base2, key2];
        yield path.join("/");
        if (value != null && !(value instanceof Uint8Array) && typeof value === "object" && !CID.asCID(value)) {
          yield* treeWithin(path, value);
        }
      }
    }
    function get$1(source, path) {
      let node2 = source;
      for (const [index2, key2] of path.entries()) {
        node2 = node2[key2];
        if (node2 == null) {
          throw new Error(`Object has no property at ${path.slice(0, index2 + 1).map((part) => `[${JSON.stringify(part)}]`).join("")}`);
        }
        const cid = CID.asCID(node2);
        if (cid) {
          return {value: cid, remaining: path.slice(index2 + 1).join("/")};
        }
      }
      return {value: node2};
    }
    var Block = class {
      constructor({cid, bytes, value}) {
        if (!cid || !bytes || typeof value === "undefined") {
          throw new Error("Missing required argument");
        }
        this.cid = cid;
        this.bytes = bytes;
        this.value = value;
        this.asBlock = this;
        Object.defineProperties(this, {
          cid: readonly(),
          bytes: readonly(),
          value: readonly(),
          asBlock: readonly()
        });
      }
      links() {
        return links(this.value, []);
      }
      tree() {
        return tree(this.value, []);
      }
      get(path = "/") {
        return get$1(this.value, path.split("/").filter(Boolean));
      }
    };
    async function encode$5({value, codec: codec2, hasher: hasher2}) {
      if (typeof value === "undefined")
        throw new Error('Missing required argument "value"');
      if (!codec2 || !hasher2)
        throw new Error("Missing required argument: codec or hasher");
      const bytes = codec2.encode(value);
      const hash2 = await hasher2.digest(bytes);
      const cid = CID.create(1, codec2.code, hash2);
      return new Block({value, bytes, cid});
    }
    async function decode$5({bytes, codec: codec2, hasher: hasher2}) {
      if (!bytes)
        throw new Error('Missing required argument "bytes"');
      if (!codec2 || !hasher2)
        throw new Error("Missing required argument: codec or hasher");
      const value = codec2.decode(bytes);
      const hash2 = await hasher2.digest(bytes);
      const cid = CID.create(1, codec2.code, hash2);
      return new Block({value, bytes, cid});
    }
    function createUnsafe({bytes, cid, value: maybeValue, codec: codec2}) {
      const value = maybeValue !== void 0 ? maybeValue : codec2 && codec2.decode(bytes);
      if (value === void 0)
        throw new Error('Missing required argument, must either provide "value" or "codec"');
      return new Block({
        cid,
        bytes,
        value
      });
    }
    async function create$6({bytes, cid, hasher: hasher2, codec: codec2}) {
      if (!bytes)
        throw new Error('Missing required argument "bytes"');
      if (!hasher2)
        throw new Error('Missing required argument "hasher"');
      const value = codec2.decode(bytes);
      const hash2 = await hasher2.digest(bytes);
      if (!equals$1(cid.multihash.bytes, hash2.bytes)) {
        throw new Error("CID hash does not match bytes");
      }
      return createUnsafe({
        bytes,
        cid,
        value,
        codec: codec2
      });
    }
    var sha$2 = (name2) => async (data) => new Uint8Array(await crypto.subtle.digest(name2, data));
    var sha256$2 = from$1({
      name: "sha2-256",
      code: 18,
      encode: sha$2("SHA-256")
    });
    var typeofs = [
      "string",
      "number",
      "bigint",
      "symbol"
    ];
    var objectTypeNames = [
      "Function",
      "Generator",
      "AsyncGenerator",
      "GeneratorFunction",
      "AsyncGeneratorFunction",
      "AsyncFunction",
      "Observable",
      "Array",
      "Buffer",
      "Object",
      "RegExp",
      "Date",
      "Error",
      "Map",
      "Set",
      "WeakMap",
      "WeakSet",
      "ArrayBuffer",
      "SharedArrayBuffer",
      "DataView",
      "Promise",
      "URL",
      "HTMLElement",
      "Int8Array",
      "Uint8Array",
      "Uint8ClampedArray",
      "Int16Array",
      "Uint16Array",
      "Int32Array",
      "Uint32Array",
      "Float32Array",
      "Float64Array",
      "BigInt64Array",
      "BigUint64Array"
    ];
    function is(value) {
      if (value === null) {
        return "null";
      }
      if (value === void 0) {
        return "undefined";
      }
      if (value === true || value === false) {
        return "boolean";
      }
      const typeOf = typeof value;
      if (typeofs.includes(typeOf)) {
        return typeOf;
      }
      if (typeOf === "function") {
        return "Function";
      }
      if (Array.isArray(value)) {
        return "Array";
      }
      if (isBuffer$3(value)) {
        return "Buffer";
      }
      const objectType = getObjectType(value);
      if (objectType) {
        return objectType;
      }
      return "Object";
    }
    function isBuffer$3(value) {
      return value && value.constructor && value.constructor.isBuffer && value.constructor.isBuffer.call(null, value);
    }
    function getObjectType(value) {
      const objectTypeName = Object.prototype.toString.call(value).slice(8, -1);
      if (objectTypeNames.includes(objectTypeName)) {
        return objectTypeName;
      }
      return void 0;
    }
    var Type = class {
      constructor(major, name2, terminal) {
        this.major = major;
        this.majorEncoded = major << 5;
        this.name = name2;
        this.terminal = terminal;
      }
      toString() {
        return `Type[${this.major}].${this.name}`;
      }
      compare(typ) {
        return this.major < typ.major ? -1 : this.major > typ.major ? 1 : 0;
      }
    };
    Type.uint = new Type(0, "uint", true);
    Type.negint = new Type(1, "negint", true);
    Type.bytes = new Type(2, "bytes", true);
    Type.string = new Type(3, "string", true);
    Type.array = new Type(4, "array", false);
    Type.map = new Type(5, "map", false);
    Type.tag = new Type(6, "tag", false);
    Type.float = new Type(7, "float", true);
    Type.false = new Type(7, "false", true);
    Type.true = new Type(7, "true", true);
    Type.null = new Type(7, "null", true);
    Type.undefined = new Type(7, "undefined", true);
    Type.break = new Type(7, "break", true);
    var Token = class {
      constructor(type, value, encodedLength) {
        this.type = type;
        this.value = value;
        this.encodedLength = encodedLength;
        this.encodedBytes = void 0;
        this.byteValue = void 0;
      }
      toString() {
        return `Token[${this.type}].${this.value}`;
      }
    };
    var useBuffer = globalThis.process && !globalThis.process.browser && globalThis.Buffer && typeof globalThis.Buffer.isBuffer === "function";
    var textDecoder$1 = new TextDecoder();
    var textEncoder$1 = new TextEncoder();
    function isBuffer$2(buf2) {
      return useBuffer && globalThis.Buffer.isBuffer(buf2);
    }
    function asU8A(buf2) {
      if (!(buf2 instanceof Uint8Array)) {
        return Uint8Array.from(buf2);
      }
      return isBuffer$2(buf2) ? new Uint8Array(buf2.buffer, buf2.byteOffset, buf2.byteLength) : buf2;
    }
    var toString$1 = useBuffer ? (bytes, start, end) => {
      return end - start > 64 ? globalThis.Buffer.from(bytes.subarray(start, end)).toString("utf8") : utf8Slice$1(bytes, start, end);
    } : (bytes, start, end) => {
      return end - start > 64 ? textDecoder$1.decode(bytes.subarray(start, end)) : utf8Slice$1(bytes, start, end);
    };
    var fromString$1 = useBuffer ? (string) => {
      return string.length > 64 ? globalThis.Buffer.from(string) : utf8ToBytes$1(string);
    } : (string) => {
      return string.length > 64 ? textEncoder$1.encode(string) : utf8ToBytes$1(string);
    };
    var fromArray = (arr) => {
      return Uint8Array.from(arr);
    };
    var slice = useBuffer ? (bytes, start, end) => {
      if (isBuffer$2(bytes)) {
        return new Uint8Array(bytes.subarray(start, end));
      }
      return bytes.slice(start, end);
    } : (bytes, start, end) => {
      return bytes.slice(start, end);
    };
    var concat$1 = useBuffer ? (chunks, length2) => {
      chunks = chunks.map((c) => c instanceof Uint8Array ? c : globalThis.Buffer.from(c));
      return asU8A(globalThis.Buffer.concat(chunks, length2));
    } : (chunks, length2) => {
      const out = new Uint8Array(length2);
      let off2 = 0;
      for (let b of chunks) {
        if (off2 + b.length > out.length) {
          b = b.subarray(0, out.length - off2);
        }
        out.set(b, off2);
        off2 += b.length;
      }
      return out;
    };
    var alloc$1 = useBuffer ? (size) => {
      return globalThis.Buffer.allocUnsafe(size);
    } : (size) => {
      return new Uint8Array(size);
    };
    function compare$3(b1, b2) {
      if (isBuffer$2(b1) && isBuffer$2(b2)) {
        return b1.compare(b2);
      }
      for (let i = 0; i < b1.length; i++) {
        if (b1[i] === b2[i]) {
          continue;
        }
        return b1[i] < b2[i] ? -1 : 1;
      }
      return 0;
    }
    function utf8ToBytes$1(string, units = Infinity) {
      let codePoint;
      const length2 = string.length;
      let leadSurrogate = null;
      const bytes = [];
      for (let i = 0; i < length2; ++i) {
        codePoint = string.charCodeAt(i);
        if (codePoint > 55295 && codePoint < 57344) {
          if (!leadSurrogate) {
            if (codePoint > 56319) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            } else if (i + 1 === length2) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            }
            leadSurrogate = codePoint;
            continue;
          }
          if (codePoint < 56320) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            leadSurrogate = codePoint;
            continue;
          }
          codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
        }
        leadSurrogate = null;
        if (codePoint < 128) {
          if ((units -= 1) < 0)
            break;
          bytes.push(codePoint);
        } else if (codePoint < 2048) {
          if ((units -= 2) < 0)
            break;
          bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
        } else if (codePoint < 65536) {
          if ((units -= 3) < 0)
            break;
          bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
        } else if (codePoint < 1114112) {
          if ((units -= 4) < 0)
            break;
          bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
        } else {
          throw new Error("Invalid code point");
        }
      }
      return bytes;
    }
    function utf8Slice$1(buf2, offset, end) {
      const res = [];
      while (offset < end) {
        const firstByte = buf2[offset];
        let codePoint = null;
        let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (offset + bytesPerSequence <= end) {
          let secondByte, thirdByte, fourthByte, tempCodePoint;
          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 128) {
                codePoint = firstByte;
              }
              break;
            case 2:
              secondByte = buf2[offset + 1];
              if ((secondByte & 192) === 128) {
                tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                if (tempCodePoint > 127) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 3:
              secondByte = buf2[offset + 1];
              thirdByte = buf2[offset + 2];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 4:
              secondByte = buf2[offset + 1];
              thirdByte = buf2[offset + 2];
              fourthByte = buf2[offset + 3];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }
        if (codePoint === null) {
          codePoint = 65533;
          bytesPerSequence = 1;
        } else if (codePoint > 65535) {
          codePoint -= 65536;
          res.push(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        offset += bytesPerSequence;
      }
      return decodeCodePointsArray$1(res);
    }
    var MAX_ARGUMENTS_LENGTH$1 = 4096;
    function decodeCodePointsArray$1(codePoints) {
      const len = codePoints.length;
      if (len <= MAX_ARGUMENTS_LENGTH$1) {
        return String.fromCharCode.apply(String, codePoints);
      }
      let res = "";
      let i = 0;
      while (i < len) {
        res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH$1));
      }
      return res;
    }
    var defaultChunkSize = 256;
    var Bl = class {
      constructor(chunkSize = defaultChunkSize) {
        this.chunkSize = chunkSize;
        this.cursor = 0;
        this.maxCursor = -1;
        this.chunks = [];
        this._initReuseChunk = null;
      }
      reset() {
        this.cursor = 0;
        this.maxCursor = -1;
        if (this.chunks.length) {
          this.chunks = [];
        }
        if (this._initReuseChunk !== null) {
          this.chunks.push(this._initReuseChunk);
          this.maxCursor = this._initReuseChunk.length - 1;
        }
      }
      push(bytes) {
        let topChunk = this.chunks[this.chunks.length - 1];
        const newMax = this.cursor + bytes.length;
        if (newMax <= this.maxCursor + 1) {
          const chunkPos = topChunk.length - (this.maxCursor - this.cursor) - 1;
          topChunk.set(bytes, chunkPos);
        } else {
          if (topChunk) {
            const chunkPos = topChunk.length - (this.maxCursor - this.cursor) - 1;
            if (chunkPos < topChunk.length) {
              this.chunks[this.chunks.length - 1] = topChunk.subarray(0, chunkPos);
              this.maxCursor = this.cursor - 1;
            }
          }
          if (bytes.length < 64 && bytes.length < this.chunkSize) {
            topChunk = alloc$1(this.chunkSize);
            this.chunks.push(topChunk);
            this.maxCursor += topChunk.length;
            if (this._initReuseChunk === null) {
              this._initReuseChunk = topChunk;
            }
            topChunk.set(bytes, 0);
          } else {
            this.chunks.push(bytes);
            this.maxCursor += bytes.length;
          }
        }
        this.cursor += bytes.length;
      }
      toBytes(reset = false) {
        let byts;
        if (this.chunks.length === 1) {
          const chunk = this.chunks[0];
          if (reset && this.cursor > chunk.length / 2) {
            byts = this.cursor === chunk.length ? chunk : chunk.subarray(0, this.cursor);
            this._initReuseChunk = null;
            this.chunks = [];
          } else {
            byts = slice(chunk, 0, this.cursor);
          }
        } else {
          byts = concat$1(this.chunks, this.cursor);
        }
        if (reset) {
          this.reset();
        }
        return byts;
      }
    };
    var decodeErrPrefix = "CBOR decode error:";
    var encodeErrPrefix = "CBOR encode error:";
    function assertEnoughData(data, pos, need) {
      if (data.length - pos < need) {
        throw new Error(`${decodeErrPrefix} not enough data for type`);
      }
    }
    var uintBoundaries = [
      24,
      256,
      65536,
      4294967296,
      BigInt("18446744073709551616")
    ];
    function readUint8(data, offset, options) {
      assertEnoughData(data, offset, 1);
      const value = data[offset];
      if (options.strict === true && value < uintBoundaries[0]) {
        throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
      }
      return value;
    }
    function readUint16(data, offset, options) {
      assertEnoughData(data, offset, 2);
      const value = data[offset] << 8 | data[offset + 1];
      if (options.strict === true && value < uintBoundaries[1]) {
        throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
      }
      return value;
    }
    function readUint32(data, offset, options) {
      assertEnoughData(data, offset, 4);
      const value = data[offset] * 16777216 + (data[offset + 1] << 16) + (data[offset + 2] << 8) + data[offset + 3];
      if (options.strict === true && value < uintBoundaries[2]) {
        throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
      }
      return value;
    }
    function readUint64(data, offset, options) {
      assertEnoughData(data, offset, 8);
      const hi = data[offset] * 16777216 + (data[offset + 1] << 16) + (data[offset + 2] << 8) + data[offset + 3];
      const lo = data[offset + 4] * 16777216 + (data[offset + 5] << 16) + (data[offset + 6] << 8) + data[offset + 7];
      const value = (BigInt(hi) << BigInt(32)) + BigInt(lo);
      if (options.strict === true && value < uintBoundaries[3]) {
        throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
      }
      if (value <= Number.MAX_SAFE_INTEGER) {
        return Number(value);
      }
      if (options.allowBigInt === true) {
        return value;
      }
      throw new Error(`${decodeErrPrefix} integers outside of the safe integer range are not supported`);
    }
    function decodeUint8(data, pos, _minor, options) {
      return new Token(Type.uint, readUint8(data, pos + 1, options), 2);
    }
    function decodeUint16(data, pos, _minor, options) {
      return new Token(Type.uint, readUint16(data, pos + 1, options), 3);
    }
    function decodeUint32(data, pos, _minor, options) {
      return new Token(Type.uint, readUint32(data, pos + 1, options), 5);
    }
    function decodeUint64(data, pos, _minor, options) {
      return new Token(Type.uint, readUint64(data, pos + 1, options), 9);
    }
    function encodeUint(buf2, token) {
      return encodeUintValue(buf2, 0, token.value);
    }
    function encodeUintValue(buf2, major, uint) {
      if (uint < uintBoundaries[0]) {
        const nuint = Number(uint);
        buf2.push([major | nuint]);
      } else if (uint < uintBoundaries[1]) {
        const nuint = Number(uint);
        buf2.push([
          major | 24,
          nuint
        ]);
      } else if (uint < uintBoundaries[2]) {
        const nuint = Number(uint);
        buf2.push([
          major | 25,
          nuint >>> 8,
          nuint & 255
        ]);
      } else if (uint < uintBoundaries[3]) {
        const nuint = Number(uint);
        buf2.push([
          major | 26,
          nuint >>> 24 & 255,
          nuint >>> 16 & 255,
          nuint >>> 8 & 255,
          nuint & 255
        ]);
      } else {
        const buint = BigInt(uint);
        if (buint < uintBoundaries[4]) {
          const set = [
            major | 27,
            0,
            0,
            0,
            0,
            0,
            0,
            0
          ];
          let lo = Number(buint & BigInt(4294967295));
          let hi = Number(buint >> BigInt(32) & BigInt(4294967295));
          set[8] = lo & 255;
          lo = lo >> 8;
          set[7] = lo & 255;
          lo = lo >> 8;
          set[6] = lo & 255;
          lo = lo >> 8;
          set[5] = lo & 255;
          set[4] = hi & 255;
          hi = hi >> 8;
          set[3] = hi & 255;
          hi = hi >> 8;
          set[2] = hi & 255;
          hi = hi >> 8;
          set[1] = hi & 255;
          buf2.push(set);
        } else {
          throw new Error(`${decodeErrPrefix} encountered BigInt larger than allowable range`);
        }
      }
    }
    encodeUint.encodedSize = function encodedSize(token) {
      return encodeUintValue.encodedSize(token.value);
    };
    encodeUintValue.encodedSize = function encodedSize(uint) {
      if (uint < uintBoundaries[0]) {
        return 1;
      }
      if (uint < uintBoundaries[1]) {
        return 2;
      }
      if (uint < uintBoundaries[2]) {
        return 3;
      }
      if (uint < uintBoundaries[3]) {
        return 5;
      }
      return 9;
    };
    encodeUint.compareTokens = function compareTokens(tok1, tok2) {
      return tok1.value < tok2.value ? -1 : tok1.value > tok2.value ? 1 : 0;
    };
    function decodeNegint8(data, pos, _minor, options) {
      return new Token(Type.negint, -1 - readUint8(data, pos + 1, options), 2);
    }
    function decodeNegint16(data, pos, _minor, options) {
      return new Token(Type.negint, -1 - readUint16(data, pos + 1, options), 3);
    }
    function decodeNegint32(data, pos, _minor, options) {
      return new Token(Type.negint, -1 - readUint32(data, pos + 1, options), 5);
    }
    var neg1b = BigInt(-1);
    var pos1b = BigInt(1);
    function decodeNegint64(data, pos, _minor, options) {
      const int = readUint64(data, pos + 1, options);
      if (typeof int !== "bigint") {
        const value = -1 - int;
        if (value >= Number.MIN_SAFE_INTEGER) {
          return new Token(Type.negint, value, 9);
        }
      }
      if (options.allowBigInt !== true) {
        throw new Error(`${decodeErrPrefix} integers outside of the safe integer range are not supported`);
      }
      return new Token(Type.negint, neg1b - BigInt(int), 9);
    }
    function encodeNegint(buf2, token) {
      const negint = token.value;
      const unsigned = typeof negint === "bigint" ? negint * neg1b - pos1b : negint * -1 - 1;
      encodeUintValue(buf2, token.type.majorEncoded, unsigned);
    }
    encodeNegint.encodedSize = function encodedSize(token) {
      const negint = token.value;
      const unsigned = typeof negint === "bigint" ? negint * neg1b - pos1b : negint * -1 - 1;
      if (unsigned < uintBoundaries[0]) {
        return 1;
      }
      if (unsigned < uintBoundaries[1]) {
        return 2;
      }
      if (unsigned < uintBoundaries[2]) {
        return 3;
      }
      if (unsigned < uintBoundaries[3]) {
        return 5;
      }
      return 9;
    };
    encodeNegint.compareTokens = function compareTokens(tok1, tok2) {
      return tok1.value < tok2.value ? 1 : tok1.value > tok2.value ? -1 : 0;
    };
    function toToken$3(data, pos, prefix, length2) {
      assertEnoughData(data, pos, prefix + length2);
      const buf2 = slice(data, pos + prefix, pos + prefix + length2);
      return new Token(Type.bytes, buf2, prefix + length2);
    }
    function decodeBytesCompact(data, pos, minor, _options) {
      return toToken$3(data, pos, 1, minor);
    }
    function decodeBytes8(data, pos, _minor, options) {
      return toToken$3(data, pos, 2, readUint8(data, pos + 1, options));
    }
    function decodeBytes16(data, pos, _minor, options) {
      return toToken$3(data, pos, 3, readUint16(data, pos + 1, options));
    }
    function decodeBytes32(data, pos, _minor, options) {
      return toToken$3(data, pos, 5, readUint32(data, pos + 1, options));
    }
    function decodeBytes64(data, pos, _minor, options) {
      const l = readUint64(data, pos + 1, options);
      if (typeof l === "bigint") {
        throw new Error(`${decodeErrPrefix} 64-bit integer bytes lengths not supported`);
      }
      return toToken$3(data, pos, 9, l);
    }
    function tokenBytes(token) {
      if (token.encodedBytes === void 0) {
        token.encodedBytes = token.type === Type.string ? fromString$1(token.value) : token.value;
      }
      return token.encodedBytes;
    }
    function encodeBytes(buf2, token) {
      const bytes = tokenBytes(token);
      encodeUintValue(buf2, token.type.majorEncoded, bytes.length);
      buf2.push(bytes);
    }
    encodeBytes.encodedSize = function encodedSize(token) {
      const bytes = tokenBytes(token);
      return encodeUintValue.encodedSize(bytes.length) + bytes.length;
    };
    encodeBytes.compareTokens = function compareTokens(tok1, tok2) {
      return compareBytes(tokenBytes(tok1), tokenBytes(tok2));
    };
    function compareBytes(b1, b2) {
      return b1.length < b2.length ? -1 : b1.length > b2.length ? 1 : compare$3(b1, b2);
    }
    function toToken$2(data, pos, prefix, length2, options) {
      const totLength = prefix + length2;
      assertEnoughData(data, pos, totLength);
      const tok = new Token(Type.string, toString$1(data, pos + prefix, pos + totLength), totLength);
      if (options.retainStringBytes === true) {
        tok.byteValue = slice(data, pos + prefix, pos + totLength);
      }
      return tok;
    }
    function decodeStringCompact(data, pos, minor, options) {
      return toToken$2(data, pos, 1, minor, options);
    }
    function decodeString8(data, pos, _minor, options) {
      return toToken$2(data, pos, 2, readUint8(data, pos + 1, options), options);
    }
    function decodeString16(data, pos, _minor, options) {
      return toToken$2(data, pos, 3, readUint16(data, pos + 1, options), options);
    }
    function decodeString32(data, pos, _minor, options) {
      return toToken$2(data, pos, 5, readUint32(data, pos + 1, options), options);
    }
    function decodeString64(data, pos, _minor, options) {
      const l = readUint64(data, pos + 1, options);
      if (typeof l === "bigint") {
        throw new Error(`${decodeErrPrefix} 64-bit integer string lengths not supported`);
      }
      return toToken$2(data, pos, 9, l, options);
    }
    var encodeString = encodeBytes;
    function toToken$1(_data, _pos, prefix, length2) {
      return new Token(Type.array, length2, prefix);
    }
    function decodeArrayCompact(data, pos, minor, _options) {
      return toToken$1(data, pos, 1, minor);
    }
    function decodeArray8(data, pos, _minor, options) {
      return toToken$1(data, pos, 2, readUint8(data, pos + 1, options));
    }
    function decodeArray16(data, pos, _minor, options) {
      return toToken$1(data, pos, 3, readUint16(data, pos + 1, options));
    }
    function decodeArray32(data, pos, _minor, options) {
      return toToken$1(data, pos, 5, readUint32(data, pos + 1, options));
    }
    function decodeArray64(data, pos, _minor, options) {
      const l = readUint64(data, pos + 1, options);
      if (typeof l === "bigint") {
        throw new Error(`${decodeErrPrefix} 64-bit integer array lengths not supported`);
      }
      return toToken$1(data, pos, 9, l);
    }
    function decodeArrayIndefinite(data, pos, _minor, options) {
      if (options.allowIndefinite === false) {
        throw new Error(`${decodeErrPrefix} indefinite length items not allowed`);
      }
      return toToken$1(data, pos, 1, Infinity);
    }
    function encodeArray(buf2, token) {
      encodeUintValue(buf2, Type.array.majorEncoded, token.value);
    }
    encodeArray.compareTokens = encodeUint.compareTokens;
    encodeArray.encodedSize = function encodedSize(token) {
      return encodeUintValue.encodedSize(token.value);
    };
    function toToken(_data, _pos, prefix, length2) {
      return new Token(Type.map, length2, prefix);
    }
    function decodeMapCompact(data, pos, minor, _options) {
      return toToken(data, pos, 1, minor);
    }
    function decodeMap8(data, pos, _minor, options) {
      return toToken(data, pos, 2, readUint8(data, pos + 1, options));
    }
    function decodeMap16(data, pos, _minor, options) {
      return toToken(data, pos, 3, readUint16(data, pos + 1, options));
    }
    function decodeMap32(data, pos, _minor, options) {
      return toToken(data, pos, 5, readUint32(data, pos + 1, options));
    }
    function decodeMap64(data, pos, _minor, options) {
      const l = readUint64(data, pos + 1, options);
      if (typeof l === "bigint") {
        throw new Error(`${decodeErrPrefix} 64-bit integer map lengths not supported`);
      }
      return toToken(data, pos, 9, l);
    }
    function decodeMapIndefinite(data, pos, _minor, options) {
      if (options.allowIndefinite === false) {
        throw new Error(`${decodeErrPrefix} indefinite length items not allowed`);
      }
      return toToken(data, pos, 1, Infinity);
    }
    function encodeMap(buf2, token) {
      encodeUintValue(buf2, Type.map.majorEncoded, token.value);
    }
    encodeMap.compareTokens = encodeUint.compareTokens;
    encodeMap.encodedSize = function encodedSize(token) {
      return encodeUintValue.encodedSize(token.value);
    };
    function decodeTagCompact(_data, _pos, minor, _options) {
      return new Token(Type.tag, minor, 1);
    }
    function decodeTag8(data, pos, _minor, options) {
      return new Token(Type.tag, readUint8(data, pos + 1, options), 2);
    }
    function decodeTag16(data, pos, _minor, options) {
      return new Token(Type.tag, readUint16(data, pos + 1, options), 3);
    }
    function decodeTag32(data, pos, _minor, options) {
      return new Token(Type.tag, readUint32(data, pos + 1, options), 5);
    }
    function decodeTag64(data, pos, _minor, options) {
      return new Token(Type.tag, readUint64(data, pos + 1, options), 9);
    }
    function encodeTag(buf2, token) {
      encodeUintValue(buf2, Type.tag.majorEncoded, token.value);
    }
    encodeTag.compareTokens = encodeUint.compareTokens;
    encodeTag.encodedSize = function encodedSize(token) {
      return encodeUintValue.encodedSize(token.value);
    };
    var MINOR_FALSE = 20;
    var MINOR_TRUE = 21;
    var MINOR_NULL = 22;
    var MINOR_UNDEFINED = 23;
    function decodeUndefined(_data, _pos, _minor, options) {
      if (options.allowUndefined === false) {
        throw new Error(`${decodeErrPrefix} undefined values are not supported`);
      } else if (options.coerceUndefinedToNull === true) {
        return new Token(Type.null, null, 1);
      }
      return new Token(Type.undefined, void 0, 1);
    }
    function decodeBreak(_data, _pos, _minor, options) {
      if (options.allowIndefinite === false) {
        throw new Error(`${decodeErrPrefix} indefinite length items not allowed`);
      }
      return new Token(Type.break, void 0, 1);
    }
    function createToken(value, bytes, options) {
      if (options) {
        if (options.allowNaN === false && Number.isNaN(value)) {
          throw new Error(`${decodeErrPrefix} NaN values are not supported`);
        }
        if (options.allowInfinity === false && (value === Infinity || value === -Infinity)) {
          throw new Error(`${decodeErrPrefix} Infinity values are not supported`);
        }
      }
      return new Token(Type.float, value, bytes);
    }
    function decodeFloat16(data, pos, _minor, options) {
      return createToken(readFloat16(data, pos + 1), 3, options);
    }
    function decodeFloat32(data, pos, _minor, options) {
      return createToken(readFloat32(data, pos + 1), 5, options);
    }
    function decodeFloat64(data, pos, _minor, options) {
      return createToken(readFloat64(data, pos + 1), 9, options);
    }
    function encodeFloat(buf2, token, options) {
      const float = token.value;
      if (float === false) {
        buf2.push([Type.float.majorEncoded | MINOR_FALSE]);
      } else if (float === true) {
        buf2.push([Type.float.majorEncoded | MINOR_TRUE]);
      } else if (float === null) {
        buf2.push([Type.float.majorEncoded | MINOR_NULL]);
      } else if (float === void 0) {
        buf2.push([Type.float.majorEncoded | MINOR_UNDEFINED]);
      } else {
        let decoded;
        let success = false;
        if (!options || options.float64 !== true) {
          encodeFloat16(float);
          decoded = readFloat16(ui8a, 1);
          if (float === decoded || Number.isNaN(float)) {
            ui8a[0] = 249;
            buf2.push(ui8a.slice(0, 3));
            success = true;
          } else {
            encodeFloat32(float);
            decoded = readFloat32(ui8a, 1);
            if (float === decoded) {
              ui8a[0] = 250;
              buf2.push(ui8a.slice(0, 5));
              success = true;
            }
          }
        }
        if (!success) {
          encodeFloat64(float);
          decoded = readFloat64(ui8a, 1);
          ui8a[0] = 251;
          buf2.push(ui8a.slice(0, 9));
        }
      }
    }
    encodeFloat.encodedSize = function encodedSize(token, options) {
      const float = token.value;
      if (float === false || float === true || float === null || float === void 0) {
        return 1;
      }
      if (!options || options.float64 !== true) {
        encodeFloat16(float);
        let decoded = readFloat16(ui8a, 1);
        if (float === decoded || Number.isNaN(float)) {
          return 3;
        }
        encodeFloat32(float);
        decoded = readFloat32(ui8a, 1);
        if (float === decoded) {
          return 5;
        }
      }
      return 9;
    };
    var buffer$1 = new ArrayBuffer(9);
    var dataView = new DataView(buffer$1, 1);
    var ui8a = new Uint8Array(buffer$1, 0);
    function encodeFloat16(inp) {
      if (inp === Infinity) {
        dataView.setUint16(0, 31744, false);
      } else if (inp === -Infinity) {
        dataView.setUint16(0, 64512, false);
      } else if (Number.isNaN(inp)) {
        dataView.setUint16(0, 32256, false);
      } else {
        dataView.setFloat32(0, inp);
        const valu32 = dataView.getUint32(0);
        const exponent = (valu32 & 2139095040) >> 23;
        const mantissa = valu32 & 8388607;
        if (exponent === 255) {
          dataView.setUint16(0, 31744, false);
        } else if (exponent === 0) {
          dataView.setUint16(0, (inp & 2147483648) >> 16 | mantissa >> 13, false);
        } else {
          const logicalExponent = exponent - 127;
          if (logicalExponent < -24) {
            dataView.setUint16(0, 0);
          } else if (logicalExponent < -14) {
            dataView.setUint16(0, (valu32 & 2147483648) >> 16 | 1 << 24 + logicalExponent, false);
          } else {
            dataView.setUint16(0, (valu32 & 2147483648) >> 16 | logicalExponent + 15 << 10 | mantissa >> 13, false);
          }
        }
      }
    }
    function readFloat16(ui8a2, pos) {
      if (ui8a2.length - pos < 2) {
        throw new Error(`${decodeErrPrefix} not enough data for float16`);
      }
      const half = (ui8a2[pos] << 8) + ui8a2[pos + 1];
      if (half === 31744) {
        return Infinity;
      }
      if (half === 64512) {
        return -Infinity;
      }
      if (half === 32256) {
        return NaN;
      }
      const exp = half >> 10 & 31;
      const mant = half & 1023;
      let val;
      if (exp === 0) {
        val = mant * 2 ** -24;
      } else if (exp !== 31) {
        val = (mant + 1024) * 2 ** (exp - 25);
      } else {
        val = mant === 0 ? Infinity : NaN;
      }
      return half & 32768 ? -val : val;
    }
    function encodeFloat32(inp) {
      dataView.setFloat32(0, inp, false);
    }
    function readFloat32(ui8a2, pos) {
      if (ui8a2.length - pos < 4) {
        throw new Error(`${decodeErrPrefix} not enough data for float32`);
      }
      const offset = (ui8a2.byteOffset || 0) + pos;
      return new DataView(ui8a2.buffer, offset, 4).getFloat32(0, false);
    }
    function encodeFloat64(inp) {
      dataView.setFloat64(0, inp, false);
    }
    function readFloat64(ui8a2, pos) {
      if (ui8a2.length - pos < 8) {
        throw new Error(`${decodeErrPrefix} not enough data for float64`);
      }
      const offset = (ui8a2.byteOffset || 0) + pos;
      return new DataView(ui8a2.buffer, offset, 8).getFloat64(0, false);
    }
    encodeFloat.compareTokens = encodeUint.compareTokens;
    function invalidMinor(data, pos, minor) {
      throw new Error(`${decodeErrPrefix} encountered invalid minor (${minor}) for major ${data[pos] >>> 5}`);
    }
    function errorer(msg) {
      return () => {
        throw new Error(`${decodeErrPrefix} ${msg}`);
      };
    }
    var jump = [];
    for (let i = 0; i <= 23; i++) {
      jump[i] = invalidMinor;
    }
    jump[24] = decodeUint8;
    jump[25] = decodeUint16;
    jump[26] = decodeUint32;
    jump[27] = decodeUint64;
    jump[28] = invalidMinor;
    jump[29] = invalidMinor;
    jump[30] = invalidMinor;
    jump[31] = invalidMinor;
    for (let i = 32; i <= 55; i++) {
      jump[i] = invalidMinor;
    }
    jump[56] = decodeNegint8;
    jump[57] = decodeNegint16;
    jump[58] = decodeNegint32;
    jump[59] = decodeNegint64;
    jump[60] = invalidMinor;
    jump[61] = invalidMinor;
    jump[62] = invalidMinor;
    jump[63] = invalidMinor;
    for (let i = 64; i <= 87; i++) {
      jump[i] = decodeBytesCompact;
    }
    jump[88] = decodeBytes8;
    jump[89] = decodeBytes16;
    jump[90] = decodeBytes32;
    jump[91] = decodeBytes64;
    jump[92] = invalidMinor;
    jump[93] = invalidMinor;
    jump[94] = invalidMinor;
    jump[95] = errorer("indefinite length bytes/strings are not supported");
    for (let i = 96; i <= 119; i++) {
      jump[i] = decodeStringCompact;
    }
    jump[120] = decodeString8;
    jump[121] = decodeString16;
    jump[122] = decodeString32;
    jump[123] = decodeString64;
    jump[124] = invalidMinor;
    jump[125] = invalidMinor;
    jump[126] = invalidMinor;
    jump[127] = errorer("indefinite length bytes/strings are not supported");
    for (let i = 128; i <= 151; i++) {
      jump[i] = decodeArrayCompact;
    }
    jump[152] = decodeArray8;
    jump[153] = decodeArray16;
    jump[154] = decodeArray32;
    jump[155] = decodeArray64;
    jump[156] = invalidMinor;
    jump[157] = invalidMinor;
    jump[158] = invalidMinor;
    jump[159] = decodeArrayIndefinite;
    for (let i = 160; i <= 183; i++) {
      jump[i] = decodeMapCompact;
    }
    jump[184] = decodeMap8;
    jump[185] = decodeMap16;
    jump[186] = decodeMap32;
    jump[187] = decodeMap64;
    jump[188] = invalidMinor;
    jump[189] = invalidMinor;
    jump[190] = invalidMinor;
    jump[191] = decodeMapIndefinite;
    for (let i = 192; i <= 215; i++) {
      jump[i] = decodeTagCompact;
    }
    jump[216] = decodeTag8;
    jump[217] = decodeTag16;
    jump[218] = decodeTag32;
    jump[219] = decodeTag64;
    jump[220] = invalidMinor;
    jump[221] = invalidMinor;
    jump[222] = invalidMinor;
    jump[223] = invalidMinor;
    for (let i = 224; i <= 243; i++) {
      jump[i] = errorer("simple values are not supported");
    }
    jump[244] = invalidMinor;
    jump[245] = invalidMinor;
    jump[246] = invalidMinor;
    jump[247] = decodeUndefined;
    jump[248] = errorer("simple values are not supported");
    jump[249] = decodeFloat16;
    jump[250] = decodeFloat32;
    jump[251] = decodeFloat64;
    jump[252] = invalidMinor;
    jump[253] = invalidMinor;
    jump[254] = invalidMinor;
    jump[255] = decodeBreak;
    var quick = [];
    for (let i = 0; i < 24; i++) {
      quick[i] = new Token(Type.uint, i, 1);
    }
    for (let i = -1; i >= -24; i--) {
      quick[31 - i] = new Token(Type.negint, i, 1);
    }
    quick[64] = new Token(Type.bytes, new Uint8Array(0), 1);
    quick[96] = new Token(Type.string, "", 1);
    quick[128] = new Token(Type.array, 0, 1);
    quick[160] = new Token(Type.map, 0, 1);
    quick[244] = new Token(Type.false, false, 1);
    quick[245] = new Token(Type.true, true, 1);
    quick[246] = new Token(Type.null, null, 1);
    function quickEncodeToken(token) {
      switch (token.type) {
        case Type.false:
          return fromArray([244]);
        case Type.true:
          return fromArray([245]);
        case Type.null:
          return fromArray([246]);
        case Type.bytes:
          if (!token.value.length) {
            return fromArray([64]);
          }
          return;
        case Type.string:
          if (token.value === "") {
            return fromArray([96]);
          }
          return;
        case Type.array:
          if (token.value === 0) {
            return fromArray([128]);
          }
          return;
        case Type.map:
          if (token.value === 0) {
            return fromArray([160]);
          }
          return;
        case Type.uint:
          if (token.value < 24) {
            return fromArray([Number(token.value)]);
          }
          return;
        case Type.negint:
          if (token.value >= -24) {
            return fromArray([31 - Number(token.value)]);
          }
      }
    }
    var defaultEncodeOptions$1 = {
      float64: false,
      mapSorter,
      quickEncodeToken
    };
    function makeCborEncoders() {
      const encoders2 = [];
      encoders2[Type.uint.major] = encodeUint;
      encoders2[Type.negint.major] = encodeNegint;
      encoders2[Type.bytes.major] = encodeBytes;
      encoders2[Type.string.major] = encodeString;
      encoders2[Type.array.major] = encodeArray;
      encoders2[Type.map.major] = encodeMap;
      encoders2[Type.tag.major] = encodeTag;
      encoders2[Type.float.major] = encodeFloat;
      return encoders2;
    }
    var cborEncoders$1 = makeCborEncoders();
    var buf = new Bl();
    var Ref = class {
      constructor(obj, parent) {
        this.obj = obj;
        this.parent = parent;
      }
      includes(obj) {
        let p = this;
        do {
          if (p.obj === obj) {
            return true;
          }
        } while (p = p.parent);
        return false;
      }
      static createCheck(stack, obj) {
        if (stack && stack.includes(obj)) {
          throw new Error(`${encodeErrPrefix} object contains circular references`);
        }
        return new Ref(obj, stack);
      }
    };
    var simpleTokens = {
      null: new Token(Type.null, null),
      undefined: new Token(Type.undefined, void 0),
      true: new Token(Type.true, true),
      false: new Token(Type.false, false),
      emptyArray: new Token(Type.array, 0),
      emptyMap: new Token(Type.map, 0)
    };
    var typeEncoders = {
      number(obj, _typ, _options, _refStack) {
        if (!Number.isInteger(obj) || !Number.isSafeInteger(obj)) {
          return new Token(Type.float, obj);
        } else if (obj >= 0) {
          return new Token(Type.uint, obj);
        } else {
          return new Token(Type.negint, obj);
        }
      },
      bigint(obj, _typ, _options, _refStack) {
        if (obj >= BigInt(0)) {
          return new Token(Type.uint, obj);
        } else {
          return new Token(Type.negint, obj);
        }
      },
      Uint8Array(obj, _typ, _options, _refStack) {
        return new Token(Type.bytes, obj);
      },
      string(obj, _typ, _options, _refStack) {
        return new Token(Type.string, obj);
      },
      boolean(obj, _typ, _options, _refStack) {
        return obj ? simpleTokens.true : simpleTokens.false;
      },
      null(_obj, _typ, _options, _refStack) {
        return simpleTokens.null;
      },
      undefined(_obj, _typ, _options, _refStack) {
        return simpleTokens.undefined;
      },
      ArrayBuffer(obj, _typ, _options, _refStack) {
        return new Token(Type.bytes, new Uint8Array(obj));
      },
      DataView(obj, _typ, _options, _refStack) {
        return new Token(Type.bytes, new Uint8Array(obj.buffer, obj.byteOffset, obj.byteLength));
      },
      Array(obj, _typ, options, refStack) {
        if (!obj.length) {
          if (options.addBreakTokens === true) {
            return [
              simpleTokens.emptyArray,
              new Token(Type.break)
            ];
          }
          return simpleTokens.emptyArray;
        }
        refStack = Ref.createCheck(refStack, obj);
        const entries = [];
        let i = 0;
        for (const e of obj) {
          entries[i++] = objectToTokens(e, options, refStack);
        }
        if (options.addBreakTokens) {
          return [
            new Token(Type.array, obj.length),
            entries,
            new Token(Type.break)
          ];
        }
        return [
          new Token(Type.array, obj.length),
          entries
        ];
      },
      Object(obj, typ, options, refStack) {
        const isMap = typ !== "Object";
        const keys2 = isMap ? obj.keys() : Object.keys(obj);
        const length2 = isMap ? obj.size : keys2.length;
        if (!length2) {
          if (options.addBreakTokens === true) {
            return [
              simpleTokens.emptyMap,
              new Token(Type.break)
            ];
          }
          return simpleTokens.emptyMap;
        }
        refStack = Ref.createCheck(refStack, obj);
        const entries = [];
        let i = 0;
        for (const key2 of keys2) {
          entries[i++] = [
            objectToTokens(key2, options, refStack),
            objectToTokens(isMap ? obj.get(key2) : obj[key2], options, refStack)
          ];
        }
        sortMapEntries(entries, options);
        if (options.addBreakTokens) {
          return [
            new Token(Type.map, length2),
            entries,
            new Token(Type.break)
          ];
        }
        return [
          new Token(Type.map, length2),
          entries
        ];
      }
    };
    typeEncoders.Map = typeEncoders.Object;
    typeEncoders.Buffer = typeEncoders.Uint8Array;
    for (const typ of "Uint8Clamped Uint16 Uint32 Int8 Int16 Int32 BigUint64 BigInt64 Float32 Float64".split(" ")) {
      typeEncoders[`${typ}Array`] = typeEncoders.DataView;
    }
    function objectToTokens(obj, options = {}, refStack) {
      const typ = is(obj);
      const customTypeEncoder = options && options.typeEncoders && options.typeEncoders[typ] || typeEncoders[typ];
      if (typeof customTypeEncoder === "function") {
        const tokens = customTypeEncoder(obj, typ, options, refStack);
        if (tokens != null) {
          return tokens;
        }
      }
      const typeEncoder = typeEncoders[typ];
      if (!typeEncoder) {
        throw new Error(`${encodeErrPrefix} unsupported type: ${typ}`);
      }
      return typeEncoder(obj, typ, options, refStack);
    }
    function sortMapEntries(entries, options) {
      if (options.mapSorter) {
        entries.sort(options.mapSorter);
      }
    }
    function mapSorter(e1, e2) {
      const keyToken1 = Array.isArray(e1[0]) ? e1[0][0] : e1[0];
      const keyToken2 = Array.isArray(e2[0]) ? e2[0][0] : e2[0];
      if (keyToken1.type !== keyToken2.type) {
        return keyToken1.type.compare(keyToken2.type);
      }
      const major = keyToken1.type.major;
      const tcmp = cborEncoders$1[major].compareTokens(keyToken1, keyToken2);
      if (tcmp === 0) {
        console.warn("WARNING: complex key types used, CBOR key sorting guarantees are gone");
      }
      return tcmp;
    }
    function tokensToEncoded(buf2, tokens, encoders2, options) {
      if (Array.isArray(tokens)) {
        for (const token of tokens) {
          tokensToEncoded(buf2, token, encoders2, options);
        }
      } else {
        encoders2[tokens.type.major](buf2, tokens, options);
      }
    }
    function encodeCustom(data, encoders2, options) {
      const tokens = objectToTokens(data, options);
      if (!Array.isArray(tokens) && options.quickEncodeToken) {
        const quickBytes = options.quickEncodeToken(tokens);
        if (quickBytes) {
          return quickBytes;
        }
        const encoder = encoders2[tokens.type.major];
        if (encoder.encodedSize) {
          const size = encoder.encodedSize(tokens, options);
          const buf2 = new Bl(size);
          encoder(buf2, tokens, options);
          if (buf2.chunks.length !== 1) {
            throw new Error(`Unexpected error: pre-calculated length for ${tokens} was wrong`);
          }
          return asU8A(buf2.chunks[0]);
        }
      }
      buf.reset();
      tokensToEncoded(buf, tokens, encoders2, options);
      return buf.toBytes(true);
    }
    function encode$4(data, options) {
      options = Object.assign({}, defaultEncodeOptions$1, options);
      return encodeCustom(data, cborEncoders$1, options);
    }
    var defaultDecodeOptions = {
      strict: false,
      allowIndefinite: true,
      allowUndefined: true,
      allowBigInt: true
    };
    var Tokeniser = class {
      constructor(data, options = {}) {
        this.pos = 0;
        this.data = data;
        this.options = options;
      }
      done() {
        return this.pos >= this.data.length;
      }
      next() {
        const byt = this.data[this.pos];
        let token = quick[byt];
        if (token === void 0) {
          const decoder = jump[byt];
          if (!decoder) {
            throw new Error(`${decodeErrPrefix} no decoder for major type ${byt >>> 5} (byte 0x${byt.toString(16).padStart(2, "0")})`);
          }
          const minor = byt & 31;
          token = decoder(this.data, this.pos, minor, this.options);
        }
        this.pos += token.encodedLength;
        return token;
      }
    };
    var DONE = Symbol.for("DONE");
    var BREAK = Symbol.for("BREAK");
    function tokenToArray(token, tokeniser, options) {
      const arr = [];
      for (let i = 0; i < token.value; i++) {
        const value = tokensToObject(tokeniser, options);
        if (value === BREAK) {
          if (token.value === Infinity) {
            break;
          }
          throw new Error(`${decodeErrPrefix} got unexpected break to lengthed array`);
        }
        if (value === DONE) {
          throw new Error(`${decodeErrPrefix} found array but not enough entries (got ${i}, expected ${token.value})`);
        }
        arr[i] = value;
      }
      return arr;
    }
    function tokenToMap(token, tokeniser, options) {
      const useMaps = options.useMaps === true;
      const obj = useMaps ? void 0 : {};
      const m = useMaps ? new Map() : void 0;
      for (let i = 0; i < token.value; i++) {
        const key2 = tokensToObject(tokeniser, options);
        if (key2 === BREAK) {
          if (token.value === Infinity) {
            break;
          }
          throw new Error(`${decodeErrPrefix} got unexpected break to lengthed map`);
        }
        if (key2 === DONE) {
          throw new Error(`${decodeErrPrefix} found map but not enough entries (got ${i} [no key], expected ${token.value})`);
        }
        if (useMaps !== true && typeof key2 !== "string") {
          throw new Error(`${decodeErrPrefix} non-string keys not supported (got ${typeof key2})`);
        }
        if (options.rejectDuplicateMapKeys === true) {
          if (useMaps && m.has(key2) || !useMaps && key2 in obj) {
            throw new Error(`${decodeErrPrefix} found repeat map key "${key2}"`);
          }
        }
        const value = tokensToObject(tokeniser, options);
        if (value === DONE) {
          throw new Error(`${decodeErrPrefix} found map but not enough entries (got ${i} [no value], expected ${token.value})`);
        }
        if (useMaps) {
          m.set(key2, value);
        } else {
          obj[key2] = value;
        }
      }
      return useMaps ? m : obj;
    }
    function tokensToObject(tokeniser, options) {
      if (tokeniser.done()) {
        return DONE;
      }
      const token = tokeniser.next();
      if (token.type === Type.break) {
        return BREAK;
      }
      if (token.type.terminal) {
        return token.value;
      }
      if (token.type === Type.array) {
        return tokenToArray(token, tokeniser, options);
      }
      if (token.type === Type.map) {
        return tokenToMap(token, tokeniser, options);
      }
      if (token.type === Type.tag) {
        if (options.tags && typeof options.tags[token.value] === "function") {
          const tagged = tokensToObject(tokeniser, options);
          return options.tags[token.value](tagged);
        }
        throw new Error(`${decodeErrPrefix} tag not supported (${token.value})`);
      }
      throw new Error("unsupported");
    }
    function decode$4(data, options) {
      if (!(data instanceof Uint8Array)) {
        throw new Error(`${decodeErrPrefix} data to decode must be a Uint8Array`);
      }
      options = Object.assign({}, defaultDecodeOptions, options);
      const tokeniser = options.tokenizer || new Tokeniser(data, options);
      const decoded = tokensToObject(tokeniser, options);
      if (decoded === DONE) {
        throw new Error(`${decodeErrPrefix} did not find any content to decode`);
      }
      if (decoded === BREAK) {
        throw new Error(`${decodeErrPrefix} got unexpected break`);
      }
      if (!tokeniser.done()) {
        throw new Error(`${decodeErrPrefix} too many terminals, data makes no sense`);
      }
      return decoded;
    }
    var CID_CBOR_TAG = 42;
    function cidEncoder(obj) {
      if (obj.asCID !== obj && obj["/"] !== obj.bytes) {
        return null;
      }
      const cid = CID.asCID(obj);
      if (!cid) {
        return null;
      }
      const bytes = new Uint8Array(cid.bytes.byteLength + 1);
      bytes.set(cid.bytes, 1);
      return [
        new Token(Type.tag, CID_CBOR_TAG),
        new Token(Type.bytes, bytes)
      ];
    }
    function undefinedEncoder() {
      throw new Error("`undefined` is not supported by the IPLD Data Model and cannot be encoded");
    }
    function numberEncoder(num) {
      if (Number.isNaN(num)) {
        throw new Error("`NaN` is not supported by the IPLD Data Model and cannot be encoded");
      }
      if (num === Infinity || num === -Infinity) {
        throw new Error("`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded");
      }
      return null;
    }
    var encodeOptions = {
      float64: true,
      typeEncoders: {
        Object: cidEncoder,
        undefined: undefinedEncoder,
        number: numberEncoder
      }
    };
    function cidDecoder(bytes) {
      if (bytes[0] !== 0) {
        throw new Error("Invalid CID for CBOR tag 42; expected leading 0x00");
      }
      return CID.decode(bytes.subarray(1));
    }
    var decodeOptions = {
      allowIndefinite: false,
      coerceUndefinedToNull: true,
      allowNaN: false,
      allowInfinity: false,
      allowBigInt: true,
      strict: true,
      useMaps: false,
      rejectDuplicateMapKeys: true,
      tags: []
    };
    decodeOptions.tags[CID_CBOR_TAG] = cidDecoder;
    var name$3 = "dag-cbor";
    var code$2 = 113;
    var encode$3 = (node2) => encode$4(node2, encodeOptions);
    var decode$3 = (data) => decode$4(data, decodeOptions);
    var codec$1 = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      code: code$2,
      decode: decode$3,
      encode: encode$3,
      name: name$3
    });
    var readUInt32LE$1 = (buffer2) => {
      const offset = buffer2.byteLength - 4;
      return (buffer2[offset] | buffer2[offset + 1] << 8 | buffer2[offset + 2] << 16) + buffer2[offset + 3] * 16777216;
    };
    var MAX_UINT32$1 = 4294967295;
    var bf = (factor) => {
      const threshold = Math.floor(MAX_UINT32$1 / factor);
      return async (entry) => {
        const identity = await entry.identity();
        if (typeof identity !== "number") {
          throw new Error("Identity must be a number");
        }
        if (identity <= threshold) {
          return true;
        }
        return false;
      };
    };
    var simpleCompare = (a, b) => {
      if (a === b)
        return 0;
      if (a > b)
        return 1;
      return -1;
    };
    var binaryCompare = (b1, b2) => {
      for (let i = 0; i < b1.byteLength; i++) {
        if (b2.byteLength === i)
          return 1;
        const c1 = b1[i];
        const c2 = b2[i];
        if (c1 === c2)
          continue;
        if (c1 > c2)
          return 1;
        else
          return -1;
      }
      if (b2.byteLength > b1.byteLength)
        return -1;
      return 0;
    };
    var CIDCounter = class {
      constructor() {
        this._cids = new Set();
      }
      add(node2) {
        if (!node2.address) {
          throw new Error("Cannot add node without address");
        }
        if (node2.address.then) {
          const p = node2.address.then((cid) => this._cids.add(cid.toString()));
          this._cids.add(p);
          p.then(() => this._cids.delete(p));
        } else {
          this._cids.add(node2.address.toString());
        }
      }
      async all() {
        await Promise.all([...this._cids]);
        return this._cids;
      }
    };
    async function advance(blocks, head, event) {
      const events = new EventFetcher(blocks);
      const headmap = new Map(head.map((cid) => [cid.toString(), cid]));
      if (headmap.has(event.toString()))
        return {head, cids: await events.all()};
      let changed = false;
      for (const cid of head) {
        if (await contains(events, event, cid)) {
          headmap.delete(cid.toString());
          headmap.set(event.toString(), event);
          changed = true;
        }
      }
      if (changed) {
        return {head: [...headmap.values()], cids: await events.all()};
      }
      for (const p of head) {
        if (await contains(events, p, event)) {
          return {head, cids: await events.all()};
        }
      }
      return {head: head.concat(event), cids: await events.all()};
    }
    var EventBlock = class extends Block {
      constructor({cid, value, bytes}) {
        super({cid, value, bytes});
      }
      static create(data, parents) {
        return encodeEventBlock({data, parents: parents ?? []});
      }
    };
    var EventFetcher = class {
      constructor(blocks) {
        this._blocks = blocks;
        this._cids = new CIDCounter();
        this._cache = new Map();
      }
      async get(link) {
        const slink = link.toString();
        if (this._cache.has(slink))
          return this._cache.get(slink);
        const block = await this._blocks.get(link);
        this._cids.add({address: link});
        if (!block)
          throw new Error(`missing block: ${link}`);
        const got = decodeEventBlock(block.bytes);
        this._cache.set(slink, got);
        return got;
      }
      async all() {
        return this._cids.all();
      }
    };
    async function encodeEventBlock(value) {
      const {cid, bytes} = await encode$5({value, codec: codec$1, hasher: sha256$2});
      return new Block({cid, value, bytes});
    }
    async function decodeEventBlock(bytes) {
      const {cid, value} = await decode$5({bytes, codec: codec$1, hasher: sha256$2});
      return new Block({cid, value, bytes});
    }
    async function contains(events, a, b) {
      if (a.toString() === b.toString())
        return true;
      const [{value: aevent}, {value: bevent}] = await Promise.all([events.get(a), events.get(b)]);
      const links2 = [...aevent.parents || []];
      while (links2.length) {
        const link = links2.shift();
        if (!link)
          break;
        if (link.toString() === b.toString())
          return true;
        if (bevent.parents.some((p) => link.toString() === p.toString()))
          continue;
        const {value: event} = await events.get(link);
        links2.push(...event.parents);
      }
      return false;
    }
    async function* vis$1(blocks, head, options = {}) {
      const renderNodeLabel = options.renderNodeLabel ?? ((b) => {
        const {key: key2, root: root2, type} = b.value.data;
        return b.cid.toString() + "\n" + JSON.stringify({key: key2, root: root2.cid.toString(), type}, null, 2).replace(/"/g, "'");
      });
      const events = new EventFetcher(blocks);
      yield "digraph clock {";
      yield '  node [shape=point fontname="Courier"]; head;';
      const hevents = await Promise.all(head.map((link) => events.get(link)));
      const links2 = [];
      const nodes = new Set();
      for (const e of hevents) {
        nodes.add(e.cid.toString());
        yield `  node [shape=oval fontname="Courier"]; ${e.cid} [label="${renderNodeLabel(e)}"];`;
        yield `  head -> ${e.cid};`;
        for (const p of e.value.parents) {
          yield `  ${e.cid} -> ${p};`;
        }
        links2.push(...e.value.parents);
      }
      while (links2.length) {
        const link = links2.shift();
        if (!link)
          break;
        if (nodes.has(link.toString()))
          continue;
        nodes.add(link.toString());
        const block = await events.get(link);
        yield `  node [shape=oval]; ${link} [label="${renderNodeLabel(block)}" fontname="Courier"];`;
        for (const p of block.value.parents) {
          yield `  ${link} -> ${p};`;
        }
        links2.push(...block.value.parents);
      }
      yield "}";
    }
    async function findEventsToSync(blocks, head) {
      const events = new EventFetcher(blocks);
      const {ancestor, sorted} = await findCommonAncestorWithSortedEvents(events, head);
      const toSync = ancestor ? await asyncFilter(sorted, async (uks) => !await contains(events, ancestor, uks.cid)) : sorted;
      const sortDifference = sorted.length - toSync.length;
      if (sortDifference / sorted.length > 0.6)
        console.log("optimize sorted", !!ancestor, sortDifference);
      return {cids: events, events: toSync};
    }
    var asyncFilter = async (arr, predicate) => Promise.all(arr.map(predicate)).then((results) => arr.filter((_v, index2) => results[index2]));
    async function findCommonAncestorWithSortedEvents(events, children, doFull = false) {
      const ancestor = await findCommonAncestor(events, children);
      if (!ancestor) {
        console.log("no common ancestor", children);
        const sorted2 = await findSortedEvents(events, children, children, doFull);
        return {ancestor: null, sorted: sorted2};
      }
      const sorted = await findSortedEvents(events, children, [ancestor], doFull);
      return {ancestor, sorted};
    }
    async function findCommonAncestor(events, children) {
      if (!children.length)
        return;
      children = [...new Set(children)];
      if (children.length === 1)
        return children[0];
      const candidates = children.map((c) => [c]);
      while (true) {
        let changed = false;
        for (const c of candidates) {
          const candidate = await findAncestorCandidate(events, c[c.length - 1]);
          if (!candidate)
            continue;
          if (c.includes(candidate))
            continue;
          changed = true;
          c.push(candidate);
          const ancestor = findCommonString(candidates);
          if (ancestor)
            return ancestor;
        }
        if (!changed)
          return;
      }
    }
    async function findAncestorCandidate(events, root2) {
      const {value: event} = await events.get(root2);
      if (!event.parents.length)
        return root2;
      return event.parents.length === 1 ? event.parents[0] : findCommonAncestor(events, event.parents);
    }
    function findCommonString(arrays) {
      arrays = arrays.map((a) => [...a]);
      for (const arr of arrays) {
        for (const item of arr) {
          let matched = true;
          for (const other of arrays) {
            if (arr === other)
              continue;
            matched = other.some((i) => String(i) === String(item));
            if (!matched)
              break;
          }
          if (matched)
            return item;
        }
      }
    }
    async function findSortedEvents(events, head, tails, doFull) {
      const weights = new Map();
      head = [...new Set([...head.map((h) => h.toString())])];
      const allEvents = new Set([tails.map((t) => t.toString()).toString(), ...head]);
      if (!doFull && allEvents.size === 1) {
        return [];
      }
      const all = await (await Promise.all(tails.map((t) => Promise.all(head.map((h) => findEvents(events, h, t)))))).flat();
      for (const arr of all) {
        for (const {event, depth} of arr) {
          const info = weights.get(event.cid.toString());
          if (info) {
            info.weight += depth;
          } else {
            weights.set(event.cid.toString(), {event, weight: depth});
          }
        }
      }
      const buckets = new Map();
      for (const {event, weight} of weights.values()) {
        const bucket = buckets.get(weight);
        if (bucket) {
          bucket.push(event);
        } else {
          buckets.set(weight, [event]);
        }
      }
      const sorted = Array.from(buckets).sort((a, b) => b[0] - a[0]).flatMap(([, es]) => es.sort((a, b) => String(a.cid) < String(b.cid) ? -1 : 1));
      return sorted;
    }
    async function findEvents(events, start, end, depth = 0) {
      const event = await events.get(start);
      const send = String(end);
      const acc = [{event, depth}];
      const {parents} = event.value;
      if (parents.findIndex((p) => String(p) === send) !== -1)
        return acc;
      const rest = await Promise.all(parents.map((p) => findEvents(events, p, end, depth + 1)));
      return acc.concat(...rest);
    }
    var Entry = class {
      constructor({key: key2, address}, opts = {}) {
        this.key = key2;
        this.address = address;
        this.codec = opts.codec;
        this.hasher = opts.hasher;
      }
      get isEntry() {
        return true;
      }
    };
    var EntryList = class {
      constructor({entries, closed}) {
        if (typeof closed !== "boolean")
          throw new Error('Missing required argument "closed"');
        this.entries = entries;
        this.closed = closed;
        this.startKey = entries[0].key;
      }
      find(key2, compare2) {
        const {entries} = this;
        for (let i = entries.length - 1; i > -1; i--) {
          const entry = entries[i];
          const comp = compare2(key2, entry.key);
          if (comp > -1) {
            return [
              i,
              entry
            ];
          }
        }
        return null;
      }
      findMany(keys2, compare2, sorted = false, strict = false) {
        const {entries} = this;
        const results = new Map();
        if (!sorted) {
          keys2 = keys2.sort(compare2);
        } else {
          keys2 = [...keys2];
        }
        for (let i = entries.length - 1; i > -1; i--) {
          if (!keys2.length)
            break;
          const entry = entries[i];
          const found = [];
          while (keys2.length) {
            let key2 = keys2[keys2.length - 1];
            key2 = key2.key ? key2.key : key2;
            const comp = compare2(key2, entry.key);
            if (!strict) {
              if (comp > -1) {
                found.push(keys2.pop());
              } else {
                break;
              }
            } else {
              if (comp === 0) {
                found.push(keys2.pop());
              } else if (comp > 0) {
                keys2.pop();
              } else {
                break;
              }
            }
          }
          if (found.length) {
            results.set(i, [
              entry,
              found
            ]);
          }
        }
        return results;
      }
      findRange(start, end, compare2) {
        const {entries} = this;
        let last;
        let first = 0;
        for (let i = entries.length - 1; i > -1; i--) {
          const entry = entries[i];
          const comp = compare2(end, entry.key);
          if (comp > 0) {
            last = i;
            break;
          }
        }
        for (let i = 0; i < entries.length; i++) {
          const entry = entries[i];
          const comp = compare2(start, entry.key);
          if (comp === 0) {
            first = i;
            break;
          } else if (comp < 0) {
            break;
          }
          first = i;
        }
        return {
          first,
          last,
          entries: entries.slice(first, last + 1)
        };
      }
    };
    var stringKey = (key2) => typeof key2 === "string" ? key2 : JSON.stringify(key2);
    function sortBulk(bulk, opts) {
      return bulk.sort(({key: a}, {key: b}) => opts.compare(a, b));
    }
    async function filterLeftmostInserts(first, bulk, compare2) {
      const inserts = [];
      for (const b of bulk) {
        const {key: key2, del} = b;
        if (compare2(key2, first) < 0) {
          if (!del)
            inserts.push(b);
        } else {
          break;
        }
      }
      return inserts;
    }
    async function generateNewLeaves(inserts, opts, {chunker: chunker2, compare: compare2}) {
      return await Node.from({
        entries: inserts.map((insert) => new opts.LeafEntryClass(insert, opts)).sort((a, b) => compare2(a.key, b.key)),
        chunker: chunker2,
        NodeClass: opts.LeafClass,
        distance: 0,
        opts
      });
    }
    async function generateBranchEntries(that, newLeaves, results, opts) {
      return await Promise.all(newLeaves.map(async (node2) => {
        const block = await node2.encode();
        results.blocks.push({
          block,
          node: node2
        });
        that.cache.set(node2);
        const newBranchEntry = new opts.BranchEntryClass({
          key: node2.key,
          address: await node2.address
        }, opts);
        return newBranchEntry;
      }));
    }
    async function processRoot(that, results, bulk, nodeOptions) {
      const root2 = results.root;
      results.blocks.push({
        block: await root2.encode(),
        node: root2
      });
      that.cache.set(root2);
      const opts = nodeOptions.opts;
      const distance = root2.distance;
      const first = root2.entryList.startKey;
      const inserts = await filterLeftmostInserts(first, bulk, that.compare);
      if (inserts.length) {
        const newLeaves = await generateNewLeaves(inserts, opts, that);
        const branchEntries = await generateBranchEntries(that, newLeaves, results, opts);
        const firstRootEntry = new opts.BranchEntryClass({
          key: root2.entryList.startKey,
          address: await root2.address
        }, opts);
        const newBranchEntries = [
          firstRootEntry,
          ...branchEntries
        ].sort(({key: a}, {key: b}) => opts.compare(a, b));
        let newBranches = await Node.from({
          ...nodeOptions,
          entries: newBranchEntries,
          chunker: that.chunker,
          NodeClass: opts.BranchClass,
          distance: distance + 1
        });
        let allBranches = [...newBranches];
        while (newBranches.length > 1) {
          const newBranchEntries2 = await Promise.all(newBranches.map(async (l) => new opts.BranchEntryClass({
            key: l.key,
            address: await l.address
          }, opts)));
          newBranches = await Node.from({
            ...nodeOptions,
            entries: newBranchEntries2.sort(({key: a}, {key: b}) => opts.compare(a, b)),
            chunker: that.chunker,
            NodeClass: opts.BranchClass,
            distance: distance + 1
          });
          allBranches = [
            ...allBranches,
            ...newBranches
          ];
        }
        await Promise.all(allBranches.map(async (m) => {
          const block = await m.encode();
          that.cache.set(m);
          results.blocks.push({
            block,
            node: m
          });
        }));
        results.root = newBranches[0];
        results.nodes = [
          ...results.nodes,
          ...allBranches
        ];
      }
    }
    var Node = class {
      constructor({entryList, chunker: chunker2, distance, getNode, compare: compare2, cache: cache2}) {
        this.entryList = entryList;
        this.chunker = chunker2;
        this.distance = distance;
        this.getNode = getNode;
        this.compare = compare2;
        this.cache = cache2;
      }
      get closed() {
        return this.entryList.closed;
      }
      get key() {
        return this.entryList.startKey;
      }
      async getEntry(key2, cids = new CIDCounter()) {
        const result = await this._getEntry(key2, cids);
        return {
          result,
          cids
        };
      }
      async _getEntry(key2, cids) {
        cids.add(this);
        let node2 = this;
        while (!node2.isLeaf) {
          const result2 = node2.entryList.find(key2, this.compare);
          if (result2 === null)
            throw new Error("Not found");
          const [, entry2] = result2;
          node2 = await this.getNode(await entry2.address);
          cids.add(node2);
        }
        const result = node2.entryList.find(key2, this.compare);
        if (result === null || result[1].key.toString() !== key2.toString())
          throw new Error("Not found");
        const [, entry] = result;
        return entry;
      }
      async getAllEntries(cids = new CIDCounter()) {
        const result = await this._getAllEntries(cids);
        return {
          result,
          cids
        };
      }
      _getAllEntries(cids) {
        cids.add(this);
        if (this.isLeaf) {
          return this.entryList.entries;
        } else {
          const {entries} = this.entryList;
          const mapper = async (entry) => this.getNode(await entry.address).then((node2) => node2._getAllEntries(cids)).catch(async (err) => {
            throw err;
          });
          return Promise.all(entries.map(mapper)).then((results) => results.flat());
        }
      }
      async *vis(cids = new Set()) {
        const renderNodeLabel = async (node2) => {
          if (node2.isLeaf) {
            const entries = node2.entryList.entries.map((e) => `[${e.key},${JSON.stringify(e.value).replace(/"/g, "'")}]`).join(", ");
            return `Leaf [${entries}]`;
          } else {
            const entries = node2.entryList.entries.map((e) => `[${e.key}]`).join(", ");
            return `Branch [${entries}]`;
          }
        };
        const shortCid = (cid) => cid.toString().slice(0, 4) + cid.toString().slice(-4);
        const visit = async function* (node2, parentId, cids2) {
          const nodeId = await node2.address;
          if (!cids2.has(nodeId)) {
            cids2.add(nodeId);
            const nodeLabel = await renderNodeLabel(node2);
            yield `  node [shape=ellipse fontname="Courier"]; ${shortCid(nodeId)} [label="${nodeLabel}"];`;
            yield `  ${shortCid(parentId)} -> ${shortCid(nodeId)};`;
            for (const entry of node2.entryList.entries) {
              if (entry.address) {
                const entryId = await entry.address;
                try {
                  const childNode = await node2.getNode(entryId);
                  yield* await visit(childNode, nodeId, cids2);
                } catch (err) {
                  yield `  ${shortCid(nodeId)} -> ${shortCid(entryId)};`;
                  yield `  node [shape=ellipse fontname="Courier"]; ${shortCid(entryId)} [label="Error: ${err.message}"];`;
                }
              }
            }
          }
        };
        yield "digraph tree {";
        yield '  node [shape=ellipse fontname="Courier"]; rootnode;';
        for await (const line of visit(this, "rootnode", cids)) {
          yield line;
        }
        yield "}";
      }
      async getEntries(keys2, sorted = false, cids = new CIDCounter()) {
        const result = await this._getEntries(keys2, sorted, cids);
        return {
          result,
          cids
        };
      }
      async _getEntries(keys2, sorted, cids) {
        cids.add(this);
        if (!sorted)
          keys2 = keys2.sort(this.compare);
        const results = this.entryList.findMany(keys2, this.compare, true, this.isLeaf);
        if (this.isLeaf) {
          return [...results.values()].map(([entry]) => entry);
        }
        let entries = [];
        for (const [entry, keys3] of [...results.values()].reverse()) {
          const p = this.getNode(await entry.address);
          entries.push(p.then((node2) => node2._getEntries(keys3.reverse(), true, cids)));
        }
        entries = await Promise.all(entries);
        return entries.flat();
      }
      async getRangeEntries(start, end, cids = new CIDCounter()) {
        const result = await this._getRangeEntries(start, end, cids);
        return {
          result,
          cids
        };
      }
      _getRangeEntries(start, end, cids) {
        cids.add(this);
        const {entries} = this.entryList.findRange(start, end, this.compare);
        if (this.isLeaf) {
          return entries.filter((entry) => {
            const s = this.compare(start, entry.key);
            const e = this.compare(end, entry.key);
            if (s <= 0 && e >= 0)
              return true;
            return false;
          });
        }
        if (!entries.length)
          return [];
        const thenRange = async (entry) => this.getNode(await entry.address).then((node2) => node2._getRangeEntries(start, end, cids));
        const results = [thenRange(entries.shift())];
        if (!entries.length)
          return results[0];
        const last = thenRange(entries.pop());
        while (entries.length) {
          const thenAll = async (entry) => this.getNode(await entry.address).then(async (node2) => node2._getAllEntries(cids));
          results.push(thenAll(entries.shift()));
        }
        results.push(last);
        return Promise.all(results).then((results2) => results2.flat());
      }
      async transaction(bulk, opts = {}) {
        opts = {
          codec: this.codec,
          hasher: this.hasher,
          getNode: this.getNode,
          compare: this.compare,
          cache: this.cache,
          ...opts
        };
        const nodeOptions = {
          chunker: this.chunker,
          opts
        };
        const results = this.entryList.findMany(bulk, opts.compare, true, this.isLeaf);
        if (this.isLeaf) {
          return await this.transactionLeaf(bulk, opts, nodeOptions, results);
        } else {
          return await this.transactionBranch(bulk, opts, nodeOptions, results);
        }
      }
      async transactionLeaf(bulk, opts, nodeOptions, results) {
        const {LeafClass: LeafClass2, LeafEntryClass} = opts;
        const {entries, previous} = this.processLeafEntries(bulk, results, LeafEntryClass, opts);
        const _opts = {
          ...nodeOptions,
          entries,
          NodeClass: LeafClass2,
          distance: 0
        };
        const nodes = await Node.from(_opts);
        return {
          nodes,
          previous,
          blocks: await Promise.all(nodes.map(async (n) => {
            const block = await n.encode();
            this.cache.set(n);
            return {
              block,
              node: n
            };
          })),
          distance: 0
        };
      }
      processLeafEntries(bulk, results, LeafEntryClass, opts) {
        const previous = [];
        let entries = [];
        const changes = {};
        const deletes = new Map();
        for (const {key: key2, del, value} of bulk) {
          const skey = stringKey(key2);
          if (del) {
            if (typeof changes[skey] === "undefined")
              deletes.set(skey, null);
          } else {
            changes[skey] = {
              key: key2,
              value
            };
            deletes.delete(skey);
          }
        }
        entries = [...this.entryList.entries];
        for (const [i, [entry]] of results) {
          previous.push(entry);
          const skey = stringKey(entry.key);
          if (deletes.has(skey)) {
            deletes.set(skey, i);
          } else {
            entries[i] = new LeafEntryClass(changes[skey], opts);
            delete changes[skey];
          }
        }
        let count = 0;
        for (const [, i] of deletes) {
          if (i !== null)
            entries.splice(i - count++, 1);
        }
        const appends = Object.values(changes).map((obj) => new LeafEntryClass(obj, opts));
        entries = entries.concat(appends).sort(({key: a}, {key: b}) => opts.compare(a, b));
        return {
          entries,
          previous
        };
      }
      async transactionBranch(bulk, opts, nodeOptions, results) {
        const {BranchClass: BranchClass2, BranchEntryClass} = opts;
        let distance = 0;
        for (const [i, [entry, keys2]] of results) {
          const p = this.getNode(await entry.address).then((node2) => node2.transaction(keys2.reverse(), {
            ...opts,
            sorted: true
          })).then((r) => ({
            entry,
            keys: keys2,
            distance,
            ...r
          }));
          results.set(i, p);
        }
        let entries = [...this.entryList.entries];
        const final = {
          previous: [],
          blocks: [],
          nodes: []
        };
        for (const [i, p] of results) {
          const {
            nodes,
            previous,
            blocks,
            distance: _distance
          } = await p;
          distance = _distance;
          entries[i] = nodes;
          if (previous.length)
            final.previous = final.previous.concat(previous);
          if (blocks.length)
            final.blocks = final.blocks.concat(blocks);
          if (nodes.length)
            final.nodes = final.nodes.concat(nodes);
        }
        entries = entries.flat();
        const newEntries = await this.handlePrepend(entries, opts, nodeOptions, final, distance);
        distance++;
        const toEntry = async (branch) => {
          if (branch.isEntry)
            return branch;
          const block = await branch.encode();
          final.blocks.push({
            block,
            node: branch
          });
          this.cache.set(branch);
          return new BranchEntryClass(branch, opts);
        };
        entries = await Promise.all(newEntries.map(toEntry));
        const _opts = {
          ...nodeOptions,
          entries,
          NodeClass: BranchClass2,
          distance
        };
        const newNodes = await Node.from(_opts);
        await Promise.all(newNodes.map(async (n) => {
          const block = await n.encode();
          final.blocks.push({
            block,
            node: n
          });
          this.cache.set(n);
        }));
        final.nodes = newNodes;
        return {
          ...final,
          distance
        };
      }
      async handlePrepend(entries, opts, nodeOptions, final, distance) {
        const {BranchClass: BranchClass2, LeafClass: LeafClass2} = opts;
        let newEntries = [];
        let prepend = null;
        for (const entry of entries) {
          if (prepend) {
            const mergeEntries = await this.mergeFirstLeftEntries(entry, prepend, nodeOptions, final, distance);
            prepend = null;
            const NodeClass = !mergeEntries[0].address ? LeafClass2 : BranchClass2;
            const _opts = {
              ...nodeOptions,
              entries: mergeEntries.sort(({key: a}, {key: b}) => opts.compare(a, b)),
              NodeClass,
              distance
            };
            const nodes = await Node.from(_opts);
            if (!nodes[nodes.length - 1].closed) {
              prepend = nodes.pop();
            }
            if (nodes.length) {
              newEntries = newEntries.concat(nodes);
            }
          } else {
            if (!entry.isEntry && !entry.closed) {
              prepend = entry;
            } else {
              newEntries.push(entry);
            }
          }
        }
        if (prepend) {
          newEntries.push(prepend);
        }
        return newEntries;
      }
      async getNodeFirstFromBlocks(blocks, addr) {
        for (const {block, node: node2} of blocks) {
          if (await block.cid === addr)
            return node2;
        }
        return await this.getNode(addr);
      }
      async mergeFirstLeftEntries(entry, prepend, nodeOptions, final, distance) {
        const opts = nodeOptions.opts;
        const {LeafClass: LeafClass2, BranchClass: BranchClass2, BranchEntryClass} = opts;
        if (entry.isEntry) {
          const addr = await entry.address;
          entry = await this.getNodeFirstFromBlocks(final.blocks, addr);
        }
        const es = entry.entryList.entries;
        if (!es.length)
          throw new Error("unreachable no entries");
        const basicMerge = (entries1, entries2) => {
          return entries1.concat(entries2);
        };
        const processNodesAndCreateEntries = async (nodes, final2, opts2) => {
          return await Promise.all(nodes.map(async (l) => {
            final2.blocks.push({
              block: await l.encode(),
              node: l
            });
            this.cache.set(l);
            return new BranchEntryClass({
              key: l.key,
              address: await l.address
            }, opts2);
          }));
        };
        if (es[0].constructor.name === prepend.entryList.entries[0].constructor.name) {
          return await basicMerge(prepend.entryList.entries, es);
        } else {
          const leftEntry = es.shift();
          if (!leftEntry)
            throw new Error("unreachable no left entry");
          if (!leftEntry.address)
            throw new Error("unreachable existing leaf, no leftEntry.address");
          const mergeLeftEntries = await this.mergeFirstLeftEntries(leftEntry, prepend, nodeOptions, final, distance - 1);
          const esf = es.shift();
          if (!esf) {
            return mergeLeftEntries;
          }
          if (!esf.address)
            throw new Error("unreachable existing leaf, no esf.address");
          const oldFront = await this.getNodeFirstFromBlocks(final.blocks, await esf.address);
          if (!oldFront.entryList.entries[0].address) {
            const leftLeafEntries = await basicMerge(mergeLeftEntries, oldFront.entryList.entries);
            const leftLeafNodes = await Node.from({
              ...nodeOptions,
              entries: leftLeafEntries.sort(({key: a}, {key: b}) => opts.compare(a, b)),
              NodeClass: LeafClass2,
              distance
            });
            const leftBranches = await processNodesAndCreateEntries(leftLeafNodes, final, opts);
            return await basicMerge(leftBranches, es);
          } else {
            if (mergeLeftEntries[0].address) {
              return mergeLeftEntries.concat(oldFront.entryList.entries);
            } else {
              const mergeLeftNodes = await Node.from({
                ...nodeOptions,
                entries: mergeLeftEntries.sort(({key: a}, {key: b}) => opts.compare(a, b)),
                NodeClass: LeafClass2,
                distance
              });
              const mergeLeftBranchEntries = await processNodesAndCreateEntries(mergeLeftNodes, final, opts);
              const newFirstNodes = await Node.from({
                ...nodeOptions,
                entries: [
                  ...oldFront.entryList.entries,
                  ...mergeLeftBranchEntries,
                  ...es
                ].sort(({key: a}, {key: b}) => opts.compare(a, b)),
                NodeClass: BranchClass2,
                distance
              });
              const newBranchEntries = await processNodesAndCreateEntries(newFirstNodes, final, opts);
              return newBranchEntries;
            }
          }
        }
      }
      async bulk(bulk, opts = {}, isRoot = true) {
        const {BranchClass: BranchClass2} = opts;
        opts = {
          codec: this.codec,
          hasher: this.hasher,
          getNode: this.getNode,
          compare: this.compare,
          cache: this.cache,
          ...opts
        };
        if (!opts.sorted) {
          bulk = sortBulk(bulk, opts);
          opts.sorted = true;
        }
        const nodeOptions = {
          chunker: this.chunker,
          opts
        };
        const results = await this.transaction(bulk, opts);
        while (results.nodes.length > 1) {
          const newDistance = results.nodes[0].distance + 1;
          const branchEntries = await Promise.all(results.nodes.map(async (node2) => {
            const block = await node2.encode();
            results.blocks.push({
              block,
              node: node2
            });
            this.cache.set(node2);
            return new opts.BranchEntryClass(node2, opts);
          }));
          const newNodes = await Node.from({
            ...nodeOptions,
            entries: branchEntries,
            NodeClass: BranchClass2,
            distance: newDistance
          });
          await Promise.all(newNodes.map(async (node2) => {
            const block = await node2.encode();
            this.cache.set(node2);
            results.blocks.push({
              block,
              node: node2
            });
          }));
          results.nodes = newNodes;
        }
        results.root = results.nodes[0];
        if (isRoot && results.root) {
          await processRoot(this, results, bulk, nodeOptions);
        }
        results.blocks = results.blocks.map(({block}) => block);
        return results;
      }
      static async from({entries, chunker: chunker2, NodeClass, distance, opts}) {
        if (!entries.every((entry) => entry.constructor.name === entries[0].constructor.name))
          throw new Error("all entries must be of the same type");
        const parts = [];
        let chunk = [];
        for (const entry of entries) {
          chunk.push(entry);
          if (await chunker2(entry, distance)) {
            parts.push(new EntryList({
              entries: chunk,
              closed: true
            }));
            chunk = [];
          }
        }
        if (chunk.length) {
          parts.push(new EntryList({
            entries: chunk,
            closed: false
          }));
        }
        return parts.map((entryList) => new NodeClass({
          entryList,
          chunker: chunker2,
          distance,
          ...opts
        }));
      }
    };
    var IPLDNode = class extends Node {
      constructor({codec: codec2, hasher: hasher2, block, ...opts}) {
        super(opts);
        this.codec = codec2;
        this.hasher = hasher2;
        if (!block) {
          this.block = this.encode();
          this.address = this.block.then((block2) => block2.cid);
        } else {
          this.block = block;
          this.address = block.cid;
        }
      }
      async get(key2) {
        const {
          result: entry,
          cids
        } = await this.getEntry(key2);
        return {
          result: entry.key,
          cids
        };
      }
      async encode() {
        if (this.block)
          return this.block;
        const value = await this.encodeNode();
        const opts = {
          codec: this.codec,
          hasher: this.hasher,
          value
        };
        this.block = await encode$5(opts);
        return this.block;
      }
    };
    var IPLDBranch = class extends IPLDNode {
      async encodeNode() {
        const {entries} = this.entryList;
        const mapper = async (entry) => {
          if (!entry.address)
            throw new Error("entry.address required");
          return [
            entry.key,
            await entry.address
          ];
        };
        const list = await Promise.all(entries.map(mapper));
        return {
          branch: [
            this.distance,
            list
          ],
          closed: this.closed
        };
      }
      get isBranch() {
        return true;
      }
    };
    var IPLDLeaf = class extends IPLDNode {
      async encodeNode() {
        const list = await Promise.all(this.entryList.entries.map(async (entry) => await entry.encodeNode()));
        return {
          leaf: list,
          closed: this.closed
        };
      }
      get isLeaf() {
        return true;
      }
    };
    var create$5 = async function* (obj) {
      let {LeafClass: LeafClass2, LeafEntryClass, BranchClass: BranchClass2, BranchEntryClass, list, chunker: chunker2, compare: compare2, ...opts} = obj;
      list = list.map((value) => new LeafEntryClass(value, opts));
      opts.compare = compare2;
      let nodes = await Node.from({
        entries: list,
        chunker: chunker2,
        NodeClass: LeafClass2,
        distance: 0,
        opts
      });
      yield* nodes;
      let distance = 1;
      while (nodes.length > 1) {
        const mapper = async (node2) => new BranchEntryClass({
          key: node2.key,
          address: await node2.address
        }, opts);
        const entries = await Promise.all(nodes.map(mapper));
        nodes = await Node.from({
          entries,
          chunker: chunker2,
          NodeClass: BranchClass2,
          distance,
          opts
        });
        yield* nodes;
        distance++;
      }
    };
    var MapEntry = class extends Entry {
      async identity() {
        const encoded = await this.codec.encode(await this.encodeNode());
        const hash2 = await this.hasher.encode(encoded);
        return readUInt32LE$1(hash2);
      }
    };
    var MapLeafEntry = class extends MapEntry {
      constructor(node2, opts) {
        super(node2, opts);
        this.value = node2.value;
      }
      encodeNode() {
        return [
          this.key,
          this.value
        ];
      }
    };
    var MapBranchEntry = class extends MapEntry {
      constructor(node2, opts) {
        if (!node2.address) {
          throw new Error("Cannot create MapBranchEntry without address");
        }
        super(node2, opts);
      }
      async encodeNode() {
        return [
          this.key,
          await this.address
        ];
      }
    };
    var getValue = async (node2, key2) => {
      const {
        result: entry,
        cids
      } = await node2.getEntry(key2);
      return {
        result: entry.value,
        cids
      };
    };
    var getManyValues = async (node2, keys2) => {
      const {
        result: entries,
        cids
      } = await node2.getEntries(keys2);
      return {
        result: entries.map((entry) => entry.value),
        cids
      };
    };
    var MapLeaf = class extends IPLDLeaf {
      get(key2) {
        return getValue(this, key2);
      }
      getMany(keys2) {
        return getManyValues(this, keys2);
      }
      bulk(bulk, opts = {}, isRoot = true) {
        return super.bulk(bulk, {
          ...classes$1,
          ...opts
        }, isRoot);
      }
    };
    var MapBranch = class extends IPLDBranch {
      get(key2) {
        return getValue(this, key2);
      }
      getMany(keys2) {
        return getManyValues(this, keys2);
      }
      bulk(bulk, opts = {}, isRoot = true) {
        return super.bulk(bulk, {
          ...classes$1,
          ...opts
        }, isRoot);
      }
    };
    var classes$1 = {
      LeafClass: MapLeaf,
      LeafEntryClass: MapLeafEntry,
      BranchClass: MapBranch,
      BranchEntryClass: MapBranchEntry
    };
    var createGetNode$1 = (get2, cache2, chunker2, codec2, hasher2, compare2, opts) => {
      const LeafClass2 = opts.LeafClass || MapLeaf;
      const LeafEntryClass = opts.LeafEntryClass || MapLeafEntry;
      const BranchClass2 = opts.BranchClass || MapBranch;
      const BranchEntryClass = opts.BranchEntryClass || MapBranchEntry;
      const getNode = async (cid) => {
        if (cache2.has(cid)) {
          return cache2.get(cid);
        }
        return get2(cid).then((block) => decoder(block));
      };
      const decoder = makeDecoder({
        chunker: chunker2,
        cache: cache2,
        getNode,
        codec: codec2,
        hasher: hasher2,
        compare: compare2,
        LeafEntryClass,
        LeafClass: LeafClass2,
        BranchEntryClass,
        BranchClass: BranchClass2
      });
      return getNode;
    };
    var create$4 = ({get: get2, cache: cache2, chunker: chunker2, list, codec: codec2, hasher: hasher2, sorted, compare: compare2, ...opts}) => {
      if (!sorted) {
        list = list.sort(({key: a}, {key: b}) => compare2(a, b));
      }
      const getNode = createGetNode$1(get2, cache2, chunker2, codec2, hasher2, compare2, opts);
      const _opts = {
        list,
        codec: codec2,
        hasher: hasher2,
        chunker: chunker2,
        getNode,
        sorted,
        compare: compare2,
        cache: cache2,
        LeafClass: opts.LeafClass || MapLeaf,
        LeafEntryClass: opts.LeafEntryClass || MapLeafEntry,
        BranchClass: opts.BranchClass || MapBranch,
        BranchEntryClass: opts.BranchEntryClass || MapBranchEntry
      };
      return create$5(_opts);
    };
    var load$4 = ({cid, get: get2, cache: cache2, chunker: chunker2, codec: codec2, hasher: hasher2, compare: compare2, ...opts}) => {
      const getNode = createGetNode$1(get2, cache2, chunker2, codec2, hasher2, compare2, opts);
      return getNode(cid);
    };
    function makeDecoder({chunker: chunker2, cache: cache2, getNode, codec: codec2, hasher: hasher2, compare: compare2, LeafEntryClass, LeafClass: LeafClass2, BranchEntryClass, BranchClass: BranchClass2}) {
      const entryOpts = {
        codec: codec2,
        hasher: hasher2
      };
      return (block) => {
        const {value} = block;
        const opts = {
          chunker: chunker2,
          cache: cache2,
          block,
          getNode,
          codec: codec2,
          hasher: hasher2,
          compare: compare2
        };
        let entries;
        let CLS;
        if (value.leaf) {
          entries = value.leaf.map(([key2, value2]) => new LeafEntryClass({
            key: key2,
            value: value2
          }, entryOpts));
          CLS = LeafClass2;
        } else if (value.branch) {
          const [distance, _entries] = value.branch;
          opts.distance = distance;
          entries = _entries.map(([key2, address]) => new BranchEntryClass({
            key: key2,
            address
          }, entryOpts));
          CLS = BranchClass2;
        } else {
          throw new Error("Unknown block data, does not match schema");
        }
        const entryList = new EntryList({
          entries,
          closed: value.closed
        });
        const node2 = new CLS({
          entryList,
          ...opts
        });
        cache2.set(node2);
        return node2;
      };
    }
    var nocache = {
      has: () => false,
      get: () => {
        throw new Error("Cannot ask for entries from nocache");
      },
      set: () => {
      }
    };
    var parse = (source, base2) => CID.parse(source, base2);
    var instanceOfAny = (object2, constructors) => constructors.some((c) => object2 instanceof c);
    var idbProxyableTypes;
    var cursorAdvanceMethods;
    function getIdbProxyableTypes() {
      return idbProxyableTypes || (idbProxyableTypes = [
        IDBDatabase,
        IDBObjectStore,
        IDBIndex,
        IDBCursor,
        IDBTransaction
      ]);
    }
    function getCursorAdvanceMethods() {
      return cursorAdvanceMethods || (cursorAdvanceMethods = [
        IDBCursor.prototype.advance,
        IDBCursor.prototype.continue,
        IDBCursor.prototype.continuePrimaryKey
      ]);
    }
    var cursorRequestMap = new WeakMap();
    var transactionDoneMap = new WeakMap();
    var transactionStoreNamesMap = new WeakMap();
    var transformCache = new WeakMap();
    var reverseTransformCache = new WeakMap();
    function promisifyRequest(request) {
      const promise2 = new Promise((resolve, reject) => {
        const unlisten = () => {
          request.removeEventListener("success", success);
          request.removeEventListener("error", error);
        };
        const success = () => {
          resolve(wrap(request.result));
          unlisten();
        };
        const error = () => {
          reject(request.error);
          unlisten();
        };
        request.addEventListener("success", success);
        request.addEventListener("error", error);
      });
      promise2.then((value) => {
        if (value instanceof IDBCursor) {
          cursorRequestMap.set(value, request);
        }
      }).catch(() => {
      });
      reverseTransformCache.set(promise2, request);
      return promise2;
    }
    function cacheDonePromiseForTransaction(tx) {
      if (transactionDoneMap.has(tx))
        return;
      const done2 = new Promise((resolve, reject) => {
        const unlisten = () => {
          tx.removeEventListener("complete", complete);
          tx.removeEventListener("error", error);
          tx.removeEventListener("abort", error);
        };
        const complete = () => {
          resolve();
          unlisten();
        };
        const error = () => {
          reject(tx.error || new DOMException("AbortError", "AbortError"));
          unlisten();
        };
        tx.addEventListener("complete", complete);
        tx.addEventListener("error", error);
        tx.addEventListener("abort", error);
      });
      transactionDoneMap.set(tx, done2);
    }
    var idbProxyTraps = {
      get(target, prop, receiver) {
        if (target instanceof IDBTransaction) {
          if (prop === "done")
            return transactionDoneMap.get(target);
          if (prop === "objectStoreNames") {
            return target.objectStoreNames || transactionStoreNamesMap.get(target);
          }
          if (prop === "store") {
            return receiver.objectStoreNames[1] ? void 0 : receiver.objectStore(receiver.objectStoreNames[0]);
          }
        }
        return wrap(target[prop]);
      },
      set(target, prop, value) {
        target[prop] = value;
        return true;
      },
      has(target, prop) {
        if (target instanceof IDBTransaction && (prop === "done" || prop === "store")) {
          return true;
        }
        return prop in target;
      }
    };
    function replaceTraps(callback) {
      idbProxyTraps = callback(idbProxyTraps);
    }
    function wrapFunction(func) {
      if (func === IDBDatabase.prototype.transaction && !("objectStoreNames" in IDBTransaction.prototype)) {
        return function(storeNames, ...args) {
          const tx = func.call(unwrap(this), storeNames, ...args);
          transactionStoreNamesMap.set(tx, storeNames.sort ? storeNames.sort() : [storeNames]);
          return wrap(tx);
        };
      }
      if (getCursorAdvanceMethods().includes(func)) {
        return function(...args) {
          func.apply(unwrap(this), args);
          return wrap(cursorRequestMap.get(this));
        };
      }
      return function(...args) {
        return wrap(func.apply(unwrap(this), args));
      };
    }
    function transformCachableValue(value) {
      if (typeof value === "function")
        return wrapFunction(value);
      if (value instanceof IDBTransaction)
        cacheDonePromiseForTransaction(value);
      if (instanceOfAny(value, getIdbProxyableTypes()))
        return new Proxy(value, idbProxyTraps);
      return value;
    }
    function wrap(value) {
      if (value instanceof IDBRequest)
        return promisifyRequest(value);
      if (transformCache.has(value))
        return transformCache.get(value);
      const newValue = transformCachableValue(value);
      if (newValue !== value) {
        transformCache.set(value, newValue);
        reverseTransformCache.set(newValue, value);
      }
      return newValue;
    }
    var unwrap = (value) => reverseTransformCache.get(value);
    function openDB(name2, version2, {blocked, upgrade, blocking, terminated} = {}) {
      const request = indexedDB.open(name2, version2);
      const openPromise = wrap(request);
      if (upgrade) {
        request.addEventListener("upgradeneeded", (event) => {
          upgrade(wrap(request.result), event.oldVersion, event.newVersion, wrap(request.transaction), event);
        });
      }
      if (blocked) {
        request.addEventListener("blocked", (event) => blocked(event.oldVersion, event.newVersion, event));
      }
      openPromise.then((db) => {
        if (terminated)
          db.addEventListener("close", () => terminated());
        if (blocking) {
          db.addEventListener("versionchange", (event) => blocking(event.oldVersion, event.newVersion, event));
        }
      }).catch(() => {
      });
      return openPromise;
    }
    var readMethods = ["get", "getKey", "getAll", "getAllKeys", "count"];
    var writeMethods = ["put", "add", "delete", "clear"];
    var cachedMethods = new Map();
    function getMethod(target, prop) {
      if (!(target instanceof IDBDatabase && !(prop in target) && typeof prop === "string")) {
        return;
      }
      if (cachedMethods.get(prop))
        return cachedMethods.get(prop);
      const targetFuncName = prop.replace(/FromIndex$/, "");
      const useIndex = prop !== targetFuncName;
      const isWrite = writeMethods.includes(targetFuncName);
      if (!(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) || !(isWrite || readMethods.includes(targetFuncName))) {
        return;
      }
      const method2 = async function(storeName, ...args) {
        const tx = this.transaction(storeName, isWrite ? "readwrite" : "readonly");
        let target2 = tx.store;
        if (useIndex)
          target2 = target2.index(args.shift());
        return (await Promise.all([
          target2[targetFuncName](...args),
          isWrite && tx.done
        ]))[0];
      };
      cachedMethods.set(prop, method2);
      return method2;
    }
    replaceTraps((oldTraps) => ({
      ...oldTraps,
      get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),
      has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop)
    }));
    var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
    function getDefaultExportFromCjs(x) {
      return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
    }
    function getAugmentedNamespace(n) {
      if (n.__esModule)
        return n;
      var f = n.default;
      if (typeof f == "function") {
        var a = function a2() {
          if (this instanceof a2) {
            var args = [null];
            args.push.apply(args, arguments);
            var Ctor = Function.bind.apply(f, args);
            return new Ctor();
          }
          return f.apply(this, arguments);
        };
        a.prototype = f.prototype;
      } else
        a = {};
      Object.defineProperty(a, "__esModule", {value: true});
      Object.keys(n).forEach(function(k) {
        var d = Object.getOwnPropertyDescriptor(n, k);
        Object.defineProperty(a, k, d.get ? d : {
          enumerable: true,
          get: function() {
            return n[k];
          }
        });
      });
      return a;
    }
    var encode_1 = encode$2;
    var MSB$1 = 128;
    var REST$1 = 127;
    var MSBALL = ~REST$1;
    var INT = Math.pow(2, 31);
    function encode$2(num, out, offset) {
      if (Number.MAX_SAFE_INTEGER && num > Number.MAX_SAFE_INTEGER) {
        encode$2.bytes = 0;
        throw new RangeError("Could not encode varint");
      }
      out = out || [];
      offset = offset || 0;
      var oldOffset = offset;
      while (num >= INT) {
        out[offset++] = num & 255 | MSB$1;
        num /= 128;
      }
      while (num & MSBALL) {
        out[offset++] = num & 255 | MSB$1;
        num >>>= 7;
      }
      out[offset] = num | 0;
      encode$2.bytes = offset - oldOffset + 1;
      return out;
    }
    var decode$2 = read$1;
    var MSB = 128;
    var REST = 127;
    function read$1(buf2, offset) {
      var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf2.length;
      do {
        if (counter >= l || shift > 49) {
          read$1.bytes = 0;
          throw new RangeError("Could not decode varint");
        }
        b = buf2[counter++];
        res += shift < 28 ? (b & REST) << shift : (b & REST) * Math.pow(2, shift);
        shift += 7;
      } while (b >= MSB);
      read$1.bytes = counter - offset;
      return res;
    }
    var N1 = Math.pow(2, 7);
    var N2 = Math.pow(2, 14);
    var N3 = Math.pow(2, 21);
    var N4 = Math.pow(2, 28);
    var N5 = Math.pow(2, 35);
    var N6 = Math.pow(2, 42);
    var N7 = Math.pow(2, 49);
    var N8 = Math.pow(2, 56);
    var N9 = Math.pow(2, 63);
    var length = function(value) {
      return value < N1 ? 1 : value < N2 ? 2 : value < N3 ? 3 : value < N4 ? 4 : value < N5 ? 5 : value < N6 ? 6 : value < N7 ? 7 : value < N8 ? 8 : value < N9 ? 9 : 10;
    };
    var varint = {
      encode: encode_1,
      decode: decode$2,
      encodingLength: length
    };
    var cborEncoders = makeCborEncoders();
    var defaultEncodeOptions = {
      float64: false,
      quickEncodeToken
    };
    function tokensToLength(tokens, encoders2 = cborEncoders, options = defaultEncodeOptions) {
      if (Array.isArray(tokens)) {
        let len = 0;
        for (const token of tokens) {
          len += tokensToLength(token, encoders2, options);
        }
        return len;
      } else {
        const encoder = encoders2[tokens.type.major];
        if (encoder.encodedSize === void 0 || typeof encoder.encodedSize !== "function") {
          throw new Error(`Encoder for ${tokens.type.name} does not have an encodedSize()`);
        }
        return encoder.encodedSize(tokens, options);
      }
    }
    var CarBufferWriter = class {
      constructor(bytes, headerSize) {
        this.bytes = bytes;
        this.byteOffset = headerSize;
        this.roots = [];
        this.headerSize = headerSize;
      }
      addRoot(root2, options) {
        addRoot(this, root2, options);
        return this;
      }
      write(block) {
        addBlock(this, block);
        return this;
      }
      close(options) {
        return close(this, options);
      }
    };
    var addRoot = (writer, root2, options = {}) => {
      const {resize = false} = options;
      const {bytes, headerSize, byteOffset, roots} = writer;
      writer.roots.push(root2);
      const size = headerLength(writer);
      if (size > headerSize) {
        if (size - headerSize + byteOffset < bytes.byteLength) {
          if (resize) {
            resizeHeader(writer, size);
          } else {
            roots.pop();
            throw new RangeError(`Header of size ${headerSize} has no capacity for new root ${root2}.
  However there is a space in the buffer and you could call addRoot(root, { resize: root }) to resize header to make a space for this root.`);
          }
        } else {
          roots.pop();
          throw new RangeError(`Buffer has no capacity for a new root ${root2}`);
        }
      }
    };
    var blockLength = ({cid, bytes}) => {
      const size = cid.bytes.byteLength + bytes.byteLength;
      return varint.encodingLength(size) + size;
    };
    var addBlock = (writer, {cid, bytes}) => {
      const byteLength2 = cid.bytes.byteLength + bytes.byteLength;
      const size = varint.encode(byteLength2);
      if (writer.byteOffset + size.length + byteLength2 > writer.bytes.byteLength) {
        throw new RangeError("Buffer has no capacity for this block");
      } else {
        writeBytes(writer, size);
        writeBytes(writer, cid.bytes);
        writeBytes(writer, bytes);
      }
    };
    var close = (writer, options = {}) => {
      const {resize = false} = options;
      const {roots, bytes, byteOffset, headerSize} = writer;
      const headerBytes = encode$3({version: 1, roots});
      const varintBytes = varint.encode(headerBytes.length);
      const size = varintBytes.length + headerBytes.byteLength;
      const offset = headerSize - size;
      if (offset === 0) {
        writeHeader(writer, varintBytes, headerBytes);
        return bytes.subarray(0, byteOffset);
      } else if (resize) {
        resizeHeader(writer, size);
        writeHeader(writer, varintBytes, headerBytes);
        return bytes.subarray(0, writer.byteOffset);
      } else {
        throw new RangeError(`Header size was overestimated.
You can use close({ resize: true }) to resize header`);
      }
    };
    var resizeHeader = (writer, byteLength2) => {
      const {bytes, headerSize} = writer;
      bytes.set(bytes.subarray(headerSize, writer.byteOffset), byteLength2);
      writer.byteOffset += byteLength2 - headerSize;
      writer.headerSize = byteLength2;
    };
    var writeBytes = (writer, bytes) => {
      writer.bytes.set(bytes, writer.byteOffset);
      writer.byteOffset += bytes.length;
    };
    var writeHeader = ({bytes}, varint2, header) => {
      bytes.set(varint2);
      bytes.set(header, varint2.length);
    };
    var headerPreludeTokens = [
      new Token(Type.map, 2),
      new Token(Type.string, "version"),
      new Token(Type.uint, 1),
      new Token(Type.string, "roots")
    ];
    var CID_TAG = new Token(Type.tag, 42);
    var calculateHeaderLength = (rootLengths) => {
      const tokens = [...headerPreludeTokens];
      tokens.push(new Token(Type.array, rootLengths.length));
      for (const rootLength of rootLengths) {
        tokens.push(CID_TAG);
        tokens.push(new Token(Type.bytes, {length: rootLength + 1}));
      }
      const length2 = tokensToLength(tokens);
      return varint.encodingLength(length2) + length2;
    };
    var headerLength = ({roots}) => calculateHeaderLength(roots.map((cid) => cid.bytes.byteLength));
    var createWriter = (buffer2, options = {}) => {
      const {
        roots = [],
        byteOffset = 0,
        byteLength: byteLength2 = buffer2.byteLength,
        headerSize = headerLength({roots})
      } = options;
      const bytes = new Uint8Array(buffer2, byteOffset, byteLength2);
      const writer = new CarBufferWriter(bytes, headerSize);
      for (const root2 of roots) {
        writer.addRoot(root2);
      }
      return writer;
    };
    var name$2 = "raw";
    var code$1 = 85;
    var encode$1 = (node2) => coerce(node2);
    var decode$1 = (data) => coerce(data);
    var raw = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      code: code$1,
      decode: decode$1,
      encode: encode$1,
      name: name$2
    });
    var browserExports$1 = {};
    var browser$d = {
      get exports() {
        return browserExports$1;
      },
      set exports(v2) {
        browserExports$1 = v2;
      }
    };
    var safeBufferExports = {};
    var safeBuffer = {
      get exports() {
        return safeBufferExports;
      },
      set exports(v2) {
        safeBufferExports = v2;
      }
    };
    var global$1 = typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {};
    var lookup = [];
    var revLookup = [];
    var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    var inited = false;
    function init() {
      inited = true;
      var code2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      for (var i = 0, len = code2.length; i < len; ++i) {
        lookup[i] = code2[i];
        revLookup[code2.charCodeAt(i)] = i;
      }
      revLookup["-".charCodeAt(0)] = 62;
      revLookup["_".charCodeAt(0)] = 63;
    }
    function toByteArray(b64) {
      if (!inited) {
        init();
      }
      var i, j, l, tmp, placeHolders, arr;
      var len = b64.length;
      if (len % 4 > 0) {
        throw new Error("Invalid string. Length must be a multiple of 4");
      }
      placeHolders = b64[len - 2] === "=" ? 2 : b64[len - 1] === "=" ? 1 : 0;
      arr = new Arr(len * 3 / 4 - placeHolders);
      l = placeHolders > 0 ? len - 4 : len;
      var L = 0;
      for (i = 0, j = 0; i < l; i += 4, j += 3) {
        tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
        arr[L++] = tmp >> 16 & 255;
        arr[L++] = tmp >> 8 & 255;
        arr[L++] = tmp & 255;
      }
      if (placeHolders === 2) {
        tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
        arr[L++] = tmp & 255;
      } else if (placeHolders === 1) {
        tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
        arr[L++] = tmp >> 8 & 255;
        arr[L++] = tmp & 255;
      }
      return arr;
    }
    function tripletToBase64(num) {
      return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
    }
    function encodeChunk(uint8, start, end) {
      var tmp;
      var output = [];
      for (var i = start; i < end; i += 3) {
        tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2];
        output.push(tripletToBase64(tmp));
      }
      return output.join("");
    }
    function fromByteArray(uint8) {
      if (!inited) {
        init();
      }
      var tmp;
      var len = uint8.length;
      var extraBytes = len % 3;
      var output = "";
      var parts = [];
      var maxChunkLength = 16383;
      for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
        parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
      }
      if (extraBytes === 1) {
        tmp = uint8[len - 1];
        output += lookup[tmp >> 2];
        output += lookup[tmp << 4 & 63];
        output += "==";
      } else if (extraBytes === 2) {
        tmp = (uint8[len - 2] << 8) + uint8[len - 1];
        output += lookup[tmp >> 10];
        output += lookup[tmp >> 4 & 63];
        output += lookup[tmp << 2 & 63];
        output += "=";
      }
      parts.push(output);
      return parts.join("");
    }
    function read(buffer2, offset, isLE, mLen, nBytes) {
      var e, m;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i = isLE ? nBytes - 1 : 0;
      var d = isLE ? -1 : 1;
      var s = buffer2[offset + i];
      i += d;
      e = s & (1 << -nBits) - 1;
      s >>= -nBits;
      nBits += eLen;
      for (; nBits > 0; e = e * 256 + buffer2[offset + i], i += d, nBits -= 8) {
      }
      m = e & (1 << -nBits) - 1;
      e >>= -nBits;
      nBits += mLen;
      for (; nBits > 0; m = m * 256 + buffer2[offset + i], i += d, nBits -= 8) {
      }
      if (e === 0) {
        e = 1 - eBias;
      } else if (e === eMax) {
        return m ? NaN : (s ? -1 : 1) * Infinity;
      } else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
      }
      return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
    }
    function write(buffer2, value, offset, isLE, mLen, nBytes) {
      var e, m, c;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
      var i = isLE ? 0 : nBytes - 1;
      var d = isLE ? 1 : -1;
      var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
      value = Math.abs(value);
      if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
      } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
          e--;
          c *= 2;
        }
        if (e + eBias >= 1) {
          value += rt / c;
        } else {
          value += rt * Math.pow(2, 1 - eBias);
        }
        if (value * c >= 2) {
          e++;
          c /= 2;
        }
        if (e + eBias >= eMax) {
          m = 0;
          e = eMax;
        } else if (e + eBias >= 1) {
          m = (value * c - 1) * Math.pow(2, mLen);
          e = e + eBias;
        } else {
          m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e = 0;
        }
      }
      for (; mLen >= 8; buffer2[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
      }
      e = e << mLen | m;
      eLen += mLen;
      for (; eLen > 0; buffer2[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
      }
      buffer2[offset + i - d] |= s * 128;
    }
    var toString = {}.toString;
    var isArray$1 = Array.isArray || function(arr) {
      return toString.call(arr) == "[object Array]";
    };
    /*!
     * The buffer module from node.js, for the browser.
     *
     * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
     * @license  MIT
     */
    var INSPECT_MAX_BYTES = 50;
    Buffer$3.TYPED_ARRAY_SUPPORT = global$1.TYPED_ARRAY_SUPPORT !== void 0 ? global$1.TYPED_ARRAY_SUPPORT : true;
    var _kMaxLength = kMaxLength();
    function kMaxLength() {
      return Buffer$3.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
    }
    function createBuffer(that, length2) {
      if (kMaxLength() < length2) {
        throw new RangeError("Invalid typed array length");
      }
      if (Buffer$3.TYPED_ARRAY_SUPPORT) {
        that = new Uint8Array(length2);
        that.__proto__ = Buffer$3.prototype;
      } else {
        if (that === null) {
          that = new Buffer$3(length2);
        }
        that.length = length2;
      }
      return that;
    }
    function Buffer$3(arg, encodingOrOffset, length2) {
      if (!Buffer$3.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer$3)) {
        return new Buffer$3(arg, encodingOrOffset, length2);
      }
      if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") {
          throw new Error("If encoding is specified then the first argument must be a string");
        }
        return allocUnsafe(this, arg);
      }
      return from(this, arg, encodingOrOffset, length2);
    }
    Buffer$3.poolSize = 8192;
    Buffer$3._augment = function(arr) {
      arr.__proto__ = Buffer$3.prototype;
      return arr;
    };
    function from(that, value, encodingOrOffset, length2) {
      if (typeof value === "number") {
        throw new TypeError('"value" argument must not be a number');
      }
      if (typeof ArrayBuffer !== "undefined" && value instanceof ArrayBuffer) {
        return fromArrayBuffer(that, value, encodingOrOffset, length2);
      }
      if (typeof value === "string") {
        return fromString(that, value, encodingOrOffset);
      }
      return fromObject(that, value);
    }
    Buffer$3.from = function(value, encodingOrOffset, length2) {
      return from(null, value, encodingOrOffset, length2);
    };
    if (Buffer$3.TYPED_ARRAY_SUPPORT) {
      Buffer$3.prototype.__proto__ = Uint8Array.prototype;
      Buffer$3.__proto__ = Uint8Array;
      if (typeof Symbol !== "undefined" && Symbol.species && Buffer$3[Symbol.species] === Buffer$3)
        ;
    }
    function assertSize(size) {
      if (typeof size !== "number") {
        throw new TypeError('"size" argument must be a number');
      } else if (size < 0) {
        throw new RangeError('"size" argument must not be negative');
      }
    }
    function alloc(that, size, fill, encoding) {
      assertSize(size);
      if (size <= 0) {
        return createBuffer(that, size);
      }
      if (fill !== void 0) {
        return typeof encoding === "string" ? createBuffer(that, size).fill(fill, encoding) : createBuffer(that, size).fill(fill);
      }
      return createBuffer(that, size);
    }
    Buffer$3.alloc = function(size, fill, encoding) {
      return alloc(null, size, fill, encoding);
    };
    function allocUnsafe(that, size) {
      assertSize(size);
      that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
      if (!Buffer$3.TYPED_ARRAY_SUPPORT) {
        for (var i = 0; i < size; ++i) {
          that[i] = 0;
        }
      }
      return that;
    }
    Buffer$3.allocUnsafe = function(size) {
      return allocUnsafe(null, size);
    };
    Buffer$3.allocUnsafeSlow = function(size) {
      return allocUnsafe(null, size);
    };
    function fromString(that, string, encoding) {
      if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
      }
      if (!Buffer$3.isEncoding(encoding)) {
        throw new TypeError('"encoding" must be a valid string encoding');
      }
      var length2 = byteLength(string, encoding) | 0;
      that = createBuffer(that, length2);
      var actual = that.write(string, encoding);
      if (actual !== length2) {
        that = that.slice(0, actual);
      }
      return that;
    }
    function fromArrayLike(that, array) {
      var length2 = array.length < 0 ? 0 : checked(array.length) | 0;
      that = createBuffer(that, length2);
      for (var i = 0; i < length2; i += 1) {
        that[i] = array[i] & 255;
      }
      return that;
    }
    function fromArrayBuffer(that, array, byteOffset, length2) {
      array.byteLength;
      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError("'offset' is out of bounds");
      }
      if (array.byteLength < byteOffset + (length2 || 0)) {
        throw new RangeError("'length' is out of bounds");
      }
      if (byteOffset === void 0 && length2 === void 0) {
        array = new Uint8Array(array);
      } else if (length2 === void 0) {
        array = new Uint8Array(array, byteOffset);
      } else {
        array = new Uint8Array(array, byteOffset, length2);
      }
      if (Buffer$3.TYPED_ARRAY_SUPPORT) {
        that = array;
        that.__proto__ = Buffer$3.prototype;
      } else {
        that = fromArrayLike(that, array);
      }
      return that;
    }
    function fromObject(that, obj) {
      if (internalIsBuffer(obj)) {
        var len = checked(obj.length) | 0;
        that = createBuffer(that, len);
        if (that.length === 0) {
          return that;
        }
        obj.copy(that, 0, 0, len);
        return that;
      }
      if (obj) {
        if (typeof ArrayBuffer !== "undefined" && obj.buffer instanceof ArrayBuffer || "length" in obj) {
          if (typeof obj.length !== "number" || isnan(obj.length)) {
            return createBuffer(that, 0);
          }
          return fromArrayLike(that, obj);
        }
        if (obj.type === "Buffer" && isArray$1(obj.data)) {
          return fromArrayLike(that, obj.data);
        }
      }
      throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
    }
    function checked(length2) {
      if (length2 >= kMaxLength()) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + kMaxLength().toString(16) + " bytes");
      }
      return length2 | 0;
    }
    function SlowBuffer(length2) {
      if (+length2 != length2) {
        length2 = 0;
      }
      return Buffer$3.alloc(+length2);
    }
    Buffer$3.isBuffer = isBuffer$1;
    function internalIsBuffer(b) {
      return !!(b != null && b._isBuffer);
    }
    Buffer$3.compare = function compare2(a, b) {
      if (!internalIsBuffer(a) || !internalIsBuffer(b)) {
        throw new TypeError("Arguments must be Buffers");
      }
      if (a === b)
        return 0;
      var x = a.length;
      var y = b.length;
      for (var i = 0, len = Math.min(x, y); i < len; ++i) {
        if (a[i] !== b[i]) {
          x = a[i];
          y = b[i];
          break;
        }
      }
      if (x < y)
        return -1;
      if (y < x)
        return 1;
      return 0;
    };
    Buffer$3.isEncoding = function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    Buffer$3.concat = function concat2(list, length2) {
      if (!isArray$1(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list.length === 0) {
        return Buffer$3.alloc(0);
      }
      var i;
      if (length2 === void 0) {
        length2 = 0;
        for (i = 0; i < list.length; ++i) {
          length2 += list[i].length;
        }
      }
      var buffer2 = Buffer$3.allocUnsafe(length2);
      var pos = 0;
      for (i = 0; i < list.length; ++i) {
        var buf2 = list[i];
        if (!internalIsBuffer(buf2)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        }
        buf2.copy(buffer2, pos);
        pos += buf2.length;
      }
      return buffer2;
    };
    function byteLength(string, encoding) {
      if (internalIsBuffer(string)) {
        return string.length;
      }
      if (typeof ArrayBuffer !== "undefined" && typeof ArrayBuffer.isView === "function" && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
        return string.byteLength;
      }
      if (typeof string !== "string") {
        string = "" + string;
      }
      var len = string.length;
      if (len === 0)
        return 0;
      var loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "ascii":
          case "latin1":
          case "binary":
            return len;
          case "utf8":
          case "utf-8":
          case void 0:
            return utf8ToBytes(string).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return len * 2;
          case "hex":
            return len >>> 1;
          case "base64":
            return base64ToBytes(string).length;
          default:
            if (loweredCase)
              return utf8ToBytes(string).length;
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer$3.byteLength = byteLength;
    function slowToString(encoding, start, end) {
      var loweredCase = false;
      if (start === void 0 || start < 0) {
        start = 0;
      }
      if (start > this.length) {
        return "";
      }
      if (end === void 0 || end > this.length) {
        end = this.length;
      }
      if (end <= 0) {
        return "";
      }
      end >>>= 0;
      start >>>= 0;
      if (end <= start) {
        return "";
      }
      if (!encoding)
        encoding = "utf8";
      while (true) {
        switch (encoding) {
          case "hex":
            return hexSlice(this, start, end);
          case "utf8":
          case "utf-8":
            return utf8Slice(this, start, end);
          case "ascii":
            return asciiSlice(this, start, end);
          case "latin1":
          case "binary":
            return latin1Slice(this, start, end);
          case "base64":
            return base64Slice(this, start, end);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return utf16leSlice(this, start, end);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer$3.prototype._isBuffer = true;
    function swap(b, n, m) {
      var i = b[n];
      b[n] = b[m];
      b[m] = i;
    }
    Buffer$3.prototype.swap16 = function swap16() {
      var len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (var i = 0; i < len; i += 2) {
        swap(this, i, i + 1);
      }
      return this;
    };
    Buffer$3.prototype.swap32 = function swap32() {
      var len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (var i = 0; i < len; i += 4) {
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
      }
      return this;
    };
    Buffer$3.prototype.swap64 = function swap64() {
      var len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (var i = 0; i < len; i += 8) {
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
      }
      return this;
    };
    Buffer$3.prototype.toString = function toString2() {
      var length2 = this.length | 0;
      if (length2 === 0)
        return "";
      if (arguments.length === 0)
        return utf8Slice(this, 0, length2);
      return slowToString.apply(this, arguments);
    };
    Buffer$3.prototype.equals = function equals2(b) {
      if (!internalIsBuffer(b))
        throw new TypeError("Argument must be a Buffer");
      if (this === b)
        return true;
      return Buffer$3.compare(this, b) === 0;
    };
    Buffer$3.prototype.inspect = function inspect2() {
      var str = "";
      var max = INSPECT_MAX_BYTES;
      if (this.length > 0) {
        str = this.toString("hex", 0, max).match(/.{2}/g).join(" ");
        if (this.length > max)
          str += " ... ";
      }
      return "<Buffer " + str + ">";
    };
    Buffer$3.prototype.compare = function compare2(target, start, end, thisStart, thisEnd) {
      if (!internalIsBuffer(target)) {
        throw new TypeError("Argument must be a Buffer");
      }
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = target ? target.length : 0;
      }
      if (thisStart === void 0) {
        thisStart = 0;
      }
      if (thisEnd === void 0) {
        thisEnd = this.length;
      }
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError("out of range index");
      }
      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start >= end) {
        return 1;
      }
      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target)
        return 0;
      var x = thisEnd - thisStart;
      var y = end - start;
      var len = Math.min(x, y);
      var thisCopy = this.slice(thisStart, thisEnd);
      var targetCopy = target.slice(start, end);
      for (var i = 0; i < len; ++i) {
        if (thisCopy[i] !== targetCopy[i]) {
          x = thisCopy[i];
          y = targetCopy[i];
          break;
        }
      }
      if (x < y)
        return -1;
      if (y < x)
        return 1;
      return 0;
    };
    function bidirectionalIndexOf(buffer2, val, byteOffset, encoding, dir) {
      if (buffer2.length === 0)
        return -1;
      if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 2147483647) {
        byteOffset = 2147483647;
      } else if (byteOffset < -2147483648) {
        byteOffset = -2147483648;
      }
      byteOffset = +byteOffset;
      if (isNaN(byteOffset)) {
        byteOffset = dir ? 0 : buffer2.length - 1;
      }
      if (byteOffset < 0)
        byteOffset = buffer2.length + byteOffset;
      if (byteOffset >= buffer2.length) {
        if (dir)
          return -1;
        else
          byteOffset = buffer2.length - 1;
      } else if (byteOffset < 0) {
        if (dir)
          byteOffset = 0;
        else
          return -1;
      }
      if (typeof val === "string") {
        val = Buffer$3.from(val, encoding);
      }
      if (internalIsBuffer(val)) {
        if (val.length === 0) {
          return -1;
        }
        return arrayIndexOf(buffer2, val, byteOffset, encoding, dir);
      } else if (typeof val === "number") {
        val = val & 255;
        if (Buffer$3.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === "function") {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer2, val, byteOffset);
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer2, val, byteOffset);
          }
        }
        return arrayIndexOf(buffer2, [val], byteOffset, encoding, dir);
      }
      throw new TypeError("val must be string, number or Buffer");
    }
    function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
      var indexSize = 1;
      var arrLength = arr.length;
      var valLength = val.length;
      if (encoding !== void 0) {
        encoding = String(encoding).toLowerCase();
        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
          if (arr.length < 2 || val.length < 2) {
            return -1;
          }
          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }
      function read2(buf2, i2) {
        if (indexSize === 1) {
          return buf2[i2];
        } else {
          return buf2.readUInt16BE(i2 * indexSize);
        }
      }
      var i;
      if (dir) {
        var foundIndex = -1;
        for (i = byteOffset; i < arrLength; i++) {
          if (read2(arr, i) === read2(val, foundIndex === -1 ? 0 : i - foundIndex)) {
            if (foundIndex === -1)
              foundIndex = i;
            if (i - foundIndex + 1 === valLength)
              return foundIndex * indexSize;
          } else {
            if (foundIndex !== -1)
              i -= i - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength)
          byteOffset = arrLength - valLength;
        for (i = byteOffset; i >= 0; i--) {
          var found = true;
          for (var j = 0; j < valLength; j++) {
            if (read2(arr, i + j) !== read2(val, j)) {
              found = false;
              break;
            }
          }
          if (found)
            return i;
        }
      }
      return -1;
    }
    Buffer$3.prototype.includes = function includes2(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    };
    Buffer$3.prototype.indexOf = function indexOf2(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
    };
    Buffer$3.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
    };
    function hexWrite(buf2, string, offset, length2) {
      offset = Number(offset) || 0;
      var remaining = buf2.length - offset;
      if (!length2) {
        length2 = remaining;
      } else {
        length2 = Number(length2);
        if (length2 > remaining) {
          length2 = remaining;
        }
      }
      var strLen = string.length;
      if (strLen % 2 !== 0)
        throw new TypeError("Invalid hex string");
      if (length2 > strLen / 2) {
        length2 = strLen / 2;
      }
      for (var i = 0; i < length2; ++i) {
        var parsed = parseInt(string.substr(i * 2, 2), 16);
        if (isNaN(parsed))
          return i;
        buf2[offset + i] = parsed;
      }
      return i;
    }
    function utf8Write(buf2, string, offset, length2) {
      return blitBuffer(utf8ToBytes(string, buf2.length - offset), buf2, offset, length2);
    }
    function asciiWrite(buf2, string, offset, length2) {
      return blitBuffer(asciiToBytes(string), buf2, offset, length2);
    }
    function latin1Write(buf2, string, offset, length2) {
      return asciiWrite(buf2, string, offset, length2);
    }
    function base64Write(buf2, string, offset, length2) {
      return blitBuffer(base64ToBytes(string), buf2, offset, length2);
    }
    function ucs2Write(buf2, string, offset, length2) {
      return blitBuffer(utf16leToBytes(string, buf2.length - offset), buf2, offset, length2);
    }
    Buffer$3.prototype.write = function write2(string, offset, length2, encoding) {
      if (offset === void 0) {
        encoding = "utf8";
        length2 = this.length;
        offset = 0;
      } else if (length2 === void 0 && typeof offset === "string") {
        encoding = offset;
        length2 = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset | 0;
        if (isFinite(length2)) {
          length2 = length2 | 0;
          if (encoding === void 0)
            encoding = "utf8";
        } else {
          encoding = length2;
          length2 = void 0;
        }
      } else {
        throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
      }
      var remaining = this.length - offset;
      if (length2 === void 0 || length2 > remaining)
        length2 = remaining;
      if (string.length > 0 && (length2 < 0 || offset < 0) || offset > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding)
        encoding = "utf8";
      var loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "hex":
            return hexWrite(this, string, offset, length2);
          case "utf8":
          case "utf-8":
            return utf8Write(this, string, offset, length2);
          case "ascii":
            return asciiWrite(this, string, offset, length2);
          case "latin1":
          case "binary":
            return latin1Write(this, string, offset, length2);
          case "base64":
            return base64Write(this, string, offset, length2);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write(this, string, offset, length2);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };
    Buffer$3.prototype.toJSON = function toJSON() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    function base64Slice(buf2, start, end) {
      if (start === 0 && end === buf2.length) {
        return fromByteArray(buf2);
      } else {
        return fromByteArray(buf2.slice(start, end));
      }
    }
    function utf8Slice(buf2, start, end) {
      end = Math.min(buf2.length, end);
      var res = [];
      var i = start;
      while (i < end) {
        var firstByte = buf2[i];
        var codePoint = null;
        var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i + bytesPerSequence <= end) {
          var secondByte, thirdByte, fourthByte, tempCodePoint;
          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 128) {
                codePoint = firstByte;
              }
              break;
            case 2:
              secondByte = buf2[i + 1];
              if ((secondByte & 192) === 128) {
                tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                if (tempCodePoint > 127) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 3:
              secondByte = buf2[i + 1];
              thirdByte = buf2[i + 2];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 4:
              secondByte = buf2[i + 1];
              thirdByte = buf2[i + 2];
              fourthByte = buf2[i + 3];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }
        if (codePoint === null) {
          codePoint = 65533;
          bytesPerSequence = 1;
        } else if (codePoint > 65535) {
          codePoint -= 65536;
          res.push(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i += bytesPerSequence;
      }
      return decodeCodePointsArray(res);
    }
    var MAX_ARGUMENTS_LENGTH = 4096;
    function decodeCodePointsArray(codePoints) {
      var len = codePoints.length;
      if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints);
      }
      var res = "";
      var i = 0;
      while (i < len) {
        res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
      }
      return res;
    }
    function asciiSlice(buf2, start, end) {
      var ret = "";
      end = Math.min(buf2.length, end);
      for (var i = start; i < end; ++i) {
        ret += String.fromCharCode(buf2[i] & 127);
      }
      return ret;
    }
    function latin1Slice(buf2, start, end) {
      var ret = "";
      end = Math.min(buf2.length, end);
      for (var i = start; i < end; ++i) {
        ret += String.fromCharCode(buf2[i]);
      }
      return ret;
    }
    function hexSlice(buf2, start, end) {
      var len = buf2.length;
      if (!start || start < 0)
        start = 0;
      if (!end || end < 0 || end > len)
        end = len;
      var out = "";
      for (var i = start; i < end; ++i) {
        out += toHex(buf2[i]);
      }
      return out;
    }
    function utf16leSlice(buf2, start, end) {
      var bytes = buf2.slice(start, end);
      var res = "";
      for (var i = 0; i < bytes.length; i += 2) {
        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
      }
      return res;
    }
    Buffer$3.prototype.slice = function slice2(start, end) {
      var len = this.length;
      start = ~~start;
      end = end === void 0 ? len : ~~end;
      if (start < 0) {
        start += len;
        if (start < 0)
          start = 0;
      } else if (start > len) {
        start = len;
      }
      if (end < 0) {
        end += len;
        if (end < 0)
          end = 0;
      } else if (end > len) {
        end = len;
      }
      if (end < start)
        end = start;
      var newBuf;
      if (Buffer$3.TYPED_ARRAY_SUPPORT) {
        newBuf = this.subarray(start, end);
        newBuf.__proto__ = Buffer$3.prototype;
      } else {
        var sliceLen = end - start;
        newBuf = new Buffer$3(sliceLen, void 0);
        for (var i = 0; i < sliceLen; ++i) {
          newBuf[i] = this[i + start];
        }
      }
      return newBuf;
    };
    function checkOffset(offset, ext, length2) {
      if (offset % 1 !== 0 || offset < 0)
        throw new RangeError("offset is not uint");
      if (offset + ext > length2)
        throw new RangeError("Trying to access beyond buffer length");
    }
    Buffer$3.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
      offset = offset | 0;
      byteLength2 = byteLength2 | 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      var val = this[offset];
      var mul = 1;
      var i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      return val;
    };
    Buffer$3.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
      offset = offset | 0;
      byteLength2 = byteLength2 | 0;
      if (!noAssert) {
        checkOffset(offset, byteLength2, this.length);
      }
      var val = this[offset + --byteLength2];
      var mul = 1;
      while (byteLength2 > 0 && (mul *= 256)) {
        val += this[offset + --byteLength2] * mul;
      }
      return val;
    };
    Buffer$3.prototype.readUInt8 = function readUInt8(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      return this[offset];
    };
    Buffer$3.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    };
    Buffer$3.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    };
    Buffer$3.prototype.readUInt32LE = function readUInt32LE2(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
    };
    Buffer$3.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    };
    Buffer$3.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
      offset = offset | 0;
      byteLength2 = byteLength2 | 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      var val = this[offset];
      var mul = 1;
      var i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer$3.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
      offset = offset | 0;
      byteLength2 = byteLength2 | 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      var i = byteLength2;
      var mul = 1;
      var val = this[offset + --i];
      while (i > 0 && (mul *= 256)) {
        val += this[offset + --i] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer$3.prototype.readInt8 = function readInt8(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      if (!(this[offset] & 128))
        return this[offset];
      return (255 - this[offset] + 1) * -1;
    };
    Buffer$3.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      var val = this[offset] | this[offset + 1] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer$3.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      var val = this[offset + 1] | this[offset] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer$3.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    };
    Buffer$3.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    };
    Buffer$3.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return read(this, offset, true, 23, 4);
    };
    Buffer$3.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return read(this, offset, false, 23, 4);
    };
    Buffer$3.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return read(this, offset, true, 52, 8);
    };
    Buffer$3.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return read(this, offset, false, 52, 8);
    };
    function checkInt(buf2, value, offset, ext, max, min) {
      if (!internalIsBuffer(buf2))
        throw new TypeError('"buffer" argument must be a Buffer instance');
      if (value > max || value < min)
        throw new RangeError('"value" argument is out of bounds');
      if (offset + ext > buf2.length)
        throw new RangeError("Index out of range");
    }
    Buffer$3.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset | 0;
      byteLength2 = byteLength2 | 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      var mul = 1;
      var i = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer$3.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset | 0;
      byteLength2 = byteLength2 | 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      var i = byteLength2 - 1;
      var mul = 1;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer$3.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 255, 0);
      if (!Buffer$3.TYPED_ARRAY_SUPPORT)
        value = Math.floor(value);
      this[offset] = value & 255;
      return offset + 1;
    };
    function objectWriteUInt16(buf2, value, offset, littleEndian) {
      if (value < 0)
        value = 65535 + value + 1;
      for (var i = 0, j = Math.min(buf2.length - offset, 2); i < j; ++i) {
        buf2[offset + i] = (value & 255 << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;
      }
    }
    Buffer$3.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      if (Buffer$3.TYPED_ARRAY_SUPPORT) {
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
      } else {
        objectWriteUInt16(this, value, offset, true);
      }
      return offset + 2;
    };
    Buffer$3.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      if (Buffer$3.TYPED_ARRAY_SUPPORT) {
        this[offset] = value >>> 8;
        this[offset + 1] = value & 255;
      } else {
        objectWriteUInt16(this, value, offset, false);
      }
      return offset + 2;
    };
    function objectWriteUInt32(buf2, value, offset, littleEndian) {
      if (value < 0)
        value = 4294967295 + value + 1;
      for (var i = 0, j = Math.min(buf2.length - offset, 4); i < j; ++i) {
        buf2[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 255;
      }
    }
    Buffer$3.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      if (Buffer$3.TYPED_ARRAY_SUPPORT) {
        this[offset + 3] = value >>> 24;
        this[offset + 2] = value >>> 16;
        this[offset + 1] = value >>> 8;
        this[offset] = value & 255;
      } else {
        objectWriteUInt32(this, value, offset, true);
      }
      return offset + 4;
    };
    Buffer$3.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      if (Buffer$3.TYPED_ARRAY_SUPPORT) {
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 255;
      } else {
        objectWriteUInt32(this, value, offset, false);
      }
      return offset + 4;
    };
    Buffer$3.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      var i = 0;
      var mul = 1;
      var sub = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer$3.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      var i = byteLength2 - 1;
      var mul = 1;
      var sub = 0;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer$3.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 127, -128);
      if (!Buffer$3.TYPED_ARRAY_SUPPORT)
        value = Math.floor(value);
      if (value < 0)
        value = 255 + value + 1;
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer$3.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      if (Buffer$3.TYPED_ARRAY_SUPPORT) {
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
      } else {
        objectWriteUInt16(this, value, offset, true);
      }
      return offset + 2;
    };
    Buffer$3.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      if (Buffer$3.TYPED_ARRAY_SUPPORT) {
        this[offset] = value >>> 8;
        this[offset + 1] = value & 255;
      } else {
        objectWriteUInt16(this, value, offset, false);
      }
      return offset + 2;
    };
    Buffer$3.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      if (Buffer$3.TYPED_ARRAY_SUPPORT) {
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        this[offset + 2] = value >>> 16;
        this[offset + 3] = value >>> 24;
      } else {
        objectWriteUInt32(this, value, offset, true);
      }
      return offset + 4;
    };
    Buffer$3.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      if (value < 0)
        value = 4294967295 + value + 1;
      if (Buffer$3.TYPED_ARRAY_SUPPORT) {
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 255;
      } else {
        objectWriteUInt32(this, value, offset, false);
      }
      return offset + 4;
    };
    function checkIEEE754(buf2, value, offset, ext, max, min) {
      if (offset + ext > buf2.length)
        throw new RangeError("Index out of range");
      if (offset < 0)
        throw new RangeError("Index out of range");
    }
    function writeFloat(buf2, value, offset, littleEndian, noAssert) {
      if (!noAssert) {
        checkIEEE754(buf2, value, offset, 4);
      }
      write(buf2, value, offset, littleEndian, 23, 4);
      return offset + 4;
    }
    Buffer$3.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert);
    };
    Buffer$3.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert);
    };
    function writeDouble(buf2, value, offset, littleEndian, noAssert) {
      if (!noAssert) {
        checkIEEE754(buf2, value, offset, 8);
      }
      write(buf2, value, offset, littleEndian, 52, 8);
      return offset + 8;
    }
    Buffer$3.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert);
    };
    Buffer$3.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert);
    };
    Buffer$3.prototype.copy = function copy(target, targetStart, start, end) {
      if (!start)
        start = 0;
      if (!end && end !== 0)
        end = this.length;
      if (targetStart >= target.length)
        targetStart = target.length;
      if (!targetStart)
        targetStart = 0;
      if (end > 0 && end < start)
        end = start;
      if (end === start)
        return 0;
      if (target.length === 0 || this.length === 0)
        return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length)
        throw new RangeError("sourceStart out of bounds");
      if (end < 0)
        throw new RangeError("sourceEnd out of bounds");
      if (end > this.length)
        end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      var len = end - start;
      var i;
      if (this === target && start < targetStart && targetStart < end) {
        for (i = len - 1; i >= 0; --i) {
          target[i + targetStart] = this[i + start];
        }
      } else if (len < 1e3 || !Buffer$3.TYPED_ARRAY_SUPPORT) {
        for (i = 0; i < len; ++i) {
          target[i + targetStart] = this[i + start];
        }
      } else {
        Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart);
      }
      return len;
    };
    Buffer$3.prototype.fill = function fill(val, start, end, encoding) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          encoding = end;
          end = this.length;
        }
        if (val.length === 1) {
          var code2 = val.charCodeAt(0);
          if (code2 < 256) {
            val = code2;
          }
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer$3.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
      } else if (typeof val === "number") {
        val = val & 255;
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val)
        val = 0;
      var i;
      if (typeof val === "number") {
        for (i = start; i < end; ++i) {
          this[i] = val;
        }
      } else {
        var bytes = internalIsBuffer(val) ? val : utf8ToBytes(new Buffer$3(val, encoding).toString());
        var len = bytes.length;
        for (i = 0; i < end - start; ++i) {
          this[i + start] = bytes[i % len];
        }
      }
      return this;
    };
    var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;
    function base64clean(str) {
      str = stringtrim(str).replace(INVALID_BASE64_RE, "");
      if (str.length < 2)
        return "";
      while (str.length % 4 !== 0) {
        str = str + "=";
      }
      return str;
    }
    function stringtrim(str) {
      if (str.trim)
        return str.trim();
      return str.replace(/^\s+|\s+$/g, "");
    }
    function toHex(n) {
      if (n < 16)
        return "0" + n.toString(16);
      return n.toString(16);
    }
    function utf8ToBytes(string, units) {
      units = units || Infinity;
      var codePoint;
      var length2 = string.length;
      var leadSurrogate = null;
      var bytes = [];
      for (var i = 0; i < length2; ++i) {
        codePoint = string.charCodeAt(i);
        if (codePoint > 55295 && codePoint < 57344) {
          if (!leadSurrogate) {
            if (codePoint > 56319) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            } else if (i + 1 === length2) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            }
            leadSurrogate = codePoint;
            continue;
          }
          if (codePoint < 56320) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            leadSurrogate = codePoint;
            continue;
          }
          codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
        }
        leadSurrogate = null;
        if (codePoint < 128) {
          if ((units -= 1) < 0)
            break;
          bytes.push(codePoint);
        } else if (codePoint < 2048) {
          if ((units -= 2) < 0)
            break;
          bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
        } else if (codePoint < 65536) {
          if ((units -= 3) < 0)
            break;
          bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
        } else if (codePoint < 1114112) {
          if ((units -= 4) < 0)
            break;
          bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
        } else {
          throw new Error("Invalid code point");
        }
      }
      return bytes;
    }
    function asciiToBytes(str) {
      var byteArray = [];
      for (var i = 0; i < str.length; ++i) {
        byteArray.push(str.charCodeAt(i) & 255);
      }
      return byteArray;
    }
    function utf16leToBytes(str, units) {
      var c, hi, lo;
      var byteArray = [];
      for (var i = 0; i < str.length; ++i) {
        if ((units -= 2) < 0)
          break;
        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
      }
      return byteArray;
    }
    function base64ToBytes(str) {
      return toByteArray(base64clean(str));
    }
    function blitBuffer(src2, dst, offset, length2) {
      for (var i = 0; i < length2; ++i) {
        if (i + offset >= dst.length || i >= src2.length)
          break;
        dst[i + offset] = src2[i];
      }
      return i;
    }
    function isnan(val) {
      return val !== val;
    }
    function isBuffer$1(obj) {
      return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj));
    }
    function isFastBuffer(obj) {
      return !!obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
    }
    function isSlowBuffer(obj) {
      return typeof obj.readFloatLE === "function" && typeof obj.slice === "function" && isFastBuffer(obj.slice(0, 0));
    }
    var _polyfillNode_buffer = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      Buffer: Buffer$3,
      INSPECT_MAX_BYTES,
      SlowBuffer,
      isBuffer: isBuffer$1,
      kMaxLength: _kMaxLength
    });
    var require$$6$1 = /* @__PURE__ */ getAugmentedNamespace(_polyfillNode_buffer);
    /*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
    (function(module2, exports2) {
      var buffer2 = require$$6$1;
      var Buffer2 = buffer2.Buffer;
      function copyProps(src2, dst) {
        for (var key2 in src2) {
          dst[key2] = src2[key2];
        }
      }
      if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
        module2.exports = buffer2;
      } else {
        copyProps(buffer2, exports2);
        exports2.Buffer = SafeBuffer;
      }
      function SafeBuffer(arg, encodingOrOffset, length2) {
        return Buffer2(arg, encodingOrOffset, length2);
      }
      SafeBuffer.prototype = Object.create(Buffer2.prototype);
      copyProps(Buffer2, SafeBuffer);
      SafeBuffer.from = function(arg, encodingOrOffset, length2) {
        if (typeof arg === "number") {
          throw new TypeError("Argument must not be a number");
        }
        return Buffer2(arg, encodingOrOffset, length2);
      };
      SafeBuffer.alloc = function(size, fill, encoding) {
        if (typeof size !== "number") {
          throw new TypeError("Argument must be a number");
        }
        var buf2 = Buffer2(size);
        if (fill !== void 0) {
          if (typeof encoding === "string") {
            buf2.fill(fill, encoding);
          } else {
            buf2.fill(fill);
          }
        } else {
          buf2.fill(0);
        }
        return buf2;
      };
      SafeBuffer.allocUnsafe = function(size) {
        if (typeof size !== "number") {
          throw new TypeError("Argument must be a number");
        }
        return Buffer2(size);
      };
      SafeBuffer.allocUnsafeSlow = function(size) {
        if (typeof size !== "number") {
          throw new TypeError("Argument must be a number");
        }
        return buffer2.SlowBuffer(size);
      };
    })(safeBuffer, safeBufferExports);
    var MAX_BYTES = 65536;
    var MAX_UINT32 = 4294967295;
    function oldBrowser() {
      throw new Error("Secure random number generation is not supported by this browser.\nUse Chrome, Firefox or Internet Explorer 11");
    }
    var Buffer$2 = safeBufferExports.Buffer;
    var crypto$2 = commonjsGlobal.crypto || commonjsGlobal.msCrypto;
    if (crypto$2 && crypto$2.getRandomValues) {
      browser$d.exports = randomBytes;
    } else {
      browser$d.exports = oldBrowser;
    }
    function randomBytes(size, cb) {
      if (size > MAX_UINT32)
        throw new RangeError("requested too many random bytes");
      var bytes = Buffer$2.allocUnsafe(size);
      if (size > 0) {
        if (size > MAX_BYTES) {
          for (var generated = 0; generated < size; generated += MAX_BYTES) {
            crypto$2.getRandomValues(bytes.slice(generated, generated + MAX_BYTES));
          }
        } else {
          crypto$2.getRandomValues(bytes);
        }
      }
      if (typeof cb === "function") {
        return process.nextTick(function() {
          cb(null, bytes);
        });
      }
      return bytes;
    }
    var dist$1 = {};
    var aes$2 = {};
    var dist = {};
    var cryptoBrowserify = {};
    var inherits$2;
    if (typeof Object.create === "function") {
      inherits$2 = function inherits2(ctor, superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      };
    } else {
      inherits$2 = function inherits2(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      };
    }
    var inherits$3 = inherits$2;
    var _polyfillNode_inherits = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      default: inherits$3
    });
    var require$$3$1 = /* @__PURE__ */ getAugmentedNamespace(_polyfillNode_inherits);
    var readableBrowserExports = {};
    var readableBrowser = {
      get exports() {
        return readableBrowserExports;
      },
      set exports(v2) {
        readableBrowserExports = v2;
      }
    };
    var domain;
    function EventHandlers() {
    }
    EventHandlers.prototype = Object.create(null);
    function EventEmitter() {
      EventEmitter.init.call(this);
    }
    EventEmitter.EventEmitter = EventEmitter;
    EventEmitter.usingDomains = false;
    EventEmitter.prototype.domain = void 0;
    EventEmitter.prototype._events = void 0;
    EventEmitter.prototype._maxListeners = void 0;
    EventEmitter.defaultMaxListeners = 10;
    EventEmitter.init = function() {
      this.domain = null;
      if (EventEmitter.usingDomains) {
        if (domain.active)
          ;
      }
      if (!this._events || this._events === Object.getPrototypeOf(this)._events) {
        this._events = new EventHandlers();
        this._eventsCount = 0;
      }
      this._maxListeners = this._maxListeners || void 0;
    };
    EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
      if (typeof n !== "number" || n < 0 || isNaN(n))
        throw new TypeError('"n" argument must be a positive number');
      this._maxListeners = n;
      return this;
    };
    function $getMaxListeners(that) {
      if (that._maxListeners === void 0)
        return EventEmitter.defaultMaxListeners;
      return that._maxListeners;
    }
    EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
      return $getMaxListeners(this);
    };
    function emitNone(handler, isFn, self2) {
      if (isFn)
        handler.call(self2);
      else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for (var i = 0; i < len; ++i)
          listeners[i].call(self2);
      }
    }
    function emitOne(handler, isFn, self2, arg1) {
      if (isFn)
        handler.call(self2, arg1);
      else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for (var i = 0; i < len; ++i)
          listeners[i].call(self2, arg1);
      }
    }
    function emitTwo(handler, isFn, self2, arg1, arg2) {
      if (isFn)
        handler.call(self2, arg1, arg2);
      else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for (var i = 0; i < len; ++i)
          listeners[i].call(self2, arg1, arg2);
      }
    }
    function emitThree(handler, isFn, self2, arg1, arg2, arg3) {
      if (isFn)
        handler.call(self2, arg1, arg2, arg3);
      else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for (var i = 0; i < len; ++i)
          listeners[i].call(self2, arg1, arg2, arg3);
      }
    }
    function emitMany(handler, isFn, self2, args) {
      if (isFn)
        handler.apply(self2, args);
      else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for (var i = 0; i < len; ++i)
          listeners[i].apply(self2, args);
      }
    }
    EventEmitter.prototype.emit = function emit2(type) {
      var er, handler, len, args, i, events, domain2;
      var doError = type === "error";
      events = this._events;
      if (events)
        doError = doError && events.error == null;
      else if (!doError)
        return false;
      domain2 = this.domain;
      if (doError) {
        er = arguments[1];
        if (domain2) {
          if (!er)
            er = new Error('Uncaught, unspecified "error" event');
          er.domainEmitter = this;
          er.domain = domain2;
          er.domainThrown = false;
          domain2.emit("error", er);
        } else if (er instanceof Error) {
          throw er;
        } else {
          var err = new Error('Uncaught, unspecified "error" event. (' + er + ")");
          err.context = er;
          throw err;
        }
        return false;
      }
      handler = events[type];
      if (!handler)
        return false;
      var isFn = typeof handler === "function";
      len = arguments.length;
      switch (len) {
        case 1:
          emitNone(handler, isFn, this);
          break;
        case 2:
          emitOne(handler, isFn, this, arguments[1]);
          break;
        case 3:
          emitTwo(handler, isFn, this, arguments[1], arguments[2]);
          break;
        case 4:
          emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
          break;
        default:
          args = new Array(len - 1);
          for (i = 1; i < len; i++)
            args[i - 1] = arguments[i];
          emitMany(handler, isFn, this, args);
      }
      return true;
    };
    function _addListener(target, type, listener, prepend) {
      var m;
      var events;
      var existing;
      if (typeof listener !== "function")
        throw new TypeError('"listener" argument must be a function');
      events = target._events;
      if (!events) {
        events = target._events = new EventHandlers();
        target._eventsCount = 0;
      } else {
        if (events.newListener) {
          target.emit("newListener", type, listener.listener ? listener.listener : listener);
          events = target._events;
        }
        existing = events[type];
      }
      if (!existing) {
        existing = events[type] = listener;
        ++target._eventsCount;
      } else {
        if (typeof existing === "function") {
          existing = events[type] = prepend ? [listener, existing] : [existing, listener];
        } else {
          if (prepend) {
            existing.unshift(listener);
          } else {
            existing.push(listener);
          }
        }
        if (!existing.warned) {
          m = $getMaxListeners(target);
          if (m && m > 0 && existing.length > m) {
            existing.warned = true;
            var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + type + " listeners added. Use emitter.setMaxListeners() to increase limit");
            w.name = "MaxListenersExceededWarning";
            w.emitter = target;
            w.type = type;
            w.count = existing.length;
            emitWarning(w);
          }
        }
      }
      return target;
    }
    function emitWarning(e) {
      typeof console.warn === "function" ? console.warn(e) : console.log(e);
    }
    EventEmitter.prototype.addListener = function addListener2(type, listener) {
      return _addListener(this, type, listener, false);
    };
    EventEmitter.prototype.on = EventEmitter.prototype.addListener;
    EventEmitter.prototype.prependListener = function prependListener2(type, listener) {
      return _addListener(this, type, listener, true);
    };
    function _onceWrap(target, type, listener) {
      var fired = false;
      function g() {
        target.removeListener(type, g);
        if (!fired) {
          fired = true;
          listener.apply(target, arguments);
        }
      }
      g.listener = listener;
      return g;
    }
    EventEmitter.prototype.once = function once2(type, listener) {
      if (typeof listener !== "function")
        throw new TypeError('"listener" argument must be a function');
      this.on(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
      if (typeof listener !== "function")
        throw new TypeError('"listener" argument must be a function');
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter.prototype.removeListener = function removeListener2(type, listener) {
      var list, events, position, i, originalListener;
      if (typeof listener !== "function")
        throw new TypeError('"listener" argument must be a function');
      events = this._events;
      if (!events)
        return this;
      list = events[type];
      if (!list)
        return this;
      if (list === listener || list.listener && list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = new EventHandlers();
        else {
          delete events[type];
          if (events.removeListener)
            this.emit("removeListener", type, list.listener || listener);
        }
      } else if (typeof list !== "function") {
        position = -1;
        for (i = list.length; i-- > 0; ) {
          if (list[i] === listener || list[i].listener && list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }
        if (position < 0)
          return this;
        if (list.length === 1) {
          list[0] = void 0;
          if (--this._eventsCount === 0) {
            this._events = new EventHandlers();
            return this;
          } else {
            delete events[type];
          }
        } else {
          spliceOne(list, position);
        }
        if (events.removeListener)
          this.emit("removeListener", type, originalListener || listener);
      }
      return this;
    };
    EventEmitter.prototype.off = function(type, listener) {
      return this.removeListener(type, listener);
    };
    EventEmitter.prototype.removeAllListeners = function removeAllListeners2(type) {
      var listeners, events;
      events = this._events;
      if (!events)
        return this;
      if (!events.removeListener) {
        if (arguments.length === 0) {
          this._events = new EventHandlers();
          this._eventsCount = 0;
        } else if (events[type]) {
          if (--this._eventsCount === 0)
            this._events = new EventHandlers();
          else
            delete events[type];
        }
        return this;
      }
      if (arguments.length === 0) {
        var keys2 = Object.keys(events);
        for (var i = 0, key2; i < keys2.length; ++i) {
          key2 = keys2[i];
          if (key2 === "removeListener")
            continue;
          this.removeAllListeners(key2);
        }
        this.removeAllListeners("removeListener");
        this._events = new EventHandlers();
        this._eventsCount = 0;
        return this;
      }
      listeners = events[type];
      if (typeof listeners === "function") {
        this.removeListener(type, listeners);
      } else if (listeners) {
        do {
          this.removeListener(type, listeners[listeners.length - 1]);
        } while (listeners[0]);
      }
      return this;
    };
    EventEmitter.prototype.listeners = function listeners(type) {
      var evlistener;
      var ret;
      var events = this._events;
      if (!events)
        ret = [];
      else {
        evlistener = events[type];
        if (!evlistener)
          ret = [];
        else if (typeof evlistener === "function")
          ret = [evlistener.listener || evlistener];
        else
          ret = unwrapListeners(evlistener);
      }
      return ret;
    };
    EventEmitter.listenerCount = function(emitter, type) {
      if (typeof emitter.listenerCount === "function") {
        return emitter.listenerCount(type);
      } else {
        return listenerCount$1.call(emitter, type);
      }
    };
    EventEmitter.prototype.listenerCount = listenerCount$1;
    function listenerCount$1(type) {
      var events = this._events;
      if (events) {
        var evlistener = events[type];
        if (typeof evlistener === "function") {
          return 1;
        } else if (evlistener) {
          return evlistener.length;
        }
      }
      return 0;
    }
    EventEmitter.prototype.eventNames = function eventNames() {
      return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
    };
    function spliceOne(list, index2) {
      for (var i = index2, k = i + 1, n = list.length; k < n; i += 1, k += 1)
        list[i] = list[k];
      list.pop();
    }
    function arrayClone(arr, i) {
      var copy = new Array(i);
      while (i--)
        copy[i] = arr[i];
      return copy;
    }
    function unwrapListeners(arr) {
      var ret = new Array(arr.length);
      for (var i = 0; i < ret.length; ++i) {
        ret[i] = arr[i].listener || arr[i];
      }
      return ret;
    }
    var _polyfillNode_events = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      EventEmitter,
      default: EventEmitter
    });
    var require$$0$1 = /* @__PURE__ */ getAugmentedNamespace(_polyfillNode_events);
    var streamBrowser;
    var hasRequiredStreamBrowser;
    function requireStreamBrowser() {
      if (hasRequiredStreamBrowser)
        return streamBrowser;
      hasRequiredStreamBrowser = 1;
      streamBrowser = require$$0$1.EventEmitter;
      return streamBrowser;
    }
    function defaultSetTimout() {
      throw new Error("setTimeout has not been defined");
    }
    function defaultClearTimeout() {
      throw new Error("clearTimeout has not been defined");
    }
    var cachedSetTimeout = defaultSetTimout;
    var cachedClearTimeout = defaultClearTimeout;
    if (typeof global$1.setTimeout === "function") {
      cachedSetTimeout = setTimeout;
    }
    if (typeof global$1.clearTimeout === "function") {
      cachedClearTimeout = clearTimeout;
    }
    function runTimeout(fun) {
      if (cachedSetTimeout === setTimeout) {
        return setTimeout(fun, 0);
      }
      if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
      }
      try {
        return cachedSetTimeout(fun, 0);
      } catch (e) {
        try {
          return cachedSetTimeout.call(null, fun, 0);
        } catch (e2) {
          return cachedSetTimeout.call(this, fun, 0);
        }
      }
    }
    function runClearTimeout(marker) {
      if (cachedClearTimeout === clearTimeout) {
        return clearTimeout(marker);
      }
      if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
      }
      try {
        return cachedClearTimeout(marker);
      } catch (e) {
        try {
          return cachedClearTimeout.call(null, marker);
        } catch (e2) {
          return cachedClearTimeout.call(this, marker);
        }
      }
    }
    var queue = [];
    var draining = false;
    var currentQueue;
    var queueIndex = -1;
    function cleanUpNextTick() {
      if (!draining || !currentQueue) {
        return;
      }
      draining = false;
      if (currentQueue.length) {
        queue = currentQueue.concat(queue);
      } else {
        queueIndex = -1;
      }
      if (queue.length) {
        drainQueue();
      }
    }
    function drainQueue() {
      if (draining) {
        return;
      }
      var timeout = runTimeout(cleanUpNextTick);
      draining = true;
      var len = queue.length;
      while (len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
          if (currentQueue) {
            currentQueue[queueIndex].run();
          }
        }
        queueIndex = -1;
        len = queue.length;
      }
      currentQueue = null;
      draining = false;
      runClearTimeout(timeout);
    }
    function nextTick(fun) {
      var args = new Array(arguments.length - 1);
      if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
          args[i - 1] = arguments[i];
        }
      }
      queue.push(new Item(fun, args));
      if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
      }
    }
    function Item(fun, array) {
      this.fun = fun;
      this.array = array;
    }
    Item.prototype.run = function() {
      this.fun.apply(null, this.array);
    };
    var title = "browser";
    var platform = "browser";
    var browser$c = true;
    var env = {};
    var argv = [];
    var version$1 = "";
    var versions = {};
    var release = {};
    var config = {};
    function noop$3() {
    }
    var on = noop$3;
    var addListener = noop$3;
    var once$2 = noop$3;
    var off = noop$3;
    var removeListener = noop$3;
    var removeAllListeners = noop$3;
    var emit = noop$3;
    function binding(name2) {
      throw new Error("process.binding is not supported");
    }
    function cwd() {
      return "/";
    }
    function chdir(dir) {
      throw new Error("process.chdir is not supported");
    }
    function umask() {
      return 0;
    }
    var performance2 = global$1.performance || {};
    var performanceNow = performance2.now || performance2.mozNow || performance2.msNow || performance2.oNow || performance2.webkitNow || function() {
      return new Date().getTime();
    };
    function hrtime(previousTimestamp) {
      var clocktime = performanceNow.call(performance2) * 1e-3;
      var seconds = Math.floor(clocktime);
      var nanoseconds = Math.floor(clocktime % 1 * 1e9);
      if (previousTimestamp) {
        seconds = seconds - previousTimestamp[0];
        nanoseconds = nanoseconds - previousTimestamp[1];
        if (nanoseconds < 0) {
          seconds--;
          nanoseconds += 1e9;
        }
      }
      return [seconds, nanoseconds];
    }
    var startTime = new Date();
    function uptime() {
      var currentTime = new Date();
      var dif = currentTime - startTime;
      return dif / 1e3;
    }
    var browser$1$1 = {
      nextTick,
      title,
      browser: browser$c,
      env,
      argv,
      version: version$1,
      versions,
      on,
      addListener,
      once: once$2,
      off,
      removeListener,
      removeAllListeners,
      emit,
      binding,
      cwd,
      chdir,
      umask,
      hrtime,
      platform,
      release,
      config,
      uptime
    };
    var inherits;
    if (typeof Object.create === "function") {
      inherits = function inherits2(ctor, superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      };
    } else {
      inherits = function inherits2(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      };
    }
    var inherits$1 = inherits;
    var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors2(obj) {
      var keys2 = Object.keys(obj);
      var descriptors = {};
      for (var i = 0; i < keys2.length; i++) {
        descriptors[keys2[i]] = Object.getOwnPropertyDescriptor(obj, keys2[i]);
      }
      return descriptors;
    };
    var formatRegExp = /%[sdj%]/g;
    function format(f) {
      if (!isString(f)) {
        var objects = [];
        for (var i = 0; i < arguments.length; i++) {
          objects.push(inspect(arguments[i]));
        }
        return objects.join(" ");
      }
      var i = 1;
      var args = arguments;
      var len = args.length;
      var str = String(f).replace(formatRegExp, function(x2) {
        if (x2 === "%%")
          return "%";
        if (i >= len)
          return x2;
        switch (x2) {
          case "%s":
            return String(args[i++]);
          case "%d":
            return Number(args[i++]);
          case "%j":
            try {
              return JSON.stringify(args[i++]);
            } catch (_) {
              return "[Circular]";
            }
          default:
            return x2;
        }
      });
      for (var x = args[i]; i < len; x = args[++i]) {
        if (isNull(x) || !isObject(x)) {
          str += " " + x;
        } else {
          str += " " + inspect(x);
        }
      }
      return str;
    }
    function deprecate(fn, msg) {
      if (isUndefined(global$1.process)) {
        return function() {
          return deprecate(fn, msg).apply(this, arguments);
        };
      }
      if (browser$1$1.noDeprecation === true) {
        return fn;
      }
      var warned = false;
      function deprecated() {
        if (!warned) {
          if (browser$1$1.throwDeprecation) {
            throw new Error(msg);
          } else if (browser$1$1.traceDeprecation) {
            console.trace(msg);
          } else {
            console.error(msg);
          }
          warned = true;
        }
        return fn.apply(this, arguments);
      }
      return deprecated;
    }
    var debugs = {};
    var debugEnviron;
    function debuglog(set) {
      if (isUndefined(debugEnviron))
        debugEnviron = browser$1$1.env.NODE_DEBUG || "";
      set = set.toUpperCase();
      if (!debugs[set]) {
        if (new RegExp("\\b" + set + "\\b", "i").test(debugEnviron)) {
          var pid = 0;
          debugs[set] = function() {
            var msg = format.apply(null, arguments);
            console.error("%s %d: %s", set, pid, msg);
          };
        } else {
          debugs[set] = function() {
          };
        }
      }
      return debugs[set];
    }
    function inspect(obj, opts) {
      var ctx = {
        seen: [],
        stylize: stylizeNoColor
      };
      if (arguments.length >= 3)
        ctx.depth = arguments[2];
      if (arguments.length >= 4)
        ctx.colors = arguments[3];
      if (isBoolean(opts)) {
        ctx.showHidden = opts;
      } else if (opts) {
        _extend(ctx, opts);
      }
      if (isUndefined(ctx.showHidden))
        ctx.showHidden = false;
      if (isUndefined(ctx.depth))
        ctx.depth = 2;
      if (isUndefined(ctx.colors))
        ctx.colors = false;
      if (isUndefined(ctx.customInspect))
        ctx.customInspect = true;
      if (ctx.colors)
        ctx.stylize = stylizeWithColor;
      return formatValue(ctx, obj, ctx.depth);
    }
    inspect.colors = {
      bold: [1, 22],
      italic: [3, 23],
      underline: [4, 24],
      inverse: [7, 27],
      white: [37, 39],
      grey: [90, 39],
      black: [30, 39],
      blue: [34, 39],
      cyan: [36, 39],
      green: [32, 39],
      magenta: [35, 39],
      red: [31, 39],
      yellow: [33, 39]
    };
    inspect.styles = {
      special: "cyan",
      number: "yellow",
      boolean: "yellow",
      undefined: "grey",
      null: "bold",
      string: "green",
      date: "magenta",
      regexp: "red"
    };
    function stylizeWithColor(str, styleType) {
      var style = inspect.styles[styleType];
      if (style) {
        return "[" + inspect.colors[style][0] + "m" + str + "[" + inspect.colors[style][1] + "m";
      } else {
        return str;
      }
    }
    function stylizeNoColor(str, styleType) {
      return str;
    }
    function arrayToHash(array) {
      var hash2 = {};
      array.forEach(function(val, idx) {
        hash2[val] = true;
      });
      return hash2;
    }
    function formatValue(ctx, value, recurseTimes) {
      if (ctx.customInspect && value && isFunction(value.inspect) && value.inspect !== inspect && !(value.constructor && value.constructor.prototype === value)) {
        var ret = value.inspect(recurseTimes, ctx);
        if (!isString(ret)) {
          ret = formatValue(ctx, ret, recurseTimes);
        }
        return ret;
      }
      var primitive = formatPrimitive(ctx, value);
      if (primitive) {
        return primitive;
      }
      var keys2 = Object.keys(value);
      var visibleKeys = arrayToHash(keys2);
      if (ctx.showHidden) {
        keys2 = Object.getOwnPropertyNames(value);
      }
      if (isError(value) && (keys2.indexOf("message") >= 0 || keys2.indexOf("description") >= 0)) {
        return formatError(value);
      }
      if (keys2.length === 0) {
        if (isFunction(value)) {
          var name2 = value.name ? ": " + value.name : "";
          return ctx.stylize("[Function" + name2 + "]", "special");
        }
        if (isRegExp(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
        }
        if (isDate(value)) {
          return ctx.stylize(Date.prototype.toString.call(value), "date");
        }
        if (isError(value)) {
          return formatError(value);
        }
      }
      var base2 = "", array = false, braces = ["{", "}"];
      if (isArray(value)) {
        array = true;
        braces = ["[", "]"];
      }
      if (isFunction(value)) {
        var n = value.name ? ": " + value.name : "";
        base2 = " [Function" + n + "]";
      }
      if (isRegExp(value)) {
        base2 = " " + RegExp.prototype.toString.call(value);
      }
      if (isDate(value)) {
        base2 = " " + Date.prototype.toUTCString.call(value);
      }
      if (isError(value)) {
        base2 = " " + formatError(value);
      }
      if (keys2.length === 0 && (!array || value.length == 0)) {
        return braces[0] + base2 + braces[1];
      }
      if (recurseTimes < 0) {
        if (isRegExp(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
        } else {
          return ctx.stylize("[Object]", "special");
        }
      }
      ctx.seen.push(value);
      var output;
      if (array) {
        output = formatArray(ctx, value, recurseTimes, visibleKeys, keys2);
      } else {
        output = keys2.map(function(key2) {
          return formatProperty(ctx, value, recurseTimes, visibleKeys, key2, array);
        });
      }
      ctx.seen.pop();
      return reduceToSingleString(output, base2, braces);
    }
    function formatPrimitive(ctx, value) {
      if (isUndefined(value))
        return ctx.stylize("undefined", "undefined");
      if (isString(value)) {
        var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
        return ctx.stylize(simple, "string");
      }
      if (isNumber(value))
        return ctx.stylize("" + value, "number");
      if (isBoolean(value))
        return ctx.stylize("" + value, "boolean");
      if (isNull(value))
        return ctx.stylize("null", "null");
    }
    function formatError(value) {
      return "[" + Error.prototype.toString.call(value) + "]";
    }
    function formatArray(ctx, value, recurseTimes, visibleKeys, keys2) {
      var output = [];
      for (var i = 0, l = value.length; i < l; ++i) {
        if (hasOwnProperty(value, String(i))) {
          output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
        } else {
          output.push("");
        }
      }
      keys2.forEach(function(key2) {
        if (!key2.match(/^\d+$/)) {
          output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key2, true));
        }
      });
      return output;
    }
    function formatProperty(ctx, value, recurseTimes, visibleKeys, key2, array) {
      var name2, str, desc;
      desc = Object.getOwnPropertyDescriptor(value, key2) || {value: value[key2]};
      if (desc.get) {
        if (desc.set) {
          str = ctx.stylize("[Getter/Setter]", "special");
        } else {
          str = ctx.stylize("[Getter]", "special");
        }
      } else {
        if (desc.set) {
          str = ctx.stylize("[Setter]", "special");
        }
      }
      if (!hasOwnProperty(visibleKeys, key2)) {
        name2 = "[" + key2 + "]";
      }
      if (!str) {
        if (ctx.seen.indexOf(desc.value) < 0) {
          if (isNull(recurseTimes)) {
            str = formatValue(ctx, desc.value, null);
          } else {
            str = formatValue(ctx, desc.value, recurseTimes - 1);
          }
          if (str.indexOf("\n") > -1) {
            if (array) {
              str = str.split("\n").map(function(line) {
                return "  " + line;
              }).join("\n").substr(2);
            } else {
              str = "\n" + str.split("\n").map(function(line) {
                return "   " + line;
              }).join("\n");
            }
          }
        } else {
          str = ctx.stylize("[Circular]", "special");
        }
      }
      if (isUndefined(name2)) {
        if (array && key2.match(/^\d+$/)) {
          return str;
        }
        name2 = JSON.stringify("" + key2);
        if (name2.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
          name2 = name2.substr(1, name2.length - 2);
          name2 = ctx.stylize(name2, "name");
        } else {
          name2 = name2.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
          name2 = ctx.stylize(name2, "string");
        }
      }
      return name2 + ": " + str;
    }
    function reduceToSingleString(output, base2, braces) {
      var length2 = output.reduce(function(prev, cur) {
        if (cur.indexOf("\n") >= 0)
          ;
        return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
      }, 0);
      if (length2 > 60) {
        return braces[0] + (base2 === "" ? "" : base2 + "\n ") + " " + output.join(",\n  ") + " " + braces[1];
      }
      return braces[0] + base2 + " " + output.join(", ") + " " + braces[1];
    }
    function isArray(ar) {
      return Array.isArray(ar);
    }
    function isBoolean(arg) {
      return typeof arg === "boolean";
    }
    function isNull(arg) {
      return arg === null;
    }
    function isNullOrUndefined(arg) {
      return arg == null;
    }
    function isNumber(arg) {
      return typeof arg === "number";
    }
    function isString(arg) {
      return typeof arg === "string";
    }
    function isSymbol(arg) {
      return typeof arg === "symbol";
    }
    function isUndefined(arg) {
      return arg === void 0;
    }
    function isRegExp(re) {
      return isObject(re) && objectToString(re) === "[object RegExp]";
    }
    function isObject(arg) {
      return typeof arg === "object" && arg !== null;
    }
    function isDate(d) {
      return isObject(d) && objectToString(d) === "[object Date]";
    }
    function isError(e) {
      return isObject(e) && (objectToString(e) === "[object Error]" || e instanceof Error);
    }
    function isFunction(arg) {
      return typeof arg === "function";
    }
    function isPrimitive(arg) {
      return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || typeof arg === "undefined";
    }
    function isBuffer(maybeBuf) {
      return Buffer$3.isBuffer(maybeBuf);
    }
    function objectToString(o) {
      return Object.prototype.toString.call(o);
    }
    function pad(n) {
      return n < 10 ? "0" + n.toString(10) : n.toString(10);
    }
    var months = [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec"
    ];
    function timestamp() {
      var d = new Date();
      var time = [
        pad(d.getHours()),
        pad(d.getMinutes()),
        pad(d.getSeconds())
      ].join(":");
      return [d.getDate(), months[d.getMonth()], time].join(" ");
    }
    function log() {
      console.log("%s - %s", timestamp(), format.apply(null, arguments));
    }
    function _extend(origin, add) {
      if (!add || !isObject(add))
        return origin;
      var keys2 = Object.keys(add);
      var i = keys2.length;
      while (i--) {
        origin[keys2[i]] = add[keys2[i]];
      }
      return origin;
    }
    function hasOwnProperty(obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    }
    var kCustomPromisifiedSymbol = typeof Symbol !== "undefined" ? Symbol("util.promisify.custom") : void 0;
    function promisify(original) {
      if (typeof original !== "function")
        throw new TypeError('The "original" argument must be of type Function');
      if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
        var fn = original[kCustomPromisifiedSymbol];
        if (typeof fn !== "function") {
          throw new TypeError('The "util.promisify.custom" argument must be of type Function');
        }
        Object.defineProperty(fn, kCustomPromisifiedSymbol, {
          value: fn,
          enumerable: false,
          writable: false,
          configurable: true
        });
        return fn;
      }
      function fn() {
        var promiseResolve, promiseReject;
        var promise2 = new Promise(function(resolve, reject) {
          promiseResolve = resolve;
          promiseReject = reject;
        });
        var args = [];
        for (var i = 0; i < arguments.length; i++) {
          args.push(arguments[i]);
        }
        args.push(function(err, value) {
          if (err) {
            promiseReject(err);
          } else {
            promiseResolve(value);
          }
        });
        try {
          original.apply(this, args);
        } catch (err) {
          promiseReject(err);
        }
        return promise2;
      }
      Object.setPrototypeOf(fn, Object.getPrototypeOf(original));
      if (kCustomPromisifiedSymbol)
        Object.defineProperty(fn, kCustomPromisifiedSymbol, {
          value: fn,
          enumerable: false,
          writable: false,
          configurable: true
        });
      return Object.defineProperties(fn, getOwnPropertyDescriptors(original));
    }
    promisify.custom = kCustomPromisifiedSymbol;
    function callbackifyOnRejected(reason, cb) {
      if (!reason) {
        var newReason = new Error("Promise was rejected with a falsy value");
        newReason.reason = reason;
        reason = newReason;
      }
      return cb(reason);
    }
    function callbackify(original) {
      if (typeof original !== "function") {
        throw new TypeError('The "original" argument must be of type Function');
      }
      function callbackified() {
        var args = [];
        for (var i = 0; i < arguments.length; i++) {
          args.push(arguments[i]);
        }
        var maybeCb = args.pop();
        if (typeof maybeCb !== "function") {
          throw new TypeError("The last argument must be of type Function");
        }
        var self2 = this;
        var cb = function() {
          return maybeCb.apply(self2, arguments);
        };
        original.apply(this, args).then(function(ret) {
          browser$1$1.nextTick(cb.bind(null, null, ret));
        }, function(rej) {
          browser$1$1.nextTick(callbackifyOnRejected.bind(null, rej, cb));
        });
      }
      Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
      Object.defineProperties(callbackified, getOwnPropertyDescriptors(original));
      return callbackified;
    }
    var _polyfillNode_util = {
      inherits: inherits$1,
      _extend,
      log,
      isBuffer,
      isPrimitive,
      isFunction,
      isError,
      isDate,
      isObject,
      isRegExp,
      isUndefined,
      isSymbol,
      isString,
      isNumber,
      isNullOrUndefined,
      isNull,
      isBoolean,
      isArray,
      inspect,
      deprecate,
      format,
      debuglog,
      promisify,
      callbackify
    };
    var _polyfillNode_util$1 = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      _extend,
      callbackify,
      debuglog,
      default: _polyfillNode_util,
      deprecate,
      format,
      inherits: inherits$1,
      inspect,
      isArray,
      isBoolean,
      isBuffer,
      isDate,
      isError,
      isFunction,
      isNull,
      isNullOrUndefined,
      isNumber,
      isObject,
      isPrimitive,
      isRegExp,
      isString,
      isSymbol,
      isUndefined,
      log,
      promisify
    });
    var require$$3 = /* @__PURE__ */ getAugmentedNamespace(_polyfillNode_util$1);
    var buffer_list;
    var hasRequiredBuffer_list;
    function requireBuffer_list() {
      if (hasRequiredBuffer_list)
        return buffer_list;
      hasRequiredBuffer_list = 1;
      function ownKeys(object2, enumerableOnly) {
        var keys2 = Object.keys(object2);
        if (Object.getOwnPropertySymbols) {
          var symbols = Object.getOwnPropertySymbols(object2);
          enumerableOnly && (symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
          })), keys2.push.apply(keys2, symbols);
        }
        return keys2;
      }
      function _objectSpread(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i] != null ? arguments[i] : {};
          i % 2 ? ownKeys(Object(source), true).forEach(function(key2) {
            _defineProperty(target, key2, source[key2]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key2) {
            Object.defineProperty(target, key2, Object.getOwnPropertyDescriptor(source, key2));
          });
        }
        return target;
      }
      function _defineProperty(obj, key2, value) {
        key2 = _toPropertyKey(key2);
        if (key2 in obj) {
          Object.defineProperty(obj, key2, {value, enumerable: true, configurable: true, writable: true});
        } else {
          obj[key2] = value;
        }
        return obj;
      }
      function _toPropertyKey(arg) {
        var key2 = _toPrimitive(arg, "string");
        return typeof key2 === "symbol" ? key2 : String(key2);
      }
      function _toPrimitive(input, hint) {
        if (typeof input !== "object" || input === null)
          return input;
        var prim = input[Symbol.toPrimitive];
        if (prim !== void 0) {
          var res = prim.call(input, hint || "default");
          if (typeof res !== "object")
            return res;
          throw new TypeError("@@toPrimitive must return a primitive value.");
        }
        return (hint === "string" ? String : Number)(input);
      }
      const _require = require$$6$1, Buffer2 = _require.Buffer;
      const _require2 = require$$3, inspect2 = _require2.inspect;
      const custom = inspect2 && inspect2.custom || "inspect";
      function copyBuffer(src2, target, offset) {
        Buffer2.prototype.copy.call(src2, target, offset);
      }
      buffer_list = class BufferList {
        constructor() {
          this.head = null;
          this.tail = null;
          this.length = 0;
        }
        push(v2) {
          const entry = {
            data: v2,
            next: null
          };
          if (this.length > 0)
            this.tail.next = entry;
          else
            this.head = entry;
          this.tail = entry;
          ++this.length;
        }
        unshift(v2) {
          const entry = {
            data: v2,
            next: this.head
          };
          if (this.length === 0)
            this.tail = entry;
          this.head = entry;
          ++this.length;
        }
        shift() {
          if (this.length === 0)
            return;
          const ret = this.head.data;
          if (this.length === 1)
            this.head = this.tail = null;
          else
            this.head = this.head.next;
          --this.length;
          return ret;
        }
        clear() {
          this.head = this.tail = null;
          this.length = 0;
        }
        join(s) {
          if (this.length === 0)
            return "";
          var p = this.head;
          var ret = "" + p.data;
          while (p = p.next)
            ret += s + p.data;
          return ret;
        }
        concat(n) {
          if (this.length === 0)
            return Buffer2.alloc(0);
          const ret = Buffer2.allocUnsafe(n >>> 0);
          var p = this.head;
          var i = 0;
          while (p) {
            copyBuffer(p.data, ret, i);
            i += p.data.length;
            p = p.next;
          }
          return ret;
        }
        consume(n, hasStrings) {
          var ret;
          if (n < this.head.data.length) {
            ret = this.head.data.slice(0, n);
            this.head.data = this.head.data.slice(n);
          } else if (n === this.head.data.length) {
            ret = this.shift();
          } else {
            ret = hasStrings ? this._getString(n) : this._getBuffer(n);
          }
          return ret;
        }
        first() {
          return this.head.data;
        }
        _getString(n) {
          var p = this.head;
          var c = 1;
          var ret = p.data;
          n -= ret.length;
          while (p = p.next) {
            const str = p.data;
            const nb = n > str.length ? str.length : n;
            if (nb === str.length)
              ret += str;
            else
              ret += str.slice(0, n);
            n -= nb;
            if (n === 0) {
              if (nb === str.length) {
                ++c;
                if (p.next)
                  this.head = p.next;
                else
                  this.head = this.tail = null;
              } else {
                this.head = p;
                p.data = str.slice(nb);
              }
              break;
            }
            ++c;
          }
          this.length -= c;
          return ret;
        }
        _getBuffer(n) {
          const ret = Buffer2.allocUnsafe(n);
          var p = this.head;
          var c = 1;
          p.data.copy(ret);
          n -= p.data.length;
          while (p = p.next) {
            const buf2 = p.data;
            const nb = n > buf2.length ? buf2.length : n;
            buf2.copy(ret, ret.length - n, 0, nb);
            n -= nb;
            if (n === 0) {
              if (nb === buf2.length) {
                ++c;
                if (p.next)
                  this.head = p.next;
                else
                  this.head = this.tail = null;
              } else {
                this.head = p;
                p.data = buf2.slice(nb);
              }
              break;
            }
            ++c;
          }
          this.length -= c;
          return ret;
        }
        [custom](_, options) {
          return inspect2(this, _objectSpread(_objectSpread({}, options), {}, {
            depth: 0,
            customInspect: false
          }));
        }
      };
      return buffer_list;
    }
    var destroy_1;
    var hasRequiredDestroy;
    function requireDestroy() {
      if (hasRequiredDestroy)
        return destroy_1;
      hasRequiredDestroy = 1;
      function destroy(err, cb) {
        const readableDestroyed = this._readableState && this._readableState.destroyed;
        const writableDestroyed = this._writableState && this._writableState.destroyed;
        if (readableDestroyed || writableDestroyed) {
          if (cb) {
            cb(err);
          } else if (err) {
            if (!this._writableState) {
              process.nextTick(emitErrorNT, this, err);
            } else if (!this._writableState.errorEmitted) {
              this._writableState.errorEmitted = true;
              process.nextTick(emitErrorNT, this, err);
            }
          }
          return this;
        }
        if (this._readableState) {
          this._readableState.destroyed = true;
        }
        if (this._writableState) {
          this._writableState.destroyed = true;
        }
        this._destroy(err || null, (err2) => {
          if (!cb && err2) {
            if (!this._writableState) {
              process.nextTick(emitErrorAndCloseNT, this, err2);
            } else if (!this._writableState.errorEmitted) {
              this._writableState.errorEmitted = true;
              process.nextTick(emitErrorAndCloseNT, this, err2);
            } else {
              process.nextTick(emitCloseNT, this);
            }
          } else if (cb) {
            process.nextTick(emitCloseNT, this);
            cb(err2);
          } else {
            process.nextTick(emitCloseNT, this);
          }
        });
        return this;
      }
      function emitErrorAndCloseNT(self2, err) {
        emitErrorNT(self2, err);
        emitCloseNT(self2);
      }
      function emitCloseNT(self2) {
        if (self2._writableState && !self2._writableState.emitClose)
          return;
        if (self2._readableState && !self2._readableState.emitClose)
          return;
        self2.emit("close");
      }
      function undestroy() {
        if (this._readableState) {
          this._readableState.destroyed = false;
          this._readableState.reading = false;
          this._readableState.ended = false;
          this._readableState.endEmitted = false;
        }
        if (this._writableState) {
          this._writableState.destroyed = false;
          this._writableState.ended = false;
          this._writableState.ending = false;
          this._writableState.finalCalled = false;
          this._writableState.prefinished = false;
          this._writableState.finished = false;
          this._writableState.errorEmitted = false;
        }
      }
      function emitErrorNT(self2, err) {
        self2.emit("error", err);
      }
      function errorOrDestroy(stream2, err) {
        const rState = stream2._readableState;
        const wState = stream2._writableState;
        if (rState && rState.autoDestroy || wState && wState.autoDestroy)
          stream2.destroy(err);
        else
          stream2.emit("error", err);
      }
      destroy_1 = {
        destroy,
        undestroy,
        errorOrDestroy
      };
      return destroy_1;
    }
    var errorsBrowser = {};
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      subClass.__proto__ = superClass;
    }
    var codes = {};
    function createErrorType(code2, message, Base2) {
      if (!Base2) {
        Base2 = Error;
      }
      function getMessage(arg1, arg2, arg3) {
        if (typeof message === "string") {
          return message;
        } else {
          return message(arg1, arg2, arg3);
        }
      }
      var NodeError = /* @__PURE__ */ function(_Base) {
        _inheritsLoose(NodeError2, _Base);
        function NodeError2(arg1, arg2, arg3) {
          return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
        }
        return NodeError2;
      }(Base2);
      NodeError.prototype.name = Base2.name;
      NodeError.prototype.code = code2;
      codes[code2] = NodeError;
    }
    function oneOf(expected, thing) {
      if (Array.isArray(expected)) {
        var len = expected.length;
        expected = expected.map(function(i) {
          return String(i);
        });
        if (len > 2) {
          return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(", "), ", or ") + expected[len - 1];
        } else if (len === 2) {
          return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
        } else {
          return "of ".concat(thing, " ").concat(expected[0]);
        }
      } else {
        return "of ".concat(thing, " ").concat(String(expected));
      }
    }
    function startsWith(str, search, pos) {
      return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
    }
    function endsWith(str, search, this_len) {
      if (this_len === void 0 || this_len > str.length) {
        this_len = str.length;
      }
      return str.substring(this_len - search.length, this_len) === search;
    }
    function includes(str, search, start) {
      if (typeof start !== "number") {
        start = 0;
      }
      if (start + search.length > str.length) {
        return false;
      } else {
        return str.indexOf(search, start) !== -1;
      }
    }
    createErrorType("ERR_INVALID_OPT_VALUE", function(name2, value) {
      return 'The value "' + value + '" is invalid for option "' + name2 + '"';
    }, TypeError);
    createErrorType("ERR_INVALID_ARG_TYPE", function(name2, expected, actual) {
      var determiner;
      if (typeof expected === "string" && startsWith(expected, "not ")) {
        determiner = "must not be";
        expected = expected.replace(/^not /, "");
      } else {
        determiner = "must be";
      }
      var msg;
      if (endsWith(name2, " argument")) {
        msg = "The ".concat(name2, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
      } else {
        var type = includes(name2, ".") ? "property" : "argument";
        msg = 'The "'.concat(name2, '" ').concat(type, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
      }
      msg += ". Received type ".concat(typeof actual);
      return msg;
    }, TypeError);
    createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
    createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name2) {
      return "The " + name2 + " method is not implemented";
    });
    createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
    createErrorType("ERR_STREAM_DESTROYED", function(name2) {
      return "Cannot call " + name2 + " after a stream was destroyed";
    });
    createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
    createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
    createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
    createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
      return "Unknown encoding: " + arg;
    }, TypeError);
    createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
    errorsBrowser.codes = codes;
    var state;
    var hasRequiredState;
    function requireState() {
      if (hasRequiredState)
        return state;
      hasRequiredState = 1;
      const ERR_INVALID_OPT_VALUE = errorsBrowser.codes.ERR_INVALID_OPT_VALUE;
      function highWaterMarkFrom(options, isDuplex, duplexKey) {
        return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
      }
      function getHighWaterMark(state2, options, duplexKey, isDuplex) {
        const hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
        if (hwm != null) {
          if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
            const name2 = isDuplex ? duplexKey : "highWaterMark";
            throw new ERR_INVALID_OPT_VALUE(name2, hwm);
          }
          return Math.floor(hwm);
        }
        return state2.objectMode ? 16 : 16 * 1024;
      }
      state = {
        getHighWaterMark
      };
      return state;
    }
    var browser$b;
    var hasRequiredBrowser$a;
    function requireBrowser$a() {
      if (hasRequiredBrowser$a)
        return browser$b;
      hasRequiredBrowser$a = 1;
      browser$b = deprecate2;
      function deprecate2(fn, msg) {
        if (config2("noDeprecation")) {
          return fn;
        }
        var warned = false;
        function deprecated() {
          if (!warned) {
            if (config2("throwDeprecation")) {
              throw new Error(msg);
            } else if (config2("traceDeprecation")) {
              console.trace(msg);
            } else {
              console.warn(msg);
            }
            warned = true;
          }
          return fn.apply(this, arguments);
        }
        return deprecated;
      }
      function config2(name2) {
        try {
          if (!commonjsGlobal.localStorage)
            return false;
        } catch (_) {
          return false;
        }
        var val = commonjsGlobal.localStorage[name2];
        if (val == null)
          return false;
        return String(val).toLowerCase() === "true";
      }
      return browser$b;
    }
    var _stream_writable;
    var hasRequired_stream_writable;
    function require_stream_writable() {
      if (hasRequired_stream_writable)
        return _stream_writable;
      hasRequired_stream_writable = 1;
      _stream_writable = Writable2;
      function CorkedRequest2(state2) {
        this.next = null;
        this.entry = null;
        this.finish = () => {
          onCorkedFinish(this, state2);
        };
      }
      var Duplex2;
      Writable2.WritableState = WritableState2;
      const internalUtil = {
        deprecate: requireBrowser$a()
      };
      var Stream2 = requireStreamBrowser();
      const Buffer2 = require$$6$1.Buffer;
      const OurUint8Array = (typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
      };
      function _uint8ArrayToBuffer(chunk) {
        return Buffer2.from(chunk);
      }
      function _isUint8Array(obj) {
        return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
      }
      const destroyImpl = requireDestroy();
      const _require = requireState(), getHighWaterMark = _require.getHighWaterMark;
      const _require$codes2 = errorsBrowser.codes, ERR_INVALID_ARG_TYPE = _require$codes2.ERR_INVALID_ARG_TYPE, ERR_METHOD_NOT_IMPLEMENTED2 = _require$codes2.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK2 = _require$codes2.ERR_MULTIPLE_CALLBACK, ERR_STREAM_CANNOT_PIPE = _require$codes2.ERR_STREAM_CANNOT_PIPE, ERR_STREAM_DESTROYED2 = _require$codes2.ERR_STREAM_DESTROYED, ERR_STREAM_NULL_VALUES = _require$codes2.ERR_STREAM_NULL_VALUES, ERR_STREAM_WRITE_AFTER_END = _require$codes2.ERR_STREAM_WRITE_AFTER_END, ERR_UNKNOWN_ENCODING = _require$codes2.ERR_UNKNOWN_ENCODING;
      const errorOrDestroy = destroyImpl.errorOrDestroy;
      require$$3$1(Writable2, Stream2);
      function nop2() {
      }
      function WritableState2(options, stream2, isDuplex) {
        Duplex2 = Duplex2 || require_stream_duplex();
        options = options || {};
        if (typeof isDuplex !== "boolean")
          isDuplex = stream2 instanceof Duplex2;
        this.objectMode = !!options.objectMode;
        if (isDuplex)
          this.objectMode = this.objectMode || !!options.writableObjectMode;
        this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
        this.finalCalled = false;
        this.needDrain = false;
        this.ending = false;
        this.ended = false;
        this.finished = false;
        this.destroyed = false;
        var noDecode = options.decodeStrings === false;
        this.decodeStrings = !noDecode;
        this.defaultEncoding = options.defaultEncoding || "utf8";
        this.length = 0;
        this.writing = false;
        this.corked = 0;
        this.sync = true;
        this.bufferProcessing = false;
        this.onwrite = function(er) {
          onwrite2(stream2, er);
        };
        this.writecb = null;
        this.writelen = 0;
        this.bufferedRequest = null;
        this.lastBufferedRequest = null;
        this.pendingcb = 0;
        this.prefinished = false;
        this.errorEmitted = false;
        this.emitClose = options.emitClose !== false;
        this.autoDestroy = !!options.autoDestroy;
        this.bufferedRequestCount = 0;
        this.corkedRequestsFree = new CorkedRequest2(this);
      }
      WritableState2.prototype.getBuffer = function getBuffer() {
        var current = this.bufferedRequest;
        var out = [];
        while (current) {
          out.push(current);
          current = current.next;
        }
        return out;
      };
      (function() {
        try {
          Object.defineProperty(WritableState2.prototype, "buffer", {
            get: internalUtil.deprecate(function writableStateBufferGetter() {
              return this.getBuffer();
            }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
          });
        } catch (_) {
        }
      })();
      var realHasInstance;
      if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
        realHasInstance = Function.prototype[Symbol.hasInstance];
        Object.defineProperty(Writable2, Symbol.hasInstance, {
          value: function value(object2) {
            if (realHasInstance.call(this, object2))
              return true;
            if (this !== Writable2)
              return false;
            return object2 && object2._writableState instanceof WritableState2;
          }
        });
      } else {
        realHasInstance = function realHasInstance2(object2) {
          return object2 instanceof this;
        };
      }
      function Writable2(options) {
        Duplex2 = Duplex2 || require_stream_duplex();
        const isDuplex = this instanceof Duplex2;
        if (!isDuplex && !realHasInstance.call(Writable2, this))
          return new Writable2(options);
        this._writableState = new WritableState2(options, this, isDuplex);
        this.writable = true;
        if (options) {
          if (typeof options.write === "function")
            this._write = options.write;
          if (typeof options.writev === "function")
            this._writev = options.writev;
          if (typeof options.destroy === "function")
            this._destroy = options.destroy;
          if (typeof options.final === "function")
            this._final = options.final;
        }
        Stream2.call(this);
      }
      Writable2.prototype.pipe = function() {
        errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
      };
      function writeAfterEnd2(stream2, cb) {
        var er = new ERR_STREAM_WRITE_AFTER_END();
        errorOrDestroy(stream2, er);
        process.nextTick(cb, er);
      }
      function validChunk2(stream2, state2, chunk, cb) {
        var er;
        if (chunk === null) {
          er = new ERR_STREAM_NULL_VALUES();
        } else if (typeof chunk !== "string" && !state2.objectMode) {
          er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
        }
        if (er) {
          errorOrDestroy(stream2, er);
          process.nextTick(cb, er);
          return false;
        }
        return true;
      }
      Writable2.prototype.write = function(chunk, encoding, cb) {
        var state2 = this._writableState;
        var ret = false;
        var isBuf = !state2.objectMode && _isUint8Array(chunk);
        if (isBuf && !Buffer2.isBuffer(chunk)) {
          chunk = _uint8ArrayToBuffer(chunk);
        }
        if (typeof encoding === "function") {
          cb = encoding;
          encoding = null;
        }
        if (isBuf)
          encoding = "buffer";
        else if (!encoding)
          encoding = state2.defaultEncoding;
        if (typeof cb !== "function")
          cb = nop2;
        if (state2.ending)
          writeAfterEnd2(this, cb);
        else if (isBuf || validChunk2(this, state2, chunk, cb)) {
          state2.pendingcb++;
          ret = writeOrBuffer2(this, state2, isBuf, chunk, encoding, cb);
        }
        return ret;
      };
      Writable2.prototype.cork = function() {
        this._writableState.corked++;
      };
      Writable2.prototype.uncork = function() {
        var state2 = this._writableState;
        if (state2.corked) {
          state2.corked--;
          if (!state2.writing && !state2.corked && !state2.bufferProcessing && state2.bufferedRequest)
            clearBuffer2(this, state2);
        }
      };
      Writable2.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
        if (typeof encoding === "string")
          encoding = encoding.toLowerCase();
        if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
          throw new ERR_UNKNOWN_ENCODING(encoding);
        this._writableState.defaultEncoding = encoding;
        return this;
      };
      Object.defineProperty(Writable2.prototype, "writableBuffer", {
        enumerable: false,
        get: function get2() {
          return this._writableState && this._writableState.getBuffer();
        }
      });
      function decodeChunk2(state2, chunk, encoding) {
        if (!state2.objectMode && state2.decodeStrings !== false && typeof chunk === "string") {
          chunk = Buffer2.from(chunk, encoding);
        }
        return chunk;
      }
      Object.defineProperty(Writable2.prototype, "writableHighWaterMark", {
        enumerable: false,
        get: function get2() {
          return this._writableState.highWaterMark;
        }
      });
      function writeOrBuffer2(stream2, state2, isBuf, chunk, encoding, cb) {
        if (!isBuf) {
          var newChunk = decodeChunk2(state2, chunk, encoding);
          if (chunk !== newChunk) {
            isBuf = true;
            encoding = "buffer";
            chunk = newChunk;
          }
        }
        var len = state2.objectMode ? 1 : chunk.length;
        state2.length += len;
        var ret = state2.length < state2.highWaterMark;
        if (!ret)
          state2.needDrain = true;
        if (state2.writing || state2.corked) {
          var last = state2.lastBufferedRequest;
          state2.lastBufferedRequest = {
            chunk,
            encoding,
            isBuf,
            callback: cb,
            next: null
          };
          if (last) {
            last.next = state2.lastBufferedRequest;
          } else {
            state2.bufferedRequest = state2.lastBufferedRequest;
          }
          state2.bufferedRequestCount += 1;
        } else {
          doWrite2(stream2, state2, false, len, chunk, encoding, cb);
        }
        return ret;
      }
      function doWrite2(stream2, state2, writev, len, chunk, encoding, cb) {
        state2.writelen = len;
        state2.writecb = cb;
        state2.writing = true;
        state2.sync = true;
        if (state2.destroyed)
          state2.onwrite(new ERR_STREAM_DESTROYED2("write"));
        else if (writev)
          stream2._writev(chunk, state2.onwrite);
        else
          stream2._write(chunk, encoding, state2.onwrite);
        state2.sync = false;
      }
      function onwriteError2(stream2, state2, sync, er, cb) {
        --state2.pendingcb;
        if (sync) {
          process.nextTick(cb, er);
          process.nextTick(finishMaybe2, stream2, state2);
          stream2._writableState.errorEmitted = true;
          errorOrDestroy(stream2, er);
        } else {
          cb(er);
          stream2._writableState.errorEmitted = true;
          errorOrDestroy(stream2, er);
          finishMaybe2(stream2, state2);
        }
      }
      function onwriteStateUpdate2(state2) {
        state2.writing = false;
        state2.writecb = null;
        state2.length -= state2.writelen;
        state2.writelen = 0;
      }
      function onwrite2(stream2, er) {
        var state2 = stream2._writableState;
        var sync = state2.sync;
        var cb = state2.writecb;
        if (typeof cb !== "function")
          throw new ERR_MULTIPLE_CALLBACK2();
        onwriteStateUpdate2(state2);
        if (er)
          onwriteError2(stream2, state2, sync, er, cb);
        else {
          var finished = needFinish2(state2) || stream2.destroyed;
          if (!finished && !state2.corked && !state2.bufferProcessing && state2.bufferedRequest) {
            clearBuffer2(stream2, state2);
          }
          if (sync) {
            process.nextTick(afterWrite2, stream2, state2, finished, cb);
          } else {
            afterWrite2(stream2, state2, finished, cb);
          }
        }
      }
      function afterWrite2(stream2, state2, finished, cb) {
        if (!finished)
          onwriteDrain2(stream2, state2);
        state2.pendingcb--;
        cb();
        finishMaybe2(stream2, state2);
      }
      function onwriteDrain2(stream2, state2) {
        if (state2.length === 0 && state2.needDrain) {
          state2.needDrain = false;
          stream2.emit("drain");
        }
      }
      function clearBuffer2(stream2, state2) {
        state2.bufferProcessing = true;
        var entry = state2.bufferedRequest;
        if (stream2._writev && entry && entry.next) {
          var l = state2.bufferedRequestCount;
          var buffer2 = new Array(l);
          var holder = state2.corkedRequestsFree;
          holder.entry = entry;
          var count = 0;
          var allBuffers = true;
          while (entry) {
            buffer2[count] = entry;
            if (!entry.isBuf)
              allBuffers = false;
            entry = entry.next;
            count += 1;
          }
          buffer2.allBuffers = allBuffers;
          doWrite2(stream2, state2, true, state2.length, buffer2, "", holder.finish);
          state2.pendingcb++;
          state2.lastBufferedRequest = null;
          if (holder.next) {
            state2.corkedRequestsFree = holder.next;
            holder.next = null;
          } else {
            state2.corkedRequestsFree = new CorkedRequest2(state2);
          }
          state2.bufferedRequestCount = 0;
        } else {
          while (entry) {
            var chunk = entry.chunk;
            var encoding = entry.encoding;
            var cb = entry.callback;
            var len = state2.objectMode ? 1 : chunk.length;
            doWrite2(stream2, state2, false, len, chunk, encoding, cb);
            entry = entry.next;
            state2.bufferedRequestCount--;
            if (state2.writing) {
              break;
            }
          }
          if (entry === null)
            state2.lastBufferedRequest = null;
        }
        state2.bufferedRequest = entry;
        state2.bufferProcessing = false;
      }
      Writable2.prototype._write = function(chunk, encoding, cb) {
        cb(new ERR_METHOD_NOT_IMPLEMENTED2("_write()"));
      };
      Writable2.prototype._writev = null;
      Writable2.prototype.end = function(chunk, encoding, cb) {
        var state2 = this._writableState;
        if (typeof chunk === "function") {
          cb = chunk;
          chunk = null;
          encoding = null;
        } else if (typeof encoding === "function") {
          cb = encoding;
          encoding = null;
        }
        if (chunk !== null && chunk !== void 0)
          this.write(chunk, encoding);
        if (state2.corked) {
          state2.corked = 1;
          this.uncork();
        }
        if (!state2.ending)
          endWritable2(this, state2, cb);
        return this;
      };
      Object.defineProperty(Writable2.prototype, "writableLength", {
        enumerable: false,
        get() {
          return this._writableState.length;
        }
      });
      function needFinish2(state2) {
        return state2.ending && state2.length === 0 && state2.bufferedRequest === null && !state2.finished && !state2.writing;
      }
      function callFinal(stream2, state2) {
        stream2._final((err) => {
          state2.pendingcb--;
          if (err) {
            errorOrDestroy(stream2, err);
          }
          state2.prefinished = true;
          stream2.emit("prefinish");
          finishMaybe2(stream2, state2);
        });
      }
      function prefinish2(stream2, state2) {
        if (!state2.prefinished && !state2.finalCalled) {
          if (typeof stream2._final === "function" && !state2.destroyed) {
            state2.pendingcb++;
            state2.finalCalled = true;
            process.nextTick(callFinal, stream2, state2);
          } else {
            state2.prefinished = true;
            stream2.emit("prefinish");
          }
        }
      }
      function finishMaybe2(stream2, state2) {
        var need = needFinish2(state2);
        if (need) {
          prefinish2(stream2, state2);
          if (state2.pendingcb === 0) {
            state2.finished = true;
            stream2.emit("finish");
            if (state2.autoDestroy) {
              const rState = stream2._readableState;
              if (!rState || rState.autoDestroy && rState.endEmitted) {
                stream2.destroy();
              }
            }
          }
        }
        return need;
      }
      function endWritable2(stream2, state2, cb) {
        state2.ending = true;
        finishMaybe2(stream2, state2);
        if (cb) {
          if (state2.finished)
            process.nextTick(cb);
          else
            stream2.once("finish", cb);
        }
        state2.ended = true;
        stream2.writable = false;
      }
      function onCorkedFinish(corkReq, state2, err) {
        var entry = corkReq.entry;
        corkReq.entry = null;
        while (entry) {
          var cb = entry.callback;
          state2.pendingcb--;
          cb(err);
          entry = entry.next;
        }
        state2.corkedRequestsFree.next = corkReq;
      }
      Object.defineProperty(Writable2.prototype, "destroyed", {
        enumerable: false,
        get() {
          if (this._writableState === void 0) {
            return false;
          }
          return this._writableState.destroyed;
        },
        set(value) {
          if (!this._writableState) {
            return;
          }
          this._writableState.destroyed = value;
        }
      });
      Writable2.prototype.destroy = destroyImpl.destroy;
      Writable2.prototype._undestroy = destroyImpl.undestroy;
      Writable2.prototype._destroy = function(err, cb) {
        cb(err);
      };
      return _stream_writable;
    }
    var _stream_duplex;
    var hasRequired_stream_duplex;
    function require_stream_duplex() {
      if (hasRequired_stream_duplex)
        return _stream_duplex;
      hasRequired_stream_duplex = 1;
      var objectKeys = Object.keys || function(obj) {
        var keys2 = [];
        for (var key2 in obj)
          keys2.push(key2);
        return keys2;
      };
      _stream_duplex = Duplex2;
      const Readable2 = require_stream_readable();
      const Writable2 = require_stream_writable();
      require$$3$1(Duplex2, Readable2);
      {
        const keys2 = objectKeys(Writable2.prototype);
        for (var v2 = 0; v2 < keys2.length; v2++) {
          const method2 = keys2[v2];
          if (!Duplex2.prototype[method2])
            Duplex2.prototype[method2] = Writable2.prototype[method2];
        }
      }
      function Duplex2(options) {
        if (!(this instanceof Duplex2))
          return new Duplex2(options);
        Readable2.call(this, options);
        Writable2.call(this, options);
        this.allowHalfOpen = true;
        if (options) {
          if (options.readable === false)
            this.readable = false;
          if (options.writable === false)
            this.writable = false;
          if (options.allowHalfOpen === false) {
            this.allowHalfOpen = false;
            this.once("end", onend2);
          }
        }
      }
      Object.defineProperty(Duplex2.prototype, "writableHighWaterMark", {
        enumerable: false,
        get() {
          return this._writableState.highWaterMark;
        }
      });
      Object.defineProperty(Duplex2.prototype, "writableBuffer", {
        enumerable: false,
        get: function get2() {
          return this._writableState && this._writableState.getBuffer();
        }
      });
      Object.defineProperty(Duplex2.prototype, "writableLength", {
        enumerable: false,
        get() {
          return this._writableState.length;
        }
      });
      function onend2() {
        if (this._writableState.ended)
          return;
        process.nextTick(onEndNT2, this);
      }
      function onEndNT2(self2) {
        self2.end();
      }
      Object.defineProperty(Duplex2.prototype, "destroyed", {
        enumerable: false,
        get() {
          if (this._readableState === void 0 || this._writableState === void 0) {
            return false;
          }
          return this._readableState.destroyed && this._writableState.destroyed;
        },
        set(value) {
          if (this._readableState === void 0 || this._writableState === void 0) {
            return;
          }
          this._readableState.destroyed = value;
          this._writableState.destroyed = value;
        }
      });
      return _stream_duplex;
    }
    var isBufferEncoding = Buffer$3.isEncoding || function(encoding) {
      switch (encoding && encoding.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function assertEncoding(encoding) {
      if (encoding && !isBufferEncoding(encoding)) {
        throw new Error("Unknown encoding: " + encoding);
      }
    }
    function StringDecoder(encoding) {
      this.encoding = (encoding || "utf8").toLowerCase().replace(/[-_]/, "");
      assertEncoding(encoding);
      switch (this.encoding) {
        case "utf8":
          this.surrogateSize = 3;
          break;
        case "ucs2":
        case "utf16le":
          this.surrogateSize = 2;
          this.detectIncompleteChar = utf16DetectIncompleteChar;
          break;
        case "base64":
          this.surrogateSize = 3;
          this.detectIncompleteChar = base64DetectIncompleteChar;
          break;
        default:
          this.write = passThroughWrite;
          return;
      }
      this.charBuffer = new Buffer$3(6);
      this.charReceived = 0;
      this.charLength = 0;
    }
    StringDecoder.prototype.write = function(buffer2) {
      var charStr = "";
      while (this.charLength) {
        var available = buffer2.length >= this.charLength - this.charReceived ? this.charLength - this.charReceived : buffer2.length;
        buffer2.copy(this.charBuffer, this.charReceived, 0, available);
        this.charReceived += available;
        if (this.charReceived < this.charLength) {
          return "";
        }
        buffer2 = buffer2.slice(available, buffer2.length);
        charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);
        var charCode = charStr.charCodeAt(charStr.length - 1);
        if (charCode >= 55296 && charCode <= 56319) {
          this.charLength += this.surrogateSize;
          charStr = "";
          continue;
        }
        this.charReceived = this.charLength = 0;
        if (buffer2.length === 0) {
          return charStr;
        }
        break;
      }
      this.detectIncompleteChar(buffer2);
      var end = buffer2.length;
      if (this.charLength) {
        buffer2.copy(this.charBuffer, 0, buffer2.length - this.charReceived, end);
        end -= this.charReceived;
      }
      charStr += buffer2.toString(this.encoding, 0, end);
      var end = charStr.length - 1;
      var charCode = charStr.charCodeAt(end);
      if (charCode >= 55296 && charCode <= 56319) {
        var size = this.surrogateSize;
        this.charLength += size;
        this.charReceived += size;
        this.charBuffer.copy(this.charBuffer, size, 0, size);
        buffer2.copy(this.charBuffer, 0, 0, size);
        return charStr.substring(0, end);
      }
      return charStr;
    };
    StringDecoder.prototype.detectIncompleteChar = function(buffer2) {
      var i = buffer2.length >= 3 ? 3 : buffer2.length;
      for (; i > 0; i--) {
        var c = buffer2[buffer2.length - i];
        if (i == 1 && c >> 5 == 6) {
          this.charLength = 2;
          break;
        }
        if (i <= 2 && c >> 4 == 14) {
          this.charLength = 3;
          break;
        }
        if (i <= 3 && c >> 3 == 30) {
          this.charLength = 4;
          break;
        }
      }
      this.charReceived = i;
    };
    StringDecoder.prototype.end = function(buffer2) {
      var res = "";
      if (buffer2 && buffer2.length)
        res = this.write(buffer2);
      if (this.charReceived) {
        var cr = this.charReceived;
        var buf2 = this.charBuffer;
        var enc = this.encoding;
        res += buf2.slice(0, cr).toString(enc);
      }
      return res;
    };
    function passThroughWrite(buffer2) {
      return buffer2.toString(this.encoding);
    }
    function utf16DetectIncompleteChar(buffer2) {
      this.charReceived = buffer2.length % 2;
      this.charLength = this.charReceived ? 2 : 0;
    }
    function base64DetectIncompleteChar(buffer2) {
      this.charReceived = buffer2.length % 3;
      this.charLength = this.charReceived ? 3 : 0;
    }
    var _polyfillNode_string_decoder = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      StringDecoder
    });
    var require$$2$1 = /* @__PURE__ */ getAugmentedNamespace(_polyfillNode_string_decoder);
    var ERR_STREAM_PREMATURE_CLOSE = errorsBrowser.codes.ERR_STREAM_PREMATURE_CLOSE;
    function once$1(callback) {
      let called = false;
      return function() {
        if (called)
          return;
        called = true;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        callback.apply(this, args);
      };
    }
    function noop$2() {
    }
    function isRequest$1(stream2) {
      return stream2.setHeader && typeof stream2.abort === "function";
    }
    function eos$1(stream2, opts, callback) {
      if (typeof opts === "function")
        return eos$1(stream2, null, opts);
      if (!opts)
        opts = {};
      callback = once$1(callback || noop$2);
      let readable = opts.readable || opts.readable !== false && stream2.readable;
      let writable = opts.writable || opts.writable !== false && stream2.writable;
      const onlegacyfinish = () => {
        if (!stream2.writable)
          onfinish();
      };
      var writableEnded = stream2._writableState && stream2._writableState.finished;
      const onfinish = () => {
        writable = false;
        writableEnded = true;
        if (!readable)
          callback.call(stream2);
      };
      var readableEnded = stream2._readableState && stream2._readableState.endEmitted;
      const onend2 = () => {
        readable = false;
        readableEnded = true;
        if (!writable)
          callback.call(stream2);
      };
      const onerror = (err) => {
        callback.call(stream2, err);
      };
      const onclose = () => {
        let err;
        if (readable && !readableEnded) {
          if (!stream2._readableState || !stream2._readableState.ended)
            err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream2, err);
        }
        if (writable && !writableEnded) {
          if (!stream2._writableState || !stream2._writableState.ended)
            err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream2, err);
        }
      };
      const onrequest = () => {
        stream2.req.on("finish", onfinish);
      };
      if (isRequest$1(stream2)) {
        stream2.on("complete", onfinish);
        stream2.on("abort", onclose);
        if (stream2.req)
          onrequest();
        else
          stream2.on("request", onrequest);
      } else if (writable && !stream2._writableState) {
        stream2.on("end", onlegacyfinish);
        stream2.on("close", onlegacyfinish);
      }
      stream2.on("end", onend2);
      stream2.on("finish", onfinish);
      if (opts.error !== false)
        stream2.on("error", onerror);
      stream2.on("close", onclose);
      return function() {
        stream2.removeListener("complete", onfinish);
        stream2.removeListener("abort", onclose);
        stream2.removeListener("request", onrequest);
        if (stream2.req)
          stream2.req.removeListener("finish", onfinish);
        stream2.removeListener("end", onlegacyfinish);
        stream2.removeListener("close", onlegacyfinish);
        stream2.removeListener("finish", onfinish);
        stream2.removeListener("end", onend2);
        stream2.removeListener("error", onerror);
        stream2.removeListener("close", onclose);
      };
    }
    var endOfStream = eos$1;
    var async_iterator;
    var hasRequiredAsync_iterator;
    function requireAsync_iterator() {
      if (hasRequiredAsync_iterator)
        return async_iterator;
      hasRequiredAsync_iterator = 1;
      const finished = endOfStream;
      const kLastResolve = Symbol("lastResolve");
      const kLastReject = Symbol("lastReject");
      const kError = Symbol("error");
      const kEnded = Symbol("ended");
      const kLastPromise = Symbol("lastPromise");
      const kHandlePromise = Symbol("handlePromise");
      const kStream = Symbol("stream");
      function createIterResult(value, done2) {
        return {
          value,
          done: done2
        };
      }
      function readAndResolve(iter) {
        const resolve = iter[kLastResolve];
        if (resolve !== null) {
          const data = iter[kStream].read();
          if (data !== null) {
            iter[kLastPromise] = null;
            iter[kLastResolve] = null;
            iter[kLastReject] = null;
            resolve(createIterResult(data, false));
          }
        }
      }
      function onReadable(iter) {
        process.nextTick(readAndResolve, iter);
      }
      function wrapForNext(lastPromise, iter) {
        return (resolve, reject) => {
          lastPromise.then(() => {
            if (iter[kEnded]) {
              resolve(createIterResult(void 0, true));
              return;
            }
            iter[kHandlePromise](resolve, reject);
          }, reject);
        };
      }
      const AsyncIteratorPrototype = Object.getPrototypeOf(function() {
      });
      const ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf({
        get stream() {
          return this[kStream];
        },
        next() {
          const error = this[kError];
          if (error !== null) {
            return Promise.reject(error);
          }
          if (this[kEnded]) {
            return Promise.resolve(createIterResult(void 0, true));
          }
          if (this[kStream].destroyed) {
            return new Promise((resolve, reject) => {
              process.nextTick(() => {
                if (this[kError]) {
                  reject(this[kError]);
                } else {
                  resolve(createIterResult(void 0, true));
                }
              });
            });
          }
          const lastPromise = this[kLastPromise];
          let promise2;
          if (lastPromise) {
            promise2 = new Promise(wrapForNext(lastPromise, this));
          } else {
            const data = this[kStream].read();
            if (data !== null) {
              return Promise.resolve(createIterResult(data, false));
            }
            promise2 = new Promise(this[kHandlePromise]);
          }
          this[kLastPromise] = promise2;
          return promise2;
        },
        [Symbol.asyncIterator]() {
          return this;
        },
        return() {
          return new Promise((resolve, reject) => {
            this[kStream].destroy(null, (err) => {
              if (err) {
                reject(err);
                return;
              }
              resolve(createIterResult(void 0, true));
            });
          });
        }
      }, AsyncIteratorPrototype);
      const createReadableStreamAsyncIterator = (stream2) => {
        const iterator = Object.create(ReadableStreamAsyncIteratorPrototype, {
          [kStream]: {
            value: stream2,
            writable: true
          },
          [kLastResolve]: {
            value: null,
            writable: true
          },
          [kLastReject]: {
            value: null,
            writable: true
          },
          [kError]: {
            value: null,
            writable: true
          },
          [kEnded]: {
            value: stream2._readableState.endEmitted,
            writable: true
          },
          [kHandlePromise]: {
            value: (resolve, reject) => {
              const data = iterator[kStream].read();
              if (data) {
                iterator[kLastPromise] = null;
                iterator[kLastResolve] = null;
                iterator[kLastReject] = null;
                resolve(createIterResult(data, false));
              } else {
                iterator[kLastResolve] = resolve;
                iterator[kLastReject] = reject;
              }
            },
            writable: true
          }
        });
        iterator[kLastPromise] = null;
        finished(stream2, (err) => {
          if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
            const reject = iterator[kLastReject];
            if (reject !== null) {
              iterator[kLastPromise] = null;
              iterator[kLastResolve] = null;
              iterator[kLastReject] = null;
              reject(err);
            }
            iterator[kError] = err;
            return;
          }
          const resolve = iterator[kLastResolve];
          if (resolve !== null) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            resolve(createIterResult(void 0, true));
          }
          iterator[kEnded] = true;
        });
        stream2.on("readable", onReadable.bind(null, iterator));
        return iterator;
      };
      async_iterator = createReadableStreamAsyncIterator;
      return async_iterator;
    }
    var fromBrowser;
    var hasRequiredFromBrowser;
    function requireFromBrowser() {
      if (hasRequiredFromBrowser)
        return fromBrowser;
      hasRequiredFromBrowser = 1;
      fromBrowser = function() {
        throw new Error("Readable.from is not available in the browser");
      };
      return fromBrowser;
    }
    var _stream_readable;
    var hasRequired_stream_readable;
    function require_stream_readable() {
      if (hasRequired_stream_readable)
        return _stream_readable;
      hasRequired_stream_readable = 1;
      _stream_readable = Readable2;
      var Duplex2;
      Readable2.ReadableState = ReadableState2;
      require$$0$1.EventEmitter;
      var EElistenerCount = function EElistenerCount2(emitter, type) {
        return emitter.listeners(type).length;
      };
      var Stream2 = requireStreamBrowser();
      const Buffer2 = require$$6$1.Buffer;
      const OurUint8Array = (typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
      };
      function _uint8ArrayToBuffer(chunk) {
        return Buffer2.from(chunk);
      }
      function _isUint8Array(obj) {
        return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
      }
      const debugUtil = require$$3;
      let debug2;
      if (debugUtil && debugUtil.debuglog) {
        debug2 = debugUtil.debuglog("stream");
      } else {
        debug2 = function debug3() {
        };
      }
      const BufferList2 = requireBuffer_list();
      const destroyImpl = requireDestroy();
      const _require = requireState(), getHighWaterMark = _require.getHighWaterMark;
      const _require$codes2 = errorsBrowser.codes, ERR_INVALID_ARG_TYPE = _require$codes2.ERR_INVALID_ARG_TYPE, ERR_STREAM_PUSH_AFTER_EOF = _require$codes2.ERR_STREAM_PUSH_AFTER_EOF, ERR_METHOD_NOT_IMPLEMENTED2 = _require$codes2.ERR_METHOD_NOT_IMPLEMENTED, ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes2.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
      let StringDecoder2;
      let createReadableStreamAsyncIterator;
      let from2;
      require$$3$1(Readable2, Stream2);
      const errorOrDestroy = destroyImpl.errorOrDestroy;
      const kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
      function prependListener2(emitter, event, fn) {
        if (typeof emitter.prependListener === "function")
          return emitter.prependListener(event, fn);
        if (!emitter._events || !emitter._events[event])
          emitter.on(event, fn);
        else if (Array.isArray(emitter._events[event]))
          emitter._events[event].unshift(fn);
        else
          emitter._events[event] = [fn, emitter._events[event]];
      }
      function ReadableState2(options, stream2, isDuplex) {
        Duplex2 = Duplex2 || require_stream_duplex();
        options = options || {};
        if (typeof isDuplex !== "boolean")
          isDuplex = stream2 instanceof Duplex2;
        this.objectMode = !!options.objectMode;
        if (isDuplex)
          this.objectMode = this.objectMode || !!options.readableObjectMode;
        this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
        this.buffer = new BufferList2();
        this.length = 0;
        this.pipes = null;
        this.pipesCount = 0;
        this.flowing = null;
        this.ended = false;
        this.endEmitted = false;
        this.reading = false;
        this.sync = true;
        this.needReadable = false;
        this.emittedReadable = false;
        this.readableListening = false;
        this.resumeScheduled = false;
        this.paused = true;
        this.emitClose = options.emitClose !== false;
        this.autoDestroy = !!options.autoDestroy;
        this.destroyed = false;
        this.defaultEncoding = options.defaultEncoding || "utf8";
        this.awaitDrain = 0;
        this.readingMore = false;
        this.decoder = null;
        this.encoding = null;
        if (options.encoding) {
          if (!StringDecoder2)
            StringDecoder2 = require$$2$1.StringDecoder;
          this.decoder = new StringDecoder2(options.encoding);
          this.encoding = options.encoding;
        }
      }
      function Readable2(options) {
        Duplex2 = Duplex2 || require_stream_duplex();
        if (!(this instanceof Readable2))
          return new Readable2(options);
        const isDuplex = this instanceof Duplex2;
        this._readableState = new ReadableState2(options, this, isDuplex);
        this.readable = true;
        if (options) {
          if (typeof options.read === "function")
            this._read = options.read;
          if (typeof options.destroy === "function")
            this._destroy = options.destroy;
        }
        Stream2.call(this);
      }
      Object.defineProperty(Readable2.prototype, "destroyed", {
        enumerable: false,
        get() {
          if (this._readableState === void 0) {
            return false;
          }
          return this._readableState.destroyed;
        },
        set(value) {
          if (!this._readableState) {
            return;
          }
          this._readableState.destroyed = value;
        }
      });
      Readable2.prototype.destroy = destroyImpl.destroy;
      Readable2.prototype._undestroy = destroyImpl.undestroy;
      Readable2.prototype._destroy = function(err, cb) {
        cb(err);
      };
      Readable2.prototype.push = function(chunk, encoding) {
        var state2 = this._readableState;
        var skipChunkCheck;
        if (!state2.objectMode) {
          if (typeof chunk === "string") {
            encoding = encoding || state2.defaultEncoding;
            if (encoding !== state2.encoding) {
              chunk = Buffer2.from(chunk, encoding);
              encoding = "";
            }
            skipChunkCheck = true;
          }
        } else {
          skipChunkCheck = true;
        }
        return readableAddChunk2(this, chunk, encoding, false, skipChunkCheck);
      };
      Readable2.prototype.unshift = function(chunk) {
        return readableAddChunk2(this, chunk, null, true, false);
      };
      function readableAddChunk2(stream2, chunk, encoding, addToFront, skipChunkCheck) {
        debug2("readableAddChunk", chunk);
        var state2 = stream2._readableState;
        if (chunk === null) {
          state2.reading = false;
          onEofChunk2(stream2, state2);
        } else {
          var er;
          if (!skipChunkCheck)
            er = chunkInvalid2(state2, chunk);
          if (er) {
            errorOrDestroy(stream2, er);
          } else if (state2.objectMode || chunk && chunk.length > 0) {
            if (typeof chunk !== "string" && !state2.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
              chunk = _uint8ArrayToBuffer(chunk);
            }
            if (addToFront) {
              if (state2.endEmitted)
                errorOrDestroy(stream2, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
              else
                addChunk(stream2, state2, chunk, true);
            } else if (state2.ended) {
              errorOrDestroy(stream2, new ERR_STREAM_PUSH_AFTER_EOF());
            } else if (state2.destroyed) {
              return false;
            } else {
              state2.reading = false;
              if (state2.decoder && !encoding) {
                chunk = state2.decoder.write(chunk);
                if (state2.objectMode || chunk.length !== 0)
                  addChunk(stream2, state2, chunk, false);
                else
                  maybeReadMore2(stream2, state2);
              } else {
                addChunk(stream2, state2, chunk, false);
              }
            }
          } else if (!addToFront) {
            state2.reading = false;
            maybeReadMore2(stream2, state2);
          }
        }
        return !state2.ended && (state2.length < state2.highWaterMark || state2.length === 0);
      }
      function addChunk(stream2, state2, chunk, addToFront) {
        if (state2.flowing && state2.length === 0 && !state2.sync) {
          state2.awaitDrain = 0;
          stream2.emit("data", chunk);
        } else {
          state2.length += state2.objectMode ? 1 : chunk.length;
          if (addToFront)
            state2.buffer.unshift(chunk);
          else
            state2.buffer.push(chunk);
          if (state2.needReadable)
            emitReadable2(stream2);
        }
        maybeReadMore2(stream2, state2);
      }
      function chunkInvalid2(state2, chunk) {
        var er;
        if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state2.objectMode) {
          er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
        }
        return er;
      }
      Readable2.prototype.isPaused = function() {
        return this._readableState.flowing === false;
      };
      Readable2.prototype.setEncoding = function(enc) {
        if (!StringDecoder2)
          StringDecoder2 = require$$2$1.StringDecoder;
        const decoder = new StringDecoder2(enc);
        this._readableState.decoder = decoder;
        this._readableState.encoding = this._readableState.decoder.encoding;
        let p = this._readableState.buffer.head;
        let content = "";
        while (p !== null) {
          content += decoder.write(p.data);
          p = p.next;
        }
        this._readableState.buffer.clear();
        if (content !== "")
          this._readableState.buffer.push(content);
        this._readableState.length = content.length;
        return this;
      };
      const MAX_HWM2 = 1073741824;
      function computeNewHighWaterMark2(n) {
        if (n >= MAX_HWM2) {
          n = MAX_HWM2;
        } else {
          n--;
          n |= n >>> 1;
          n |= n >>> 2;
          n |= n >>> 4;
          n |= n >>> 8;
          n |= n >>> 16;
          n++;
        }
        return n;
      }
      function howMuchToRead2(n, state2) {
        if (n <= 0 || state2.length === 0 && state2.ended)
          return 0;
        if (state2.objectMode)
          return 1;
        if (n !== n) {
          if (state2.flowing && state2.length)
            return state2.buffer.head.data.length;
          else
            return state2.length;
        }
        if (n > state2.highWaterMark)
          state2.highWaterMark = computeNewHighWaterMark2(n);
        if (n <= state2.length)
          return n;
        if (!state2.ended) {
          state2.needReadable = true;
          return 0;
        }
        return state2.length;
      }
      Readable2.prototype.read = function(n) {
        debug2("read", n);
        n = parseInt(n, 10);
        var state2 = this._readableState;
        var nOrig = n;
        if (n !== 0)
          state2.emittedReadable = false;
        if (n === 0 && state2.needReadable && ((state2.highWaterMark !== 0 ? state2.length >= state2.highWaterMark : state2.length > 0) || state2.ended)) {
          debug2("read: emitReadable", state2.length, state2.ended);
          if (state2.length === 0 && state2.ended)
            endReadable2(this);
          else
            emitReadable2(this);
          return null;
        }
        n = howMuchToRead2(n, state2);
        if (n === 0 && state2.ended) {
          if (state2.length === 0)
            endReadable2(this);
          return null;
        }
        var doRead = state2.needReadable;
        debug2("need readable", doRead);
        if (state2.length === 0 || state2.length - n < state2.highWaterMark) {
          doRead = true;
          debug2("length less than watermark", doRead);
        }
        if (state2.ended || state2.reading) {
          doRead = false;
          debug2("reading or ended", doRead);
        } else if (doRead) {
          debug2("do read");
          state2.reading = true;
          state2.sync = true;
          if (state2.length === 0)
            state2.needReadable = true;
          this._read(state2.highWaterMark);
          state2.sync = false;
          if (!state2.reading)
            n = howMuchToRead2(nOrig, state2);
        }
        var ret;
        if (n > 0)
          ret = fromList2(n, state2);
        else
          ret = null;
        if (ret === null) {
          state2.needReadable = state2.length <= state2.highWaterMark;
          n = 0;
        } else {
          state2.length -= n;
          state2.awaitDrain = 0;
        }
        if (state2.length === 0) {
          if (!state2.ended)
            state2.needReadable = true;
          if (nOrig !== n && state2.ended)
            endReadable2(this);
        }
        if (ret !== null)
          this.emit("data", ret);
        return ret;
      };
      function onEofChunk2(stream2, state2) {
        debug2("onEofChunk");
        if (state2.ended)
          return;
        if (state2.decoder) {
          var chunk = state2.decoder.end();
          if (chunk && chunk.length) {
            state2.buffer.push(chunk);
            state2.length += state2.objectMode ? 1 : chunk.length;
          }
        }
        state2.ended = true;
        if (state2.sync) {
          emitReadable2(stream2);
        } else {
          state2.needReadable = false;
          if (!state2.emittedReadable) {
            state2.emittedReadable = true;
            emitReadable_2(stream2);
          }
        }
      }
      function emitReadable2(stream2) {
        var state2 = stream2._readableState;
        debug2("emitReadable", state2.needReadable, state2.emittedReadable);
        state2.needReadable = false;
        if (!state2.emittedReadable) {
          debug2("emitReadable", state2.flowing);
          state2.emittedReadable = true;
          process.nextTick(emitReadable_2, stream2);
        }
      }
      function emitReadable_2(stream2) {
        var state2 = stream2._readableState;
        debug2("emitReadable_", state2.destroyed, state2.length, state2.ended);
        if (!state2.destroyed && (state2.length || state2.ended)) {
          stream2.emit("readable");
          state2.emittedReadable = false;
        }
        state2.needReadable = !state2.flowing && !state2.ended && state2.length <= state2.highWaterMark;
        flow2(stream2);
      }
      function maybeReadMore2(stream2, state2) {
        if (!state2.readingMore) {
          state2.readingMore = true;
          process.nextTick(maybeReadMore_2, stream2, state2);
        }
      }
      function maybeReadMore_2(stream2, state2) {
        while (!state2.reading && !state2.ended && (state2.length < state2.highWaterMark || state2.flowing && state2.length === 0)) {
          const len = state2.length;
          debug2("maybeReadMore read 0");
          stream2.read(0);
          if (len === state2.length)
            break;
        }
        state2.readingMore = false;
      }
      Readable2.prototype._read = function(n) {
        errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED2("_read()"));
      };
      Readable2.prototype.pipe = function(dest, pipeOpts) {
        var src2 = this;
        var state2 = this._readableState;
        switch (state2.pipesCount) {
          case 0:
            state2.pipes = dest;
            break;
          case 1:
            state2.pipes = [state2.pipes, dest];
            break;
          default:
            state2.pipes.push(dest);
            break;
        }
        state2.pipesCount += 1;
        debug2("pipe count=%d opts=%j", state2.pipesCount, pipeOpts);
        var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
        var endFn = doEnd ? onend2 : unpipe;
        if (state2.endEmitted)
          process.nextTick(endFn);
        else
          src2.once("end", endFn);
        dest.on("unpipe", onunpipe);
        function onunpipe(readable, unpipeInfo) {
          debug2("onunpipe");
          if (readable === src2) {
            if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
              unpipeInfo.hasUnpiped = true;
              cleanup();
            }
          }
        }
        function onend2() {
          debug2("onend");
          dest.end();
        }
        var ondrain = pipeOnDrain2(src2);
        dest.on("drain", ondrain);
        var cleanedUp = false;
        function cleanup() {
          debug2("cleanup");
          dest.removeListener("close", onclose);
          dest.removeListener("finish", onfinish);
          dest.removeListener("drain", ondrain);
          dest.removeListener("error", onerror);
          dest.removeListener("unpipe", onunpipe);
          src2.removeListener("end", onend2);
          src2.removeListener("end", unpipe);
          src2.removeListener("data", ondata);
          cleanedUp = true;
          if (state2.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
            ondrain();
        }
        src2.on("data", ondata);
        function ondata(chunk) {
          debug2("ondata");
          var ret = dest.write(chunk);
          debug2("dest.write", ret);
          if (ret === false) {
            if ((state2.pipesCount === 1 && state2.pipes === dest || state2.pipesCount > 1 && indexOf2(state2.pipes, dest) !== -1) && !cleanedUp) {
              debug2("false write response, pause", state2.awaitDrain);
              state2.awaitDrain++;
            }
            src2.pause();
          }
        }
        function onerror(er) {
          debug2("onerror", er);
          unpipe();
          dest.removeListener("error", onerror);
          if (EElistenerCount(dest, "error") === 0)
            errorOrDestroy(dest, er);
        }
        prependListener2(dest, "error", onerror);
        function onclose() {
          dest.removeListener("finish", onfinish);
          unpipe();
        }
        dest.once("close", onclose);
        function onfinish() {
          debug2("onfinish");
          dest.removeListener("close", onclose);
          unpipe();
        }
        dest.once("finish", onfinish);
        function unpipe() {
          debug2("unpipe");
          src2.unpipe(dest);
        }
        dest.emit("pipe", src2);
        if (!state2.flowing) {
          debug2("pipe resume");
          src2.resume();
        }
        return dest;
      };
      function pipeOnDrain2(src2) {
        return function pipeOnDrainFunctionResult() {
          var state2 = src2._readableState;
          debug2("pipeOnDrain", state2.awaitDrain);
          if (state2.awaitDrain)
            state2.awaitDrain--;
          if (state2.awaitDrain === 0 && EElistenerCount(src2, "data")) {
            state2.flowing = true;
            flow2(src2);
          }
        };
      }
      Readable2.prototype.unpipe = function(dest) {
        var state2 = this._readableState;
        var unpipeInfo = {
          hasUnpiped: false
        };
        if (state2.pipesCount === 0)
          return this;
        if (state2.pipesCount === 1) {
          if (dest && dest !== state2.pipes)
            return this;
          if (!dest)
            dest = state2.pipes;
          state2.pipes = null;
          state2.pipesCount = 0;
          state2.flowing = false;
          if (dest)
            dest.emit("unpipe", this, unpipeInfo);
          return this;
        }
        if (!dest) {
          var dests = state2.pipes;
          var len = state2.pipesCount;
          state2.pipes = null;
          state2.pipesCount = 0;
          state2.flowing = false;
          for (var i = 0; i < len; i++)
            dests[i].emit("unpipe", this, {
              hasUnpiped: false
            });
          return this;
        }
        var index2 = indexOf2(state2.pipes, dest);
        if (index2 === -1)
          return this;
        state2.pipes.splice(index2, 1);
        state2.pipesCount -= 1;
        if (state2.pipesCount === 1)
          state2.pipes = state2.pipes[0];
        dest.emit("unpipe", this, unpipeInfo);
        return this;
      };
      Readable2.prototype.on = function(ev, fn) {
        const res = Stream2.prototype.on.call(this, ev, fn);
        const state2 = this._readableState;
        if (ev === "data") {
          state2.readableListening = this.listenerCount("readable") > 0;
          if (state2.flowing !== false)
            this.resume();
        } else if (ev === "readable") {
          if (!state2.endEmitted && !state2.readableListening) {
            state2.readableListening = state2.needReadable = true;
            state2.flowing = false;
            state2.emittedReadable = false;
            debug2("on readable", state2.length, state2.reading);
            if (state2.length) {
              emitReadable2(this);
            } else if (!state2.reading) {
              process.nextTick(nReadingNextTick2, this);
            }
          }
        }
        return res;
      };
      Readable2.prototype.addListener = Readable2.prototype.on;
      Readable2.prototype.removeListener = function(ev, fn) {
        const res = Stream2.prototype.removeListener.call(this, ev, fn);
        if (ev === "readable") {
          process.nextTick(updateReadableListening, this);
        }
        return res;
      };
      Readable2.prototype.removeAllListeners = function(ev) {
        const res = Stream2.prototype.removeAllListeners.apply(this, arguments);
        if (ev === "readable" || ev === void 0) {
          process.nextTick(updateReadableListening, this);
        }
        return res;
      };
      function updateReadableListening(self2) {
        const state2 = self2._readableState;
        state2.readableListening = self2.listenerCount("readable") > 0;
        if (state2.resumeScheduled && !state2.paused) {
          state2.flowing = true;
        } else if (self2.listenerCount("data") > 0) {
          self2.resume();
        }
      }
      function nReadingNextTick2(self2) {
        debug2("readable nexttick read 0");
        self2.read(0);
      }
      Readable2.prototype.resume = function() {
        var state2 = this._readableState;
        if (!state2.flowing) {
          debug2("resume");
          state2.flowing = !state2.readableListening;
          resume2(this, state2);
        }
        state2.paused = false;
        return this;
      };
      function resume2(stream2, state2) {
        if (!state2.resumeScheduled) {
          state2.resumeScheduled = true;
          process.nextTick(resume_2, stream2, state2);
        }
      }
      function resume_2(stream2, state2) {
        debug2("resume", state2.reading);
        if (!state2.reading) {
          stream2.read(0);
        }
        state2.resumeScheduled = false;
        stream2.emit("resume");
        flow2(stream2);
        if (state2.flowing && !state2.reading)
          stream2.read(0);
      }
      Readable2.prototype.pause = function() {
        debug2("call pause flowing=%j", this._readableState.flowing);
        if (this._readableState.flowing !== false) {
          debug2("pause");
          this._readableState.flowing = false;
          this.emit("pause");
        }
        this._readableState.paused = true;
        return this;
      };
      function flow2(stream2) {
        const state2 = stream2._readableState;
        debug2("flow", state2.flowing);
        while (state2.flowing && stream2.read() !== null)
          ;
      }
      Readable2.prototype.wrap = function(stream2) {
        var state2 = this._readableState;
        var paused = false;
        stream2.on("end", () => {
          debug2("wrapped end");
          if (state2.decoder && !state2.ended) {
            var chunk = state2.decoder.end();
            if (chunk && chunk.length)
              this.push(chunk);
          }
          this.push(null);
        });
        stream2.on("data", (chunk) => {
          debug2("wrapped data");
          if (state2.decoder)
            chunk = state2.decoder.write(chunk);
          if (state2.objectMode && (chunk === null || chunk === void 0))
            return;
          else if (!state2.objectMode && (!chunk || !chunk.length))
            return;
          var ret = this.push(chunk);
          if (!ret) {
            paused = true;
            stream2.pause();
          }
        });
        for (var i in stream2) {
          if (this[i] === void 0 && typeof stream2[i] === "function") {
            this[i] = function methodWrap(method2) {
              return function methodWrapReturnFunction() {
                return stream2[method2].apply(stream2, arguments);
              };
            }(i);
          }
        }
        for (var n = 0; n < kProxyEvents.length; n++) {
          stream2.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
        }
        this._read = (n2) => {
          debug2("wrapped _read", n2);
          if (paused) {
            paused = false;
            stream2.resume();
          }
        };
        return this;
      };
      if (typeof Symbol === "function") {
        Readable2.prototype[Symbol.asyncIterator] = function() {
          if (createReadableStreamAsyncIterator === void 0) {
            createReadableStreamAsyncIterator = requireAsync_iterator();
          }
          return createReadableStreamAsyncIterator(this);
        };
      }
      Object.defineProperty(Readable2.prototype, "readableHighWaterMark", {
        enumerable: false,
        get: function get2() {
          return this._readableState.highWaterMark;
        }
      });
      Object.defineProperty(Readable2.prototype, "readableBuffer", {
        enumerable: false,
        get: function get2() {
          return this._readableState && this._readableState.buffer;
        }
      });
      Object.defineProperty(Readable2.prototype, "readableFlowing", {
        enumerable: false,
        get: function get2() {
          return this._readableState.flowing;
        },
        set: function set(state2) {
          if (this._readableState) {
            this._readableState.flowing = state2;
          }
        }
      });
      Readable2._fromList = fromList2;
      Object.defineProperty(Readable2.prototype, "readableLength", {
        enumerable: false,
        get() {
          return this._readableState.length;
        }
      });
      function fromList2(n, state2) {
        if (state2.length === 0)
          return null;
        var ret;
        if (state2.objectMode)
          ret = state2.buffer.shift();
        else if (!n || n >= state2.length) {
          if (state2.decoder)
            ret = state2.buffer.join("");
          else if (state2.buffer.length === 1)
            ret = state2.buffer.first();
          else
            ret = state2.buffer.concat(state2.length);
          state2.buffer.clear();
        } else {
          ret = state2.buffer.consume(n, state2.decoder);
        }
        return ret;
      }
      function endReadable2(stream2) {
        var state2 = stream2._readableState;
        debug2("endReadable", state2.endEmitted);
        if (!state2.endEmitted) {
          state2.ended = true;
          process.nextTick(endReadableNT2, state2, stream2);
        }
      }
      function endReadableNT2(state2, stream2) {
        debug2("endReadableNT", state2.endEmitted, state2.length);
        if (!state2.endEmitted && state2.length === 0) {
          state2.endEmitted = true;
          stream2.readable = false;
          stream2.emit("end");
          if (state2.autoDestroy) {
            const wState = stream2._writableState;
            if (!wState || wState.autoDestroy && wState.finished) {
              stream2.destroy();
            }
          }
        }
      }
      if (typeof Symbol === "function") {
        Readable2.from = function(iterable, opts) {
          if (from2 === void 0) {
            from2 = requireFromBrowser();
          }
          return from2(Readable2, iterable, opts);
        };
      }
      function indexOf2(xs, x) {
        for (var i = 0, l = xs.length; i < l; i++) {
          if (xs[i] === x)
            return i;
        }
        return -1;
      }
      return _stream_readable;
    }
    var _stream_transform = Transform$2;
    var _require$codes$1 = errorsBrowser.codes;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes$1.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_MULTIPLE_CALLBACK = _require$codes$1.ERR_MULTIPLE_CALLBACK;
    var ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes$1.ERR_TRANSFORM_ALREADY_TRANSFORMING;
    var ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes$1.ERR_TRANSFORM_WITH_LENGTH_0;
    var Duplex$1 = require_stream_duplex();
    require$$3$1(Transform$2, Duplex$1);
    function afterTransform$1(er, data) {
      var ts = this._transformState;
      ts.transforming = false;
      var cb = ts.writecb;
      if (cb === null) {
        return this.emit("error", new ERR_MULTIPLE_CALLBACK());
      }
      ts.writechunk = null;
      ts.writecb = null;
      if (data != null)
        this.push(data);
      cb(er);
      var rs = this._readableState;
      rs.reading = false;
      if (rs.needReadable || rs.length < rs.highWaterMark) {
        this._read(rs.highWaterMark);
      }
    }
    function Transform$2(options) {
      if (!(this instanceof Transform$2))
        return new Transform$2(options);
      Duplex$1.call(this, options);
      this._transformState = {
        afterTransform: afterTransform$1.bind(this),
        needTransform: false,
        transforming: false,
        writecb: null,
        writechunk: null,
        writeencoding: null
      };
      this._readableState.needReadable = true;
      this._readableState.sync = false;
      if (options) {
        if (typeof options.transform === "function")
          this._transform = options.transform;
        if (typeof options.flush === "function")
          this._flush = options.flush;
      }
      this.on("prefinish", prefinish$1);
    }
    function prefinish$1() {
      if (typeof this._flush === "function" && !this._readableState.destroyed) {
        this._flush((er, data) => {
          done$1(this, er, data);
        });
      } else {
        done$1(this, null, null);
      }
    }
    Transform$2.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex$1.prototype.push.call(this, chunk, encoding);
    };
    Transform$2.prototype._transform = function(chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
    };
    Transform$2.prototype._write = function(chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
          this._read(rs.highWaterMark);
      }
    };
    Transform$2.prototype._read = function(n) {
      var ts = this._transformState;
      if (ts.writechunk !== null && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        ts.needTransform = true;
      }
    };
    Transform$2.prototype._destroy = function(err, cb) {
      Duplex$1.prototype._destroy.call(this, err, (err2) => {
        cb(err2);
      });
    };
    function done$1(stream2, er, data) {
      if (er)
        return stream2.emit("error", er);
      if (data != null)
        stream2.push(data);
      if (stream2._writableState.length)
        throw new ERR_TRANSFORM_WITH_LENGTH_0();
      if (stream2._transformState.transforming)
        throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
      return stream2.push(null);
    }
    var _stream_passthrough = PassThrough$1;
    var Transform$1 = _stream_transform;
    require$$3$1(PassThrough$1, Transform$1);
    function PassThrough$1(options) {
      if (!(this instanceof PassThrough$1))
        return new PassThrough$1(options);
      Transform$1.call(this, options);
    }
    PassThrough$1.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
    var eos;
    function once(callback) {
      let called = false;
      return function() {
        if (called)
          return;
        called = true;
        callback(...arguments);
      };
    }
    var _require$codes = errorsBrowser.codes;
    var ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
    var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
    function noop$1(err) {
      if (err)
        throw err;
    }
    function isRequest(stream2) {
      return stream2.setHeader && typeof stream2.abort === "function";
    }
    function destroyer(stream2, reading, writing, callback) {
      callback = once(callback);
      let closed = false;
      stream2.on("close", () => {
        closed = true;
      });
      if (eos === void 0)
        eos = endOfStream;
      eos(stream2, {
        readable: reading,
        writable: writing
      }, (err) => {
        if (err)
          return callback(err);
        closed = true;
        callback();
      });
      let destroyed = false;
      return (err) => {
        if (closed)
          return;
        if (destroyed)
          return;
        destroyed = true;
        if (isRequest(stream2))
          return stream2.abort();
        if (typeof stream2.destroy === "function")
          return stream2.destroy();
        callback(err || new ERR_STREAM_DESTROYED("pipe"));
      };
    }
    function call(fn) {
      fn();
    }
    function pipe(from2, to) {
      return from2.pipe(to);
    }
    function popCallback(streams) {
      if (!streams.length)
        return noop$1;
      if (typeof streams[streams.length - 1] !== "function")
        return noop$1;
      return streams.pop();
    }
    function pipeline() {
      for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
        streams[_key] = arguments[_key];
      }
      const callback = popCallback(streams);
      if (Array.isArray(streams[0]))
        streams = streams[0];
      if (streams.length < 2) {
        throw new ERR_MISSING_ARGS("streams");
      }
      let error;
      const destroys = streams.map(function(stream2, i) {
        const reading = i < streams.length - 1;
        const writing = i > 0;
        return destroyer(stream2, reading, writing, function(err) {
          if (!error)
            error = err;
          if (err)
            destroys.forEach(call);
          if (reading)
            return;
          destroys.forEach(call);
          callback(error);
        });
      });
      return streams.reduce(pipe);
    }
    var pipeline_1 = pipeline;
    (function(module2, exports2) {
      exports2 = module2.exports = require_stream_readable();
      exports2.Stream = exports2;
      exports2.Readable = exports2;
      exports2.Writable = require_stream_writable();
      exports2.Duplex = require_stream_duplex();
      exports2.Transform = _stream_transform;
      exports2.PassThrough = _stream_passthrough;
      exports2.finished = endOfStream;
      exports2.pipeline = pipeline_1;
    })(readableBrowser, readableBrowserExports);
    var hashBase;
    var hasRequiredHashBase;
    function requireHashBase() {
      if (hasRequiredHashBase)
        return hashBase;
      hasRequiredHashBase = 1;
      var Buffer2 = safeBufferExports.Buffer;
      var Transform2 = readableBrowserExports.Transform;
      var inherits2 = require$$3$1;
      function throwIfNotStringOrBuffer(val, prefix) {
        if (!Buffer2.isBuffer(val) && typeof val !== "string") {
          throw new TypeError(prefix + " must be a string or a buffer");
        }
      }
      function HashBase(blockSize) {
        Transform2.call(this);
        this._block = Buffer2.allocUnsafe(blockSize);
        this._blockSize = blockSize;
        this._blockOffset = 0;
        this._length = [0, 0, 0, 0];
        this._finalized = false;
      }
      inherits2(HashBase, Transform2);
      HashBase.prototype._transform = function(chunk, encoding, callback) {
        var error = null;
        try {
          this.update(chunk, encoding);
        } catch (err) {
          error = err;
        }
        callback(error);
      };
      HashBase.prototype._flush = function(callback) {
        var error = null;
        try {
          this.push(this.digest());
        } catch (err) {
          error = err;
        }
        callback(error);
      };
      HashBase.prototype.update = function(data, encoding) {
        throwIfNotStringOrBuffer(data, "Data");
        if (this._finalized)
          throw new Error("Digest already called");
        if (!Buffer2.isBuffer(data))
          data = Buffer2.from(data, encoding);
        var block = this._block;
        var offset = 0;
        while (this._blockOffset + data.length - offset >= this._blockSize) {
          for (var i = this._blockOffset; i < this._blockSize; )
            block[i++] = data[offset++];
          this._update();
          this._blockOffset = 0;
        }
        while (offset < data.length)
          block[this._blockOffset++] = data[offset++];
        for (var j = 0, carry = data.length * 8; carry > 0; ++j) {
          this._length[j] += carry;
          carry = this._length[j] / 4294967296 | 0;
          if (carry > 0)
            this._length[j] -= 4294967296 * carry;
        }
        return this;
      };
      HashBase.prototype._update = function() {
        throw new Error("_update is not implemented");
      };
      HashBase.prototype.digest = function(encoding) {
        if (this._finalized)
          throw new Error("Digest already called");
        this._finalized = true;
        var digest = this._digest();
        if (encoding !== void 0)
          digest = digest.toString(encoding);
        this._block.fill(0);
        this._blockOffset = 0;
        for (var i = 0; i < 4; ++i)
          this._length[i] = 0;
        return digest;
      };
      HashBase.prototype._digest = function() {
        throw new Error("_digest is not implemented");
      };
      hashBase = HashBase;
      return hashBase;
    }
    var md5_js;
    var hasRequiredMd5_js;
    function requireMd5_js() {
      if (hasRequiredMd5_js)
        return md5_js;
      hasRequiredMd5_js = 1;
      var inherits2 = require$$3$1;
      var HashBase = requireHashBase();
      var Buffer2 = safeBufferExports.Buffer;
      var ARRAY16 = new Array(16);
      function MD5() {
        HashBase.call(this, 64);
        this._a = 1732584193;
        this._b = 4023233417;
        this._c = 2562383102;
        this._d = 271733878;
      }
      inherits2(MD5, HashBase);
      MD5.prototype._update = function() {
        var M = ARRAY16;
        for (var i = 0; i < 16; ++i)
          M[i] = this._block.readInt32LE(i * 4);
        var a = this._a;
        var b = this._b;
        var c = this._c;
        var d = this._d;
        a = fnF(a, b, c, d, M[0], 3614090360, 7);
        d = fnF(d, a, b, c, M[1], 3905402710, 12);
        c = fnF(c, d, a, b, M[2], 606105819, 17);
        b = fnF(b, c, d, a, M[3], 3250441966, 22);
        a = fnF(a, b, c, d, M[4], 4118548399, 7);
        d = fnF(d, a, b, c, M[5], 1200080426, 12);
        c = fnF(c, d, a, b, M[6], 2821735955, 17);
        b = fnF(b, c, d, a, M[7], 4249261313, 22);
        a = fnF(a, b, c, d, M[8], 1770035416, 7);
        d = fnF(d, a, b, c, M[9], 2336552879, 12);
        c = fnF(c, d, a, b, M[10], 4294925233, 17);
        b = fnF(b, c, d, a, M[11], 2304563134, 22);
        a = fnF(a, b, c, d, M[12], 1804603682, 7);
        d = fnF(d, a, b, c, M[13], 4254626195, 12);
        c = fnF(c, d, a, b, M[14], 2792965006, 17);
        b = fnF(b, c, d, a, M[15], 1236535329, 22);
        a = fnG(a, b, c, d, M[1], 4129170786, 5);
        d = fnG(d, a, b, c, M[6], 3225465664, 9);
        c = fnG(c, d, a, b, M[11], 643717713, 14);
        b = fnG(b, c, d, a, M[0], 3921069994, 20);
        a = fnG(a, b, c, d, M[5], 3593408605, 5);
        d = fnG(d, a, b, c, M[10], 38016083, 9);
        c = fnG(c, d, a, b, M[15], 3634488961, 14);
        b = fnG(b, c, d, a, M[4], 3889429448, 20);
        a = fnG(a, b, c, d, M[9], 568446438, 5);
        d = fnG(d, a, b, c, M[14], 3275163606, 9);
        c = fnG(c, d, a, b, M[3], 4107603335, 14);
        b = fnG(b, c, d, a, M[8], 1163531501, 20);
        a = fnG(a, b, c, d, M[13], 2850285829, 5);
        d = fnG(d, a, b, c, M[2], 4243563512, 9);
        c = fnG(c, d, a, b, M[7], 1735328473, 14);
        b = fnG(b, c, d, a, M[12], 2368359562, 20);
        a = fnH(a, b, c, d, M[5], 4294588738, 4);
        d = fnH(d, a, b, c, M[8], 2272392833, 11);
        c = fnH(c, d, a, b, M[11], 1839030562, 16);
        b = fnH(b, c, d, a, M[14], 4259657740, 23);
        a = fnH(a, b, c, d, M[1], 2763975236, 4);
        d = fnH(d, a, b, c, M[4], 1272893353, 11);
        c = fnH(c, d, a, b, M[7], 4139469664, 16);
        b = fnH(b, c, d, a, M[10], 3200236656, 23);
        a = fnH(a, b, c, d, M[13], 681279174, 4);
        d = fnH(d, a, b, c, M[0], 3936430074, 11);
        c = fnH(c, d, a, b, M[3], 3572445317, 16);
        b = fnH(b, c, d, a, M[6], 76029189, 23);
        a = fnH(a, b, c, d, M[9], 3654602809, 4);
        d = fnH(d, a, b, c, M[12], 3873151461, 11);
        c = fnH(c, d, a, b, M[15], 530742520, 16);
        b = fnH(b, c, d, a, M[2], 3299628645, 23);
        a = fnI(a, b, c, d, M[0], 4096336452, 6);
        d = fnI(d, a, b, c, M[7], 1126891415, 10);
        c = fnI(c, d, a, b, M[14], 2878612391, 15);
        b = fnI(b, c, d, a, M[5], 4237533241, 21);
        a = fnI(a, b, c, d, M[12], 1700485571, 6);
        d = fnI(d, a, b, c, M[3], 2399980690, 10);
        c = fnI(c, d, a, b, M[10], 4293915773, 15);
        b = fnI(b, c, d, a, M[1], 2240044497, 21);
        a = fnI(a, b, c, d, M[8], 1873313359, 6);
        d = fnI(d, a, b, c, M[15], 4264355552, 10);
        c = fnI(c, d, a, b, M[6], 2734768916, 15);
        b = fnI(b, c, d, a, M[13], 1309151649, 21);
        a = fnI(a, b, c, d, M[4], 4149444226, 6);
        d = fnI(d, a, b, c, M[11], 3174756917, 10);
        c = fnI(c, d, a, b, M[2], 718787259, 15);
        b = fnI(b, c, d, a, M[9], 3951481745, 21);
        this._a = this._a + a | 0;
        this._b = this._b + b | 0;
        this._c = this._c + c | 0;
        this._d = this._d + d | 0;
      };
      MD5.prototype._digest = function() {
        this._block[this._blockOffset++] = 128;
        if (this._blockOffset > 56) {
          this._block.fill(0, this._blockOffset, 64);
          this._update();
          this._blockOffset = 0;
        }
        this._block.fill(0, this._blockOffset, 56);
        this._block.writeUInt32LE(this._length[0], 56);
        this._block.writeUInt32LE(this._length[1], 60);
        this._update();
        var buffer2 = Buffer2.allocUnsafe(16);
        buffer2.writeInt32LE(this._a, 0);
        buffer2.writeInt32LE(this._b, 4);
        buffer2.writeInt32LE(this._c, 8);
        buffer2.writeInt32LE(this._d, 12);
        return buffer2;
      };
      function rotl(x, n) {
        return x << n | x >>> 32 - n;
      }
      function fnF(a, b, c, d, m, k, s) {
        return rotl(a + (b & c | ~b & d) + m + k | 0, s) + b | 0;
      }
      function fnG(a, b, c, d, m, k, s) {
        return rotl(a + (b & d | c & ~d) + m + k | 0, s) + b | 0;
      }
      function fnH(a, b, c, d, m, k, s) {
        return rotl(a + (b ^ c ^ d) + m + k | 0, s) + b | 0;
      }
      function fnI(a, b, c, d, m, k, s) {
        return rotl(a + (c ^ (b | ~d)) + m + k | 0, s) + b | 0;
      }
      md5_js = MD5;
      return md5_js;
    }
    var ripemd160;
    var hasRequiredRipemd160;
    function requireRipemd160() {
      if (hasRequiredRipemd160)
        return ripemd160;
      hasRequiredRipemd160 = 1;
      var Buffer2 = require$$6$1.Buffer;
      var inherits2 = require$$3$1;
      var HashBase = requireHashBase();
      var ARRAY16 = new Array(16);
      var zl = [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        7,
        4,
        13,
        1,
        10,
        6,
        15,
        3,
        12,
        0,
        9,
        5,
        2,
        14,
        11,
        8,
        3,
        10,
        14,
        4,
        9,
        15,
        8,
        1,
        2,
        7,
        0,
        6,
        13,
        11,
        5,
        12,
        1,
        9,
        11,
        10,
        0,
        8,
        12,
        4,
        13,
        3,
        7,
        15,
        14,
        5,
        6,
        2,
        4,
        0,
        5,
        9,
        7,
        12,
        2,
        10,
        14,
        1,
        3,
        8,
        11,
        6,
        15,
        13
      ];
      var zr = [
        5,
        14,
        7,
        0,
        9,
        2,
        11,
        4,
        13,
        6,
        15,
        8,
        1,
        10,
        3,
        12,
        6,
        11,
        3,
        7,
        0,
        13,
        5,
        10,
        14,
        15,
        8,
        12,
        4,
        9,
        1,
        2,
        15,
        5,
        1,
        3,
        7,
        14,
        6,
        9,
        11,
        8,
        12,
        2,
        10,
        0,
        4,
        13,
        8,
        6,
        4,
        1,
        3,
        11,
        15,
        0,
        5,
        12,
        2,
        13,
        9,
        7,
        10,
        14,
        12,
        15,
        10,
        4,
        1,
        5,
        8,
        7,
        6,
        2,
        13,
        14,
        0,
        3,
        9,
        11
      ];
      var sl = [
        11,
        14,
        15,
        12,
        5,
        8,
        7,
        9,
        11,
        13,
        14,
        15,
        6,
        7,
        9,
        8,
        7,
        6,
        8,
        13,
        11,
        9,
        7,
        15,
        7,
        12,
        15,
        9,
        11,
        7,
        13,
        12,
        11,
        13,
        6,
        7,
        14,
        9,
        13,
        15,
        14,
        8,
        13,
        6,
        5,
        12,
        7,
        5,
        11,
        12,
        14,
        15,
        14,
        15,
        9,
        8,
        9,
        14,
        5,
        6,
        8,
        6,
        5,
        12,
        9,
        15,
        5,
        11,
        6,
        8,
        13,
        12,
        5,
        12,
        13,
        14,
        11,
        8,
        5,
        6
      ];
      var sr = [
        8,
        9,
        9,
        11,
        13,
        15,
        15,
        5,
        7,
        7,
        8,
        11,
        14,
        14,
        12,
        6,
        9,
        13,
        15,
        7,
        12,
        8,
        9,
        11,
        7,
        7,
        12,
        7,
        6,
        15,
        13,
        11,
        9,
        7,
        15,
        11,
        8,
        6,
        6,
        14,
        12,
        13,
        5,
        14,
        13,
        13,
        7,
        5,
        15,
        5,
        8,
        11,
        14,
        14,
        6,
        14,
        6,
        9,
        12,
        9,
        12,
        5,
        15,
        8,
        8,
        5,
        12,
        9,
        12,
        5,
        14,
        6,
        8,
        13,
        6,
        5,
        15,
        13,
        11,
        11
      ];
      var hl = [0, 1518500249, 1859775393, 2400959708, 2840853838];
      var hr = [1352829926, 1548603684, 1836072691, 2053994217, 0];
      function RIPEMD160() {
        HashBase.call(this, 64);
        this._a = 1732584193;
        this._b = 4023233417;
        this._c = 2562383102;
        this._d = 271733878;
        this._e = 3285377520;
      }
      inherits2(RIPEMD160, HashBase);
      RIPEMD160.prototype._update = function() {
        var words = ARRAY16;
        for (var j = 0; j < 16; ++j)
          words[j] = this._block.readInt32LE(j * 4);
        var al = this._a | 0;
        var bl = this._b | 0;
        var cl = this._c | 0;
        var dl = this._d | 0;
        var el = this._e | 0;
        var ar = this._a | 0;
        var br = this._b | 0;
        var cr = this._c | 0;
        var dr = this._d | 0;
        var er = this._e | 0;
        for (var i = 0; i < 80; i += 1) {
          var tl;
          var tr;
          if (i < 16) {
            tl = fn1(al, bl, cl, dl, el, words[zl[i]], hl[0], sl[i]);
            tr = fn5(ar, br, cr, dr, er, words[zr[i]], hr[0], sr[i]);
          } else if (i < 32) {
            tl = fn2(al, bl, cl, dl, el, words[zl[i]], hl[1], sl[i]);
            tr = fn4(ar, br, cr, dr, er, words[zr[i]], hr[1], sr[i]);
          } else if (i < 48) {
            tl = fn3(al, bl, cl, dl, el, words[zl[i]], hl[2], sl[i]);
            tr = fn3(ar, br, cr, dr, er, words[zr[i]], hr[2], sr[i]);
          } else if (i < 64) {
            tl = fn4(al, bl, cl, dl, el, words[zl[i]], hl[3], sl[i]);
            tr = fn2(ar, br, cr, dr, er, words[zr[i]], hr[3], sr[i]);
          } else {
            tl = fn5(al, bl, cl, dl, el, words[zl[i]], hl[4], sl[i]);
            tr = fn1(ar, br, cr, dr, er, words[zr[i]], hr[4], sr[i]);
          }
          al = el;
          el = dl;
          dl = rotl(cl, 10);
          cl = bl;
          bl = tl;
          ar = er;
          er = dr;
          dr = rotl(cr, 10);
          cr = br;
          br = tr;
        }
        var t = this._b + cl + dr | 0;
        this._b = this._c + dl + er | 0;
        this._c = this._d + el + ar | 0;
        this._d = this._e + al + br | 0;
        this._e = this._a + bl + cr | 0;
        this._a = t;
      };
      RIPEMD160.prototype._digest = function() {
        this._block[this._blockOffset++] = 128;
        if (this._blockOffset > 56) {
          this._block.fill(0, this._blockOffset, 64);
          this._update();
          this._blockOffset = 0;
        }
        this._block.fill(0, this._blockOffset, 56);
        this._block.writeUInt32LE(this._length[0], 56);
        this._block.writeUInt32LE(this._length[1], 60);
        this._update();
        var buffer2 = Buffer2.alloc ? Buffer2.alloc(20) : new Buffer2(20);
        buffer2.writeInt32LE(this._a, 0);
        buffer2.writeInt32LE(this._b, 4);
        buffer2.writeInt32LE(this._c, 8);
        buffer2.writeInt32LE(this._d, 12);
        buffer2.writeInt32LE(this._e, 16);
        return buffer2;
      };
      function rotl(x, n) {
        return x << n | x >>> 32 - n;
      }
      function fn1(a, b, c, d, e, m, k, s) {
        return rotl(a + (b ^ c ^ d) + m + k | 0, s) + e | 0;
      }
      function fn2(a, b, c, d, e, m, k, s) {
        return rotl(a + (b & c | ~b & d) + m + k | 0, s) + e | 0;
      }
      function fn3(a, b, c, d, e, m, k, s) {
        return rotl(a + ((b | ~c) ^ d) + m + k | 0, s) + e | 0;
      }
      function fn4(a, b, c, d, e, m, k, s) {
        return rotl(a + (b & d | c & ~d) + m + k | 0, s) + e | 0;
      }
      function fn5(a, b, c, d, e, m, k, s) {
        return rotl(a + (b ^ (c | ~d)) + m + k | 0, s) + e | 0;
      }
      ripemd160 = RIPEMD160;
      return ripemd160;
    }
    var sha_jsExports = {};
    var sha_js = {
      get exports() {
        return sha_jsExports;
      },
      set exports(v2) {
        sha_jsExports = v2;
      }
    };
    var hash$1;
    var hasRequiredHash$1;
    function requireHash$1() {
      if (hasRequiredHash$1)
        return hash$1;
      hasRequiredHash$1 = 1;
      var Buffer2 = safeBufferExports.Buffer;
      function Hash(blockSize, finalSize) {
        this._block = Buffer2.alloc(blockSize);
        this._finalSize = finalSize;
        this._blockSize = blockSize;
        this._len = 0;
      }
      Hash.prototype.update = function(data, enc) {
        if (typeof data === "string") {
          enc = enc || "utf8";
          data = Buffer2.from(data, enc);
        }
        var block = this._block;
        var blockSize = this._blockSize;
        var length2 = data.length;
        var accum = this._len;
        for (var offset = 0; offset < length2; ) {
          var assigned = accum % blockSize;
          var remainder = Math.min(length2 - offset, blockSize - assigned);
          for (var i = 0; i < remainder; i++) {
            block[assigned + i] = data[offset + i];
          }
          accum += remainder;
          offset += remainder;
          if (accum % blockSize === 0) {
            this._update(block);
          }
        }
        this._len += length2;
        return this;
      };
      Hash.prototype.digest = function(enc) {
        var rem = this._len % this._blockSize;
        this._block[rem] = 128;
        this._block.fill(0, rem + 1);
        if (rem >= this._finalSize) {
          this._update(this._block);
          this._block.fill(0);
        }
        var bits = this._len * 8;
        if (bits <= 4294967295) {
          this._block.writeUInt32BE(bits, this._blockSize - 4);
        } else {
          var lowBits = (bits & 4294967295) >>> 0;
          var highBits = (bits - lowBits) / 4294967296;
          this._block.writeUInt32BE(highBits, this._blockSize - 8);
          this._block.writeUInt32BE(lowBits, this._blockSize - 4);
        }
        this._update(this._block);
        var hash2 = this._hash();
        return enc ? hash2.toString(enc) : hash2;
      };
      Hash.prototype._update = function() {
        throw new Error("_update must be implemented by subclass");
      };
      hash$1 = Hash;
      return hash$1;
    }
    var sha$1;
    var hasRequiredSha$1;
    function requireSha$1() {
      if (hasRequiredSha$1)
        return sha$1;
      hasRequiredSha$1 = 1;
      var inherits2 = require$$3$1;
      var Hash = requireHash$1();
      var Buffer2 = safeBufferExports.Buffer;
      var K = [
        1518500249,
        1859775393,
        2400959708 | 0,
        3395469782 | 0
      ];
      var W = new Array(80);
      function Sha() {
        this.init();
        this._w = W;
        Hash.call(this, 64, 56);
      }
      inherits2(Sha, Hash);
      Sha.prototype.init = function() {
        this._a = 1732584193;
        this._b = 4023233417;
        this._c = 2562383102;
        this._d = 271733878;
        this._e = 3285377520;
        return this;
      };
      function rotl5(num) {
        return num << 5 | num >>> 27;
      }
      function rotl30(num) {
        return num << 30 | num >>> 2;
      }
      function ft(s, b, c, d) {
        if (s === 0)
          return b & c | ~b & d;
        if (s === 2)
          return b & c | b & d | c & d;
        return b ^ c ^ d;
      }
      Sha.prototype._update = function(M) {
        var W2 = this._w;
        var a = this._a | 0;
        var b = this._b | 0;
        var c = this._c | 0;
        var d = this._d | 0;
        var e = this._e | 0;
        for (var i = 0; i < 16; ++i)
          W2[i] = M.readInt32BE(i * 4);
        for (; i < 80; ++i)
          W2[i] = W2[i - 3] ^ W2[i - 8] ^ W2[i - 14] ^ W2[i - 16];
        for (var j = 0; j < 80; ++j) {
          var s = ~~(j / 20);
          var t = rotl5(a) + ft(s, b, c, d) + e + W2[j] + K[s] | 0;
          e = d;
          d = c;
          c = rotl30(b);
          b = a;
          a = t;
        }
        this._a = a + this._a | 0;
        this._b = b + this._b | 0;
        this._c = c + this._c | 0;
        this._d = d + this._d | 0;
        this._e = e + this._e | 0;
      };
      Sha.prototype._hash = function() {
        var H = Buffer2.allocUnsafe(20);
        H.writeInt32BE(this._a | 0, 0);
        H.writeInt32BE(this._b | 0, 4);
        H.writeInt32BE(this._c | 0, 8);
        H.writeInt32BE(this._d | 0, 12);
        H.writeInt32BE(this._e | 0, 16);
        return H;
      };
      sha$1 = Sha;
      return sha$1;
    }
    var sha1;
    var hasRequiredSha1;
    function requireSha1() {
      if (hasRequiredSha1)
        return sha1;
      hasRequiredSha1 = 1;
      var inherits2 = require$$3$1;
      var Hash = requireHash$1();
      var Buffer2 = safeBufferExports.Buffer;
      var K = [
        1518500249,
        1859775393,
        2400959708 | 0,
        3395469782 | 0
      ];
      var W = new Array(80);
      function Sha1() {
        this.init();
        this._w = W;
        Hash.call(this, 64, 56);
      }
      inherits2(Sha1, Hash);
      Sha1.prototype.init = function() {
        this._a = 1732584193;
        this._b = 4023233417;
        this._c = 2562383102;
        this._d = 271733878;
        this._e = 3285377520;
        return this;
      };
      function rotl1(num) {
        return num << 1 | num >>> 31;
      }
      function rotl5(num) {
        return num << 5 | num >>> 27;
      }
      function rotl30(num) {
        return num << 30 | num >>> 2;
      }
      function ft(s, b, c, d) {
        if (s === 0)
          return b & c | ~b & d;
        if (s === 2)
          return b & c | b & d | c & d;
        return b ^ c ^ d;
      }
      Sha1.prototype._update = function(M) {
        var W2 = this._w;
        var a = this._a | 0;
        var b = this._b | 0;
        var c = this._c | 0;
        var d = this._d | 0;
        var e = this._e | 0;
        for (var i = 0; i < 16; ++i)
          W2[i] = M.readInt32BE(i * 4);
        for (; i < 80; ++i)
          W2[i] = rotl1(W2[i - 3] ^ W2[i - 8] ^ W2[i - 14] ^ W2[i - 16]);
        for (var j = 0; j < 80; ++j) {
          var s = ~~(j / 20);
          var t = rotl5(a) + ft(s, b, c, d) + e + W2[j] + K[s] | 0;
          e = d;
          d = c;
          c = rotl30(b);
          b = a;
          a = t;
        }
        this._a = a + this._a | 0;
        this._b = b + this._b | 0;
        this._c = c + this._c | 0;
        this._d = d + this._d | 0;
        this._e = e + this._e | 0;
      };
      Sha1.prototype._hash = function() {
        var H = Buffer2.allocUnsafe(20);
        H.writeInt32BE(this._a | 0, 0);
        H.writeInt32BE(this._b | 0, 4);
        H.writeInt32BE(this._c | 0, 8);
        H.writeInt32BE(this._d | 0, 12);
        H.writeInt32BE(this._e | 0, 16);
        return H;
      };
      sha1 = Sha1;
      return sha1;
    }
    var sha256$1;
    var hasRequiredSha256;
    function requireSha256() {
      if (hasRequiredSha256)
        return sha256$1;
      hasRequiredSha256 = 1;
      var inherits2 = require$$3$1;
      var Hash = requireHash$1();
      var Buffer2 = safeBufferExports.Buffer;
      var K = [
        1116352408,
        1899447441,
        3049323471,
        3921009573,
        961987163,
        1508970993,
        2453635748,
        2870763221,
        3624381080,
        310598401,
        607225278,
        1426881987,
        1925078388,
        2162078206,
        2614888103,
        3248222580,
        3835390401,
        4022224774,
        264347078,
        604807628,
        770255983,
        1249150122,
        1555081692,
        1996064986,
        2554220882,
        2821834349,
        2952996808,
        3210313671,
        3336571891,
        3584528711,
        113926993,
        338241895,
        666307205,
        773529912,
        1294757372,
        1396182291,
        1695183700,
        1986661051,
        2177026350,
        2456956037,
        2730485921,
        2820302411,
        3259730800,
        3345764771,
        3516065817,
        3600352804,
        4094571909,
        275423344,
        430227734,
        506948616,
        659060556,
        883997877,
        958139571,
        1322822218,
        1537002063,
        1747873779,
        1955562222,
        2024104815,
        2227730452,
        2361852424,
        2428436474,
        2756734187,
        3204031479,
        3329325298
      ];
      var W = new Array(64);
      function Sha256() {
        this.init();
        this._w = W;
        Hash.call(this, 64, 56);
      }
      inherits2(Sha256, Hash);
      Sha256.prototype.init = function() {
        this._a = 1779033703;
        this._b = 3144134277;
        this._c = 1013904242;
        this._d = 2773480762;
        this._e = 1359893119;
        this._f = 2600822924;
        this._g = 528734635;
        this._h = 1541459225;
        return this;
      };
      function ch(x, y, z) {
        return z ^ x & (y ^ z);
      }
      function maj(x, y, z) {
        return x & y | z & (x | y);
      }
      function sigma0(x) {
        return (x >>> 2 | x << 30) ^ (x >>> 13 | x << 19) ^ (x >>> 22 | x << 10);
      }
      function sigma1(x) {
        return (x >>> 6 | x << 26) ^ (x >>> 11 | x << 21) ^ (x >>> 25 | x << 7);
      }
      function gamma0(x) {
        return (x >>> 7 | x << 25) ^ (x >>> 18 | x << 14) ^ x >>> 3;
      }
      function gamma1(x) {
        return (x >>> 17 | x << 15) ^ (x >>> 19 | x << 13) ^ x >>> 10;
      }
      Sha256.prototype._update = function(M) {
        var W2 = this._w;
        var a = this._a | 0;
        var b = this._b | 0;
        var c = this._c | 0;
        var d = this._d | 0;
        var e = this._e | 0;
        var f = this._f | 0;
        var g = this._g | 0;
        var h = this._h | 0;
        for (var i = 0; i < 16; ++i)
          W2[i] = M.readInt32BE(i * 4);
        for (; i < 64; ++i)
          W2[i] = gamma1(W2[i - 2]) + W2[i - 7] + gamma0(W2[i - 15]) + W2[i - 16] | 0;
        for (var j = 0; j < 64; ++j) {
          var T1 = h + sigma1(e) + ch(e, f, g) + K[j] + W2[j] | 0;
          var T2 = sigma0(a) + maj(a, b, c) | 0;
          h = g;
          g = f;
          f = e;
          e = d + T1 | 0;
          d = c;
          c = b;
          b = a;
          a = T1 + T2 | 0;
        }
        this._a = a + this._a | 0;
        this._b = b + this._b | 0;
        this._c = c + this._c | 0;
        this._d = d + this._d | 0;
        this._e = e + this._e | 0;
        this._f = f + this._f | 0;
        this._g = g + this._g | 0;
        this._h = h + this._h | 0;
      };
      Sha256.prototype._hash = function() {
        var H = Buffer2.allocUnsafe(32);
        H.writeInt32BE(this._a, 0);
        H.writeInt32BE(this._b, 4);
        H.writeInt32BE(this._c, 8);
        H.writeInt32BE(this._d, 12);
        H.writeInt32BE(this._e, 16);
        H.writeInt32BE(this._f, 20);
        H.writeInt32BE(this._g, 24);
        H.writeInt32BE(this._h, 28);
        return H;
      };
      sha256$1 = Sha256;
      return sha256$1;
    }
    var sha224$1;
    var hasRequiredSha224;
    function requireSha224() {
      if (hasRequiredSha224)
        return sha224$1;
      hasRequiredSha224 = 1;
      var inherits2 = require$$3$1;
      var Sha256 = requireSha256();
      var Hash = requireHash$1();
      var Buffer2 = safeBufferExports.Buffer;
      var W = new Array(64);
      function Sha224() {
        this.init();
        this._w = W;
        Hash.call(this, 64, 56);
      }
      inherits2(Sha224, Sha256);
      Sha224.prototype.init = function() {
        this._a = 3238371032;
        this._b = 914150663;
        this._c = 812702999;
        this._d = 4144912697;
        this._e = 4290775857;
        this._f = 1750603025;
        this._g = 1694076839;
        this._h = 3204075428;
        return this;
      };
      Sha224.prototype._hash = function() {
        var H = Buffer2.allocUnsafe(28);
        H.writeInt32BE(this._a, 0);
        H.writeInt32BE(this._b, 4);
        H.writeInt32BE(this._c, 8);
        H.writeInt32BE(this._d, 12);
        H.writeInt32BE(this._e, 16);
        H.writeInt32BE(this._f, 20);
        H.writeInt32BE(this._g, 24);
        return H;
      };
      sha224$1 = Sha224;
      return sha224$1;
    }
    var sha512$1;
    var hasRequiredSha512;
    function requireSha512() {
      if (hasRequiredSha512)
        return sha512$1;
      hasRequiredSha512 = 1;
      var inherits2 = require$$3$1;
      var Hash = requireHash$1();
      var Buffer2 = safeBufferExports.Buffer;
      var K = [
        1116352408,
        3609767458,
        1899447441,
        602891725,
        3049323471,
        3964484399,
        3921009573,
        2173295548,
        961987163,
        4081628472,
        1508970993,
        3053834265,
        2453635748,
        2937671579,
        2870763221,
        3664609560,
        3624381080,
        2734883394,
        310598401,
        1164996542,
        607225278,
        1323610764,
        1426881987,
        3590304994,
        1925078388,
        4068182383,
        2162078206,
        991336113,
        2614888103,
        633803317,
        3248222580,
        3479774868,
        3835390401,
        2666613458,
        4022224774,
        944711139,
        264347078,
        2341262773,
        604807628,
        2007800933,
        770255983,
        1495990901,
        1249150122,
        1856431235,
        1555081692,
        3175218132,
        1996064986,
        2198950837,
        2554220882,
        3999719339,
        2821834349,
        766784016,
        2952996808,
        2566594879,
        3210313671,
        3203337956,
        3336571891,
        1034457026,
        3584528711,
        2466948901,
        113926993,
        3758326383,
        338241895,
        168717936,
        666307205,
        1188179964,
        773529912,
        1546045734,
        1294757372,
        1522805485,
        1396182291,
        2643833823,
        1695183700,
        2343527390,
        1986661051,
        1014477480,
        2177026350,
        1206759142,
        2456956037,
        344077627,
        2730485921,
        1290863460,
        2820302411,
        3158454273,
        3259730800,
        3505952657,
        3345764771,
        106217008,
        3516065817,
        3606008344,
        3600352804,
        1432725776,
        4094571909,
        1467031594,
        275423344,
        851169720,
        430227734,
        3100823752,
        506948616,
        1363258195,
        659060556,
        3750685593,
        883997877,
        3785050280,
        958139571,
        3318307427,
        1322822218,
        3812723403,
        1537002063,
        2003034995,
        1747873779,
        3602036899,
        1955562222,
        1575990012,
        2024104815,
        1125592928,
        2227730452,
        2716904306,
        2361852424,
        442776044,
        2428436474,
        593698344,
        2756734187,
        3733110249,
        3204031479,
        2999351573,
        3329325298,
        3815920427,
        3391569614,
        3928383900,
        3515267271,
        566280711,
        3940187606,
        3454069534,
        4118630271,
        4000239992,
        116418474,
        1914138554,
        174292421,
        2731055270,
        289380356,
        3203993006,
        460393269,
        320620315,
        685471733,
        587496836,
        852142971,
        1086792851,
        1017036298,
        365543100,
        1126000580,
        2618297676,
        1288033470,
        3409855158,
        1501505948,
        4234509866,
        1607167915,
        987167468,
        1816402316,
        1246189591
      ];
      var W = new Array(160);
      function Sha512() {
        this.init();
        this._w = W;
        Hash.call(this, 128, 112);
      }
      inherits2(Sha512, Hash);
      Sha512.prototype.init = function() {
        this._ah = 1779033703;
        this._bh = 3144134277;
        this._ch = 1013904242;
        this._dh = 2773480762;
        this._eh = 1359893119;
        this._fh = 2600822924;
        this._gh = 528734635;
        this._hh = 1541459225;
        this._al = 4089235720;
        this._bl = 2227873595;
        this._cl = 4271175723;
        this._dl = 1595750129;
        this._el = 2917565137;
        this._fl = 725511199;
        this._gl = 4215389547;
        this._hl = 327033209;
        return this;
      };
      function Ch(x, y, z) {
        return z ^ x & (y ^ z);
      }
      function maj(x, y, z) {
        return x & y | z & (x | y);
      }
      function sigma0(x, xl) {
        return (x >>> 28 | xl << 4) ^ (xl >>> 2 | x << 30) ^ (xl >>> 7 | x << 25);
      }
      function sigma1(x, xl) {
        return (x >>> 14 | xl << 18) ^ (x >>> 18 | xl << 14) ^ (xl >>> 9 | x << 23);
      }
      function Gamma0(x, xl) {
        return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ x >>> 7;
      }
      function Gamma0l(x, xl) {
        return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7 | xl << 25);
      }
      function Gamma1(x, xl) {
        return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ x >>> 6;
      }
      function Gamma1l(x, xl) {
        return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6 | xl << 26);
      }
      function getCarry(a, b) {
        return a >>> 0 < b >>> 0 ? 1 : 0;
      }
      Sha512.prototype._update = function(M) {
        var W2 = this._w;
        var ah = this._ah | 0;
        var bh = this._bh | 0;
        var ch = this._ch | 0;
        var dh2 = this._dh | 0;
        var eh = this._eh | 0;
        var fh = this._fh | 0;
        var gh = this._gh | 0;
        var hh = this._hh | 0;
        var al = this._al | 0;
        var bl = this._bl | 0;
        var cl = this._cl | 0;
        var dl = this._dl | 0;
        var el = this._el | 0;
        var fl = this._fl | 0;
        var gl = this._gl | 0;
        var hl = this._hl | 0;
        for (var i = 0; i < 32; i += 2) {
          W2[i] = M.readInt32BE(i * 4);
          W2[i + 1] = M.readInt32BE(i * 4 + 4);
        }
        for (; i < 160; i += 2) {
          var xh = W2[i - 15 * 2];
          var xl = W2[i - 15 * 2 + 1];
          var gamma0 = Gamma0(xh, xl);
          var gamma0l = Gamma0l(xl, xh);
          xh = W2[i - 2 * 2];
          xl = W2[i - 2 * 2 + 1];
          var gamma1 = Gamma1(xh, xl);
          var gamma1l = Gamma1l(xl, xh);
          var Wi7h = W2[i - 7 * 2];
          var Wi7l = W2[i - 7 * 2 + 1];
          var Wi16h = W2[i - 16 * 2];
          var Wi16l = W2[i - 16 * 2 + 1];
          var Wil = gamma0l + Wi7l | 0;
          var Wih = gamma0 + Wi7h + getCarry(Wil, gamma0l) | 0;
          Wil = Wil + gamma1l | 0;
          Wih = Wih + gamma1 + getCarry(Wil, gamma1l) | 0;
          Wil = Wil + Wi16l | 0;
          Wih = Wih + Wi16h + getCarry(Wil, Wi16l) | 0;
          W2[i] = Wih;
          W2[i + 1] = Wil;
        }
        for (var j = 0; j < 160; j += 2) {
          Wih = W2[j];
          Wil = W2[j + 1];
          var majh = maj(ah, bh, ch);
          var majl = maj(al, bl, cl);
          var sigma0h = sigma0(ah, al);
          var sigma0l = sigma0(al, ah);
          var sigma1h = sigma1(eh, el);
          var sigma1l = sigma1(el, eh);
          var Kih = K[j];
          var Kil = K[j + 1];
          var chh = Ch(eh, fh, gh);
          var chl = Ch(el, fl, gl);
          var t1l = hl + sigma1l | 0;
          var t1h = hh + sigma1h + getCarry(t1l, hl) | 0;
          t1l = t1l + chl | 0;
          t1h = t1h + chh + getCarry(t1l, chl) | 0;
          t1l = t1l + Kil | 0;
          t1h = t1h + Kih + getCarry(t1l, Kil) | 0;
          t1l = t1l + Wil | 0;
          t1h = t1h + Wih + getCarry(t1l, Wil) | 0;
          var t2l = sigma0l + majl | 0;
          var t2h = sigma0h + majh + getCarry(t2l, sigma0l) | 0;
          hh = gh;
          hl = gl;
          gh = fh;
          gl = fl;
          fh = eh;
          fl = el;
          el = dl + t1l | 0;
          eh = dh2 + t1h + getCarry(el, dl) | 0;
          dh2 = ch;
          dl = cl;
          ch = bh;
          cl = bl;
          bh = ah;
          bl = al;
          al = t1l + t2l | 0;
          ah = t1h + t2h + getCarry(al, t1l) | 0;
        }
        this._al = this._al + al | 0;
        this._bl = this._bl + bl | 0;
        this._cl = this._cl + cl | 0;
        this._dl = this._dl + dl | 0;
        this._el = this._el + el | 0;
        this._fl = this._fl + fl | 0;
        this._gl = this._gl + gl | 0;
        this._hl = this._hl + hl | 0;
        this._ah = this._ah + ah + getCarry(this._al, al) | 0;
        this._bh = this._bh + bh + getCarry(this._bl, bl) | 0;
        this._ch = this._ch + ch + getCarry(this._cl, cl) | 0;
        this._dh = this._dh + dh2 + getCarry(this._dl, dl) | 0;
        this._eh = this._eh + eh + getCarry(this._el, el) | 0;
        this._fh = this._fh + fh + getCarry(this._fl, fl) | 0;
        this._gh = this._gh + gh + getCarry(this._gl, gl) | 0;
        this._hh = this._hh + hh + getCarry(this._hl, hl) | 0;
      };
      Sha512.prototype._hash = function() {
        var H = Buffer2.allocUnsafe(64);
        function writeInt64BE(h, l, offset) {
          H.writeInt32BE(h, offset);
          H.writeInt32BE(l, offset + 4);
        }
        writeInt64BE(this._ah, this._al, 0);
        writeInt64BE(this._bh, this._bl, 8);
        writeInt64BE(this._ch, this._cl, 16);
        writeInt64BE(this._dh, this._dl, 24);
        writeInt64BE(this._eh, this._el, 32);
        writeInt64BE(this._fh, this._fl, 40);
        writeInt64BE(this._gh, this._gl, 48);
        writeInt64BE(this._hh, this._hl, 56);
        return H;
      };
      sha512$1 = Sha512;
      return sha512$1;
    }
    var sha384$1;
    var hasRequiredSha384;
    function requireSha384() {
      if (hasRequiredSha384)
        return sha384$1;
      hasRequiredSha384 = 1;
      var inherits2 = require$$3$1;
      var SHA512 = requireSha512();
      var Hash = requireHash$1();
      var Buffer2 = safeBufferExports.Buffer;
      var W = new Array(160);
      function Sha384() {
        this.init();
        this._w = W;
        Hash.call(this, 128, 112);
      }
      inherits2(Sha384, SHA512);
      Sha384.prototype.init = function() {
        this._ah = 3418070365;
        this._bh = 1654270250;
        this._ch = 2438529370;
        this._dh = 355462360;
        this._eh = 1731405415;
        this._fh = 2394180231;
        this._gh = 3675008525;
        this._hh = 1203062813;
        this._al = 3238371032;
        this._bl = 914150663;
        this._cl = 812702999;
        this._dl = 4144912697;
        this._el = 4290775857;
        this._fl = 1750603025;
        this._gl = 1694076839;
        this._hl = 3204075428;
        return this;
      };
      Sha384.prototype._hash = function() {
        var H = Buffer2.allocUnsafe(48);
        function writeInt64BE(h, l, offset) {
          H.writeInt32BE(h, offset);
          H.writeInt32BE(l, offset + 4);
        }
        writeInt64BE(this._ah, this._al, 0);
        writeInt64BE(this._bh, this._bl, 8);
        writeInt64BE(this._ch, this._cl, 16);
        writeInt64BE(this._dh, this._dl, 24);
        writeInt64BE(this._eh, this._el, 32);
        writeInt64BE(this._fh, this._fl, 40);
        return H;
      };
      sha384$1 = Sha384;
      return sha384$1;
    }
    var hasRequiredSha_js;
    function requireSha_js() {
      if (hasRequiredSha_js)
        return sha_jsExports;
      hasRequiredSha_js = 1;
      var exports2 = sha_js.exports = function SHA(algorithm) {
        algorithm = algorithm.toLowerCase();
        var Algorithm = exports2[algorithm];
        if (!Algorithm)
          throw new Error(algorithm + " is not supported (we accept pull requests)");
        return new Algorithm();
      };
      exports2.sha = requireSha$1();
      exports2.sha1 = requireSha1();
      exports2.sha224 = requireSha224();
      exports2.sha256 = requireSha256();
      exports2.sha384 = requireSha384();
      exports2.sha512 = requireSha512();
      return sha_jsExports;
    }
    function BufferList() {
      this.head = null;
      this.tail = null;
      this.length = 0;
    }
    BufferList.prototype.push = function(v2) {
      var entry = {data: v2, next: null};
      if (this.length > 0)
        this.tail.next = entry;
      else
        this.head = entry;
      this.tail = entry;
      ++this.length;
    };
    BufferList.prototype.unshift = function(v2) {
      var entry = {data: v2, next: this.head};
      if (this.length === 0)
        this.tail = entry;
      this.head = entry;
      ++this.length;
    };
    BufferList.prototype.shift = function() {
      if (this.length === 0)
        return;
      var ret = this.head.data;
      if (this.length === 1)
        this.head = this.tail = null;
      else
        this.head = this.head.next;
      --this.length;
      return ret;
    };
    BufferList.prototype.clear = function() {
      this.head = this.tail = null;
      this.length = 0;
    };
    BufferList.prototype.join = function(s) {
      if (this.length === 0)
        return "";
      var p = this.head;
      var ret = "" + p.data;
      while (p = p.next) {
        ret += s + p.data;
      }
      return ret;
    };
    BufferList.prototype.concat = function(n) {
      if (this.length === 0)
        return Buffer$3.alloc(0);
      if (this.length === 1)
        return this.head.data;
      var ret = Buffer$3.allocUnsafe(n >>> 0);
      var p = this.head;
      var i = 0;
      while (p) {
        p.data.copy(ret, i);
        i += p.data.length;
        p = p.next;
      }
      return ret;
    };
    Readable.ReadableState = ReadableState;
    var debug$1 = debuglog("stream");
    inherits$1(Readable, EventEmitter);
    function prependListener(emitter, event, fn) {
      if (typeof emitter.prependListener === "function") {
        return emitter.prependListener(event, fn);
      } else {
        if (!emitter._events || !emitter._events[event])
          emitter.on(event, fn);
        else if (Array.isArray(emitter._events[event]))
          emitter._events[event].unshift(fn);
        else
          emitter._events[event] = [fn, emitter._events[event]];
      }
    }
    function listenerCount(emitter, type) {
      return emitter.listeners(type).length;
    }
    function ReadableState(options, stream2) {
      options = options || {};
      this.objectMode = !!options.objectMode;
      if (stream2 instanceof Duplex)
        this.objectMode = this.objectMode || !!options.readableObjectMode;
      var hwm = options.highWaterMark;
      var defaultHwm = this.objectMode ? 16 : 16 * 1024;
      this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;
      this.highWaterMark = ~~this.highWaterMark;
      this.buffer = new BufferList();
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
      this.sync = true;
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.resumeScheduled = false;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.ranOut = false;
      this.awaitDrain = 0;
      this.readingMore = false;
      this.decoder = null;
      this.encoding = null;
      if (options.encoding) {
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
      }
    }
    function Readable(options) {
      if (!(this instanceof Readable))
        return new Readable(options);
      this._readableState = new ReadableState(options, this);
      this.readable = true;
      if (options && typeof options.read === "function")
        this._read = options.read;
      EventEmitter.call(this);
    }
    Readable.prototype.push = function(chunk, encoding) {
      var state2 = this._readableState;
      if (!state2.objectMode && typeof chunk === "string") {
        encoding = encoding || state2.defaultEncoding;
        if (encoding !== state2.encoding) {
          chunk = Buffer$3.from(chunk, encoding);
          encoding = "";
        }
      }
      return readableAddChunk(this, state2, chunk, encoding, false);
    };
    Readable.prototype.unshift = function(chunk) {
      var state2 = this._readableState;
      return readableAddChunk(this, state2, chunk, "", true);
    };
    Readable.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    function readableAddChunk(stream2, state2, chunk, encoding, addToFront) {
      var er = chunkInvalid(state2, chunk);
      if (er) {
        stream2.emit("error", er);
      } else if (chunk === null) {
        state2.reading = false;
        onEofChunk(stream2, state2);
      } else if (state2.objectMode || chunk && chunk.length > 0) {
        if (state2.ended && !addToFront) {
          var e = new Error("stream.push() after EOF");
          stream2.emit("error", e);
        } else if (state2.endEmitted && addToFront) {
          var _e = new Error("stream.unshift() after end event");
          stream2.emit("error", _e);
        } else {
          var skipAdd;
          if (state2.decoder && !addToFront && !encoding) {
            chunk = state2.decoder.write(chunk);
            skipAdd = !state2.objectMode && chunk.length === 0;
          }
          if (!addToFront)
            state2.reading = false;
          if (!skipAdd) {
            if (state2.flowing && state2.length === 0 && !state2.sync) {
              stream2.emit("data", chunk);
              stream2.read(0);
            } else {
              state2.length += state2.objectMode ? 1 : chunk.length;
              if (addToFront)
                state2.buffer.unshift(chunk);
              else
                state2.buffer.push(chunk);
              if (state2.needReadable)
                emitReadable(stream2);
            }
          }
          maybeReadMore(stream2, state2);
        }
      } else if (!addToFront) {
        state2.reading = false;
      }
      return needMoreData(state2);
    }
    function needMoreData(state2) {
      return !state2.ended && (state2.needReadable || state2.length < state2.highWaterMark || state2.length === 0);
    }
    Readable.prototype.setEncoding = function(enc) {
      this._readableState.decoder = new StringDecoder(enc);
      this._readableState.encoding = enc;
      return this;
    };
    var MAX_HWM = 8388608;
    function computeNewHighWaterMark(n) {
      if (n >= MAX_HWM) {
        n = MAX_HWM;
      } else {
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
      }
      return n;
    }
    function howMuchToRead(n, state2) {
      if (n <= 0 || state2.length === 0 && state2.ended)
        return 0;
      if (state2.objectMode)
        return 1;
      if (n !== n) {
        if (state2.flowing && state2.length)
          return state2.buffer.head.data.length;
        else
          return state2.length;
      }
      if (n > state2.highWaterMark)
        state2.highWaterMark = computeNewHighWaterMark(n);
      if (n <= state2.length)
        return n;
      if (!state2.ended) {
        state2.needReadable = true;
        return 0;
      }
      return state2.length;
    }
    Readable.prototype.read = function(n) {
      debug$1("read", n);
      n = parseInt(n, 10);
      var state2 = this._readableState;
      var nOrig = n;
      if (n !== 0)
        state2.emittedReadable = false;
      if (n === 0 && state2.needReadable && (state2.length >= state2.highWaterMark || state2.ended)) {
        debug$1("read: emitReadable", state2.length, state2.ended);
        if (state2.length === 0 && state2.ended)
          endReadable(this);
        else
          emitReadable(this);
        return null;
      }
      n = howMuchToRead(n, state2);
      if (n === 0 && state2.ended) {
        if (state2.length === 0)
          endReadable(this);
        return null;
      }
      var doRead = state2.needReadable;
      debug$1("need readable", doRead);
      if (state2.length === 0 || state2.length - n < state2.highWaterMark) {
        doRead = true;
        debug$1("length less than watermark", doRead);
      }
      if (state2.ended || state2.reading) {
        doRead = false;
        debug$1("reading or ended", doRead);
      } else if (doRead) {
        debug$1("do read");
        state2.reading = true;
        state2.sync = true;
        if (state2.length === 0)
          state2.needReadable = true;
        this._read(state2.highWaterMark);
        state2.sync = false;
        if (!state2.reading)
          n = howMuchToRead(nOrig, state2);
      }
      var ret;
      if (n > 0)
        ret = fromList(n, state2);
      else
        ret = null;
      if (ret === null) {
        state2.needReadable = true;
        n = 0;
      } else {
        state2.length -= n;
      }
      if (state2.length === 0) {
        if (!state2.ended)
          state2.needReadable = true;
        if (nOrig !== n && state2.ended)
          endReadable(this);
      }
      if (ret !== null)
        this.emit("data", ret);
      return ret;
    };
    function chunkInvalid(state2, chunk) {
      var er = null;
      if (!Buffer$3.isBuffer(chunk) && typeof chunk !== "string" && chunk !== null && chunk !== void 0 && !state2.objectMode) {
        er = new TypeError("Invalid non-string/buffer chunk");
      }
      return er;
    }
    function onEofChunk(stream2, state2) {
      if (state2.ended)
        return;
      if (state2.decoder) {
        var chunk = state2.decoder.end();
        if (chunk && chunk.length) {
          state2.buffer.push(chunk);
          state2.length += state2.objectMode ? 1 : chunk.length;
        }
      }
      state2.ended = true;
      emitReadable(stream2);
    }
    function emitReadable(stream2) {
      var state2 = stream2._readableState;
      state2.needReadable = false;
      if (!state2.emittedReadable) {
        debug$1("emitReadable", state2.flowing);
        state2.emittedReadable = true;
        if (state2.sync)
          nextTick(emitReadable_, stream2);
        else
          emitReadable_(stream2);
      }
    }
    function emitReadable_(stream2) {
      debug$1("emit readable");
      stream2.emit("readable");
      flow(stream2);
    }
    function maybeReadMore(stream2, state2) {
      if (!state2.readingMore) {
        state2.readingMore = true;
        nextTick(maybeReadMore_, stream2, state2);
      }
    }
    function maybeReadMore_(stream2, state2) {
      var len = state2.length;
      while (!state2.reading && !state2.flowing && !state2.ended && state2.length < state2.highWaterMark) {
        debug$1("maybeReadMore read 0");
        stream2.read(0);
        if (len === state2.length)
          break;
        else
          len = state2.length;
      }
      state2.readingMore = false;
    }
    Readable.prototype._read = function(n) {
      this.emit("error", new Error("not implemented"));
    };
    Readable.prototype.pipe = function(dest, pipeOpts) {
      var src2 = this;
      var state2 = this._readableState;
      switch (state2.pipesCount) {
        case 0:
          state2.pipes = dest;
          break;
        case 1:
          state2.pipes = [state2.pipes, dest];
          break;
        default:
          state2.pipes.push(dest);
          break;
      }
      state2.pipesCount += 1;
      debug$1("pipe count=%d opts=%j", state2.pipesCount, pipeOpts);
      var doEnd = !pipeOpts || pipeOpts.end !== false;
      var endFn = doEnd ? onend2 : cleanup;
      if (state2.endEmitted)
        nextTick(endFn);
      else
        src2.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable) {
        debug$1("onunpipe");
        if (readable === src2) {
          cleanup();
        }
      }
      function onend2() {
        debug$1("onend");
        dest.end();
      }
      var ondrain = pipeOnDrain(src2);
      dest.on("drain", ondrain);
      var cleanedUp = false;
      function cleanup() {
        debug$1("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src2.removeListener("end", onend2);
        src2.removeListener("end", cleanup);
        src2.removeListener("data", ondata);
        cleanedUp = true;
        if (state2.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
          ondrain();
      }
      var increasedAwaitDrain = false;
      src2.on("data", ondata);
      function ondata(chunk) {
        debug$1("ondata");
        increasedAwaitDrain = false;
        var ret = dest.write(chunk);
        if (ret === false && !increasedAwaitDrain) {
          if ((state2.pipesCount === 1 && state2.pipes === dest || state2.pipesCount > 1 && indexOf(state2.pipes, dest) !== -1) && !cleanedUp) {
            debug$1("false write response, pause", src2._readableState.awaitDrain);
            src2._readableState.awaitDrain++;
            increasedAwaitDrain = true;
          }
          src2.pause();
        }
      }
      function onerror(er) {
        debug$1("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (listenerCount(dest, "error") === 0)
          dest.emit("error", er);
      }
      prependListener(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug$1("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug$1("unpipe");
        src2.unpipe(dest);
      }
      dest.emit("pipe", src2);
      if (!state2.flowing) {
        debug$1("pipe resume");
        src2.resume();
      }
      return dest;
    };
    function pipeOnDrain(src2) {
      return function() {
        var state2 = src2._readableState;
        debug$1("pipeOnDrain", state2.awaitDrain);
        if (state2.awaitDrain)
          state2.awaitDrain--;
        if (state2.awaitDrain === 0 && src2.listeners("data").length) {
          state2.flowing = true;
          flow(src2);
        }
      };
    }
    Readable.prototype.unpipe = function(dest) {
      var state2 = this._readableState;
      if (state2.pipesCount === 0)
        return this;
      if (state2.pipesCount === 1) {
        if (dest && dest !== state2.pipes)
          return this;
        if (!dest)
          dest = state2.pipes;
        state2.pipes = null;
        state2.pipesCount = 0;
        state2.flowing = false;
        if (dest)
          dest.emit("unpipe", this);
        return this;
      }
      if (!dest) {
        var dests = state2.pipes;
        var len = state2.pipesCount;
        state2.pipes = null;
        state2.pipesCount = 0;
        state2.flowing = false;
        for (var _i = 0; _i < len; _i++) {
          dests[_i].emit("unpipe", this);
        }
        return this;
      }
      var i = indexOf(state2.pipes, dest);
      if (i === -1)
        return this;
      state2.pipes.splice(i, 1);
      state2.pipesCount -= 1;
      if (state2.pipesCount === 1)
        state2.pipes = state2.pipes[0];
      dest.emit("unpipe", this);
      return this;
    };
    Readable.prototype.on = function(ev, fn) {
      var res = EventEmitter.prototype.on.call(this, ev, fn);
      if (ev === "data") {
        if (this._readableState.flowing !== false)
          this.resume();
      } else if (ev === "readable") {
        var state2 = this._readableState;
        if (!state2.endEmitted && !state2.readableListening) {
          state2.readableListening = state2.needReadable = true;
          state2.emittedReadable = false;
          if (!state2.reading) {
            nextTick(nReadingNextTick, this);
          } else if (state2.length) {
            emitReadable(this);
          }
        }
      }
      return res;
    };
    Readable.prototype.addListener = Readable.prototype.on;
    function nReadingNextTick(self2) {
      debug$1("readable nexttick read 0");
      self2.read(0);
    }
    Readable.prototype.resume = function() {
      var state2 = this._readableState;
      if (!state2.flowing) {
        debug$1("resume");
        state2.flowing = true;
        resume(this, state2);
      }
      return this;
    };
    function resume(stream2, state2) {
      if (!state2.resumeScheduled) {
        state2.resumeScheduled = true;
        nextTick(resume_, stream2, state2);
      }
    }
    function resume_(stream2, state2) {
      if (!state2.reading) {
        debug$1("resume read 0");
        stream2.read(0);
      }
      state2.resumeScheduled = false;
      state2.awaitDrain = 0;
      stream2.emit("resume");
      flow(stream2);
      if (state2.flowing && !state2.reading)
        stream2.read(0);
    }
    Readable.prototype.pause = function() {
      debug$1("call pause flowing=%j", this._readableState.flowing);
      if (this._readableState.flowing !== false) {
        debug$1("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      return this;
    };
    function flow(stream2) {
      var state2 = stream2._readableState;
      debug$1("flow", state2.flowing);
      while (state2.flowing && stream2.read() !== null) {
      }
    }
    Readable.prototype.wrap = function(stream2) {
      var state2 = this._readableState;
      var paused = false;
      var self2 = this;
      stream2.on("end", function() {
        debug$1("wrapped end");
        if (state2.decoder && !state2.ended) {
          var chunk = state2.decoder.end();
          if (chunk && chunk.length)
            self2.push(chunk);
        }
        self2.push(null);
      });
      stream2.on("data", function(chunk) {
        debug$1("wrapped data");
        if (state2.decoder)
          chunk = state2.decoder.write(chunk);
        if (state2.objectMode && (chunk === null || chunk === void 0))
          return;
        else if (!state2.objectMode && (!chunk || !chunk.length))
          return;
        var ret = self2.push(chunk);
        if (!ret) {
          paused = true;
          stream2.pause();
        }
      });
      for (var i in stream2) {
        if (this[i] === void 0 && typeof stream2[i] === "function") {
          this[i] = function(method2) {
            return function() {
              return stream2[method2].apply(stream2, arguments);
            };
          }(i);
        }
      }
      var events = ["error", "close", "destroy", "pause", "resume"];
      forEach(events, function(ev) {
        stream2.on(ev, self2.emit.bind(self2, ev));
      });
      self2._read = function(n) {
        debug$1("wrapped _read", n);
        if (paused) {
          paused = false;
          stream2.resume();
        }
      };
      return self2;
    };
    Readable._fromList = fromList;
    function fromList(n, state2) {
      if (state2.length === 0)
        return null;
      var ret;
      if (state2.objectMode)
        ret = state2.buffer.shift();
      else if (!n || n >= state2.length) {
        if (state2.decoder)
          ret = state2.buffer.join("");
        else if (state2.buffer.length === 1)
          ret = state2.buffer.head.data;
        else
          ret = state2.buffer.concat(state2.length);
        state2.buffer.clear();
      } else {
        ret = fromListPartial(n, state2.buffer, state2.decoder);
      }
      return ret;
    }
    function fromListPartial(n, list, hasStrings) {
      var ret;
      if (n < list.head.data.length) {
        ret = list.head.data.slice(0, n);
        list.head.data = list.head.data.slice(n);
      } else if (n === list.head.data.length) {
        ret = list.shift();
      } else {
        ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
      }
      return ret;
    }
    function copyFromBufferString(n, list) {
      var p = list.head;
      var c = 1;
      var ret = p.data;
      n -= ret.length;
      while (p = p.next) {
        var str = p.data;
        var nb = n > str.length ? str.length : n;
        if (nb === str.length)
          ret += str;
        else
          ret += str.slice(0, n);
        n -= nb;
        if (n === 0) {
          if (nb === str.length) {
            ++c;
            if (p.next)
              list.head = p.next;
            else
              list.head = list.tail = null;
          } else {
            list.head = p;
            p.data = str.slice(nb);
          }
          break;
        }
        ++c;
      }
      list.length -= c;
      return ret;
    }
    function copyFromBuffer(n, list) {
      var ret = Buffer$3.allocUnsafe(n);
      var p = list.head;
      var c = 1;
      p.data.copy(ret);
      n -= p.data.length;
      while (p = p.next) {
        var buf2 = p.data;
        var nb = n > buf2.length ? buf2.length : n;
        buf2.copy(ret, ret.length - n, 0, nb);
        n -= nb;
        if (n === 0) {
          if (nb === buf2.length) {
            ++c;
            if (p.next)
              list.head = p.next;
            else
              list.head = list.tail = null;
          } else {
            list.head = p;
            p.data = buf2.slice(nb);
          }
          break;
        }
        ++c;
      }
      list.length -= c;
      return ret;
    }
    function endReadable(stream2) {
      var state2 = stream2._readableState;
      if (state2.length > 0)
        throw new Error('"endReadable()" called on non-empty stream');
      if (!state2.endEmitted) {
        state2.ended = true;
        nextTick(endReadableNT, state2, stream2);
      }
    }
    function endReadableNT(state2, stream2) {
      if (!state2.endEmitted && state2.length === 0) {
        state2.endEmitted = true;
        stream2.readable = false;
        stream2.emit("end");
      }
    }
    function forEach(xs, f) {
      for (var i = 0, l = xs.length; i < l; i++) {
        f(xs[i], i);
      }
    }
    function indexOf(xs, x) {
      for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x)
          return i;
      }
      return -1;
    }
    Writable.WritableState = WritableState;
    inherits$1(Writable, EventEmitter);
    function nop() {
    }
    function WriteReq(chunk, encoding, cb) {
      this.chunk = chunk;
      this.encoding = encoding;
      this.callback = cb;
      this.next = null;
    }
    function WritableState(options, stream2) {
      Object.defineProperty(this, "buffer", {
        get: deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.")
      });
      options = options || {};
      this.objectMode = !!options.objectMode;
      if (stream2 instanceof Duplex)
        this.objectMode = this.objectMode || !!options.writableObjectMode;
      var hwm = options.highWaterMark;
      var defaultHwm = this.objectMode ? 16 : 16 * 1024;
      this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;
      this.highWaterMark = ~~this.highWaterMark;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      var noDecode = options.decodeStrings === false;
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = function(er) {
        onwrite(stream2, er);
      };
      this.writecb = null;
      this.writelen = 0;
      this.bufferedRequest = null;
      this.lastBufferedRequest = null;
      this.pendingcb = 0;
      this.prefinished = false;
      this.errorEmitted = false;
      this.bufferedRequestCount = 0;
      this.corkedRequestsFree = new CorkedRequest(this);
    }
    WritableState.prototype.getBuffer = function writableStateGetBuffer() {
      var current = this.bufferedRequest;
      var out = [];
      while (current) {
        out.push(current);
        current = current.next;
      }
      return out;
    };
    function Writable(options) {
      if (!(this instanceof Writable) && !(this instanceof Duplex))
        return new Writable(options);
      this._writableState = new WritableState(options, this);
      this.writable = true;
      if (options) {
        if (typeof options.write === "function")
          this._write = options.write;
        if (typeof options.writev === "function")
          this._writev = options.writev;
      }
      EventEmitter.call(this);
    }
    Writable.prototype.pipe = function() {
      this.emit("error", new Error("Cannot pipe, not readable"));
    };
    function writeAfterEnd(stream2, cb) {
      var er = new Error("write after end");
      stream2.emit("error", er);
      nextTick(cb, er);
    }
    function validChunk(stream2, state2, chunk, cb) {
      var valid = true;
      var er = false;
      if (chunk === null) {
        er = new TypeError("May not write null values to stream");
      } else if (!Buffer$3.isBuffer(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state2.objectMode) {
        er = new TypeError("Invalid non-string/buffer chunk");
      }
      if (er) {
        stream2.emit("error", er);
        nextTick(cb, er);
        valid = false;
      }
      return valid;
    }
    Writable.prototype.write = function(chunk, encoding, cb) {
      var state2 = this._writableState;
      var ret = false;
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (Buffer$3.isBuffer(chunk))
        encoding = "buffer";
      else if (!encoding)
        encoding = state2.defaultEncoding;
      if (typeof cb !== "function")
        cb = nop;
      if (state2.ended)
        writeAfterEnd(this, cb);
      else if (validChunk(this, state2, chunk, cb)) {
        state2.pendingcb++;
        ret = writeOrBuffer(this, state2, chunk, encoding, cb);
      }
      return ret;
    };
    Writable.prototype.cork = function() {
      var state2 = this._writableState;
      state2.corked++;
    };
    Writable.prototype.uncork = function() {
      var state2 = this._writableState;
      if (state2.corked) {
        state2.corked--;
        if (!state2.writing && !state2.corked && !state2.finished && !state2.bufferProcessing && state2.bufferedRequest)
          clearBuffer(this, state2);
      }
    };
    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      if (typeof encoding === "string")
        encoding = encoding.toLowerCase();
      if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
        throw new TypeError("Unknown encoding: " + encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };
    function decodeChunk(state2, chunk, encoding) {
      if (!state2.objectMode && state2.decodeStrings !== false && typeof chunk === "string") {
        chunk = Buffer$3.from(chunk, encoding);
      }
      return chunk;
    }
    function writeOrBuffer(stream2, state2, chunk, encoding, cb) {
      chunk = decodeChunk(state2, chunk, encoding);
      if (Buffer$3.isBuffer(chunk))
        encoding = "buffer";
      var len = state2.objectMode ? 1 : chunk.length;
      state2.length += len;
      var ret = state2.length < state2.highWaterMark;
      if (!ret)
        state2.needDrain = true;
      if (state2.writing || state2.corked) {
        var last = state2.lastBufferedRequest;
        state2.lastBufferedRequest = new WriteReq(chunk, encoding, cb);
        if (last) {
          last.next = state2.lastBufferedRequest;
        } else {
          state2.bufferedRequest = state2.lastBufferedRequest;
        }
        state2.bufferedRequestCount += 1;
      } else {
        doWrite(stream2, state2, false, len, chunk, encoding, cb);
      }
      return ret;
    }
    function doWrite(stream2, state2, writev, len, chunk, encoding, cb) {
      state2.writelen = len;
      state2.writecb = cb;
      state2.writing = true;
      state2.sync = true;
      if (writev)
        stream2._writev(chunk, state2.onwrite);
      else
        stream2._write(chunk, encoding, state2.onwrite);
      state2.sync = false;
    }
    function onwriteError(stream2, state2, sync, er, cb) {
      --state2.pendingcb;
      if (sync)
        nextTick(cb, er);
      else
        cb(er);
      stream2._writableState.errorEmitted = true;
      stream2.emit("error", er);
    }
    function onwriteStateUpdate(state2) {
      state2.writing = false;
      state2.writecb = null;
      state2.length -= state2.writelen;
      state2.writelen = 0;
    }
    function onwrite(stream2, er) {
      var state2 = stream2._writableState;
      var sync = state2.sync;
      var cb = state2.writecb;
      onwriteStateUpdate(state2);
      if (er)
        onwriteError(stream2, state2, sync, er, cb);
      else {
        var finished = needFinish(state2);
        if (!finished && !state2.corked && !state2.bufferProcessing && state2.bufferedRequest) {
          clearBuffer(stream2, state2);
        }
        if (sync) {
          nextTick(afterWrite, stream2, state2, finished, cb);
        } else {
          afterWrite(stream2, state2, finished, cb);
        }
      }
    }
    function afterWrite(stream2, state2, finished, cb) {
      if (!finished)
        onwriteDrain(stream2, state2);
      state2.pendingcb--;
      cb();
      finishMaybe(stream2, state2);
    }
    function onwriteDrain(stream2, state2) {
      if (state2.length === 0 && state2.needDrain) {
        state2.needDrain = false;
        stream2.emit("drain");
      }
    }
    function clearBuffer(stream2, state2) {
      state2.bufferProcessing = true;
      var entry = state2.bufferedRequest;
      if (stream2._writev && entry && entry.next) {
        var l = state2.bufferedRequestCount;
        var buffer2 = new Array(l);
        var holder = state2.corkedRequestsFree;
        holder.entry = entry;
        var count = 0;
        while (entry) {
          buffer2[count] = entry;
          entry = entry.next;
          count += 1;
        }
        doWrite(stream2, state2, true, state2.length, buffer2, "", holder.finish);
        state2.pendingcb++;
        state2.lastBufferedRequest = null;
        if (holder.next) {
          state2.corkedRequestsFree = holder.next;
          holder.next = null;
        } else {
          state2.corkedRequestsFree = new CorkedRequest(state2);
        }
      } else {
        while (entry) {
          var chunk = entry.chunk;
          var encoding = entry.encoding;
          var cb = entry.callback;
          var len = state2.objectMode ? 1 : chunk.length;
          doWrite(stream2, state2, false, len, chunk, encoding, cb);
          entry = entry.next;
          if (state2.writing) {
            break;
          }
        }
        if (entry === null)
          state2.lastBufferedRequest = null;
      }
      state2.bufferedRequestCount = 0;
      state2.bufferedRequest = entry;
      state2.bufferProcessing = false;
    }
    Writable.prototype._write = function(chunk, encoding, cb) {
      cb(new Error("not implemented"));
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk, encoding, cb) {
      var state2 = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (chunk !== null && chunk !== void 0)
        this.write(chunk, encoding);
      if (state2.corked) {
        state2.corked = 1;
        this.uncork();
      }
      if (!state2.ending && !state2.finished)
        endWritable(this, state2, cb);
    };
    function needFinish(state2) {
      return state2.ending && state2.length === 0 && state2.bufferedRequest === null && !state2.finished && !state2.writing;
    }
    function prefinish(stream2, state2) {
      if (!state2.prefinished) {
        state2.prefinished = true;
        stream2.emit("prefinish");
      }
    }
    function finishMaybe(stream2, state2) {
      var need = needFinish(state2);
      if (need) {
        if (state2.pendingcb === 0) {
          prefinish(stream2, state2);
          state2.finished = true;
          stream2.emit("finish");
        } else {
          prefinish(stream2, state2);
        }
      }
      return need;
    }
    function endWritable(stream2, state2, cb) {
      state2.ending = true;
      finishMaybe(stream2, state2);
      if (cb) {
        if (state2.finished)
          nextTick(cb);
        else
          stream2.once("finish", cb);
      }
      state2.ended = true;
      stream2.writable = false;
    }
    function CorkedRequest(state2) {
      var _this = this;
      this.next = null;
      this.entry = null;
      this.finish = function(err) {
        var entry = _this.entry;
        _this.entry = null;
        while (entry) {
          var cb = entry.callback;
          state2.pendingcb--;
          cb(err);
          entry = entry.next;
        }
        if (state2.corkedRequestsFree) {
          state2.corkedRequestsFree.next = _this;
        } else {
          state2.corkedRequestsFree = _this;
        }
      };
    }
    inherits$1(Duplex, Readable);
    var keys = Object.keys(Writable.prototype);
    for (var v = 0; v < keys.length; v++) {
      method = keys[v];
      if (!Duplex.prototype[method])
        Duplex.prototype[method] = Writable.prototype[method];
    }
    var method;
    function Duplex(options) {
      if (!(this instanceof Duplex))
        return new Duplex(options);
      Readable.call(this, options);
      Writable.call(this, options);
      if (options && options.readable === false)
        this.readable = false;
      if (options && options.writable === false)
        this.writable = false;
      this.allowHalfOpen = true;
      if (options && options.allowHalfOpen === false)
        this.allowHalfOpen = false;
      this.once("end", onend);
    }
    function onend() {
      if (this.allowHalfOpen || this._writableState.ended)
        return;
      nextTick(onEndNT, this);
    }
    function onEndNT(self2) {
      self2.end();
    }
    inherits$1(Transform, Duplex);
    function TransformState(stream2) {
      this.afterTransform = function(er, data) {
        return afterTransform(stream2, er, data);
      };
      this.needTransform = false;
      this.transforming = false;
      this.writecb = null;
      this.writechunk = null;
      this.writeencoding = null;
    }
    function afterTransform(stream2, er, data) {
      var ts = stream2._transformState;
      ts.transforming = false;
      var cb = ts.writecb;
      if (!cb)
        return stream2.emit("error", new Error("no writecb in Transform class"));
      ts.writechunk = null;
      ts.writecb = null;
      if (data !== null && data !== void 0)
        stream2.push(data);
      cb(er);
      var rs = stream2._readableState;
      rs.reading = false;
      if (rs.needReadable || rs.length < rs.highWaterMark) {
        stream2._read(rs.highWaterMark);
      }
    }
    function Transform(options) {
      if (!(this instanceof Transform))
        return new Transform(options);
      Duplex.call(this, options);
      this._transformState = new TransformState(this);
      var stream2 = this;
      this._readableState.needReadable = true;
      this._readableState.sync = false;
      if (options) {
        if (typeof options.transform === "function")
          this._transform = options.transform;
        if (typeof options.flush === "function")
          this._flush = options.flush;
      }
      this.once("prefinish", function() {
        if (typeof this._flush === "function")
          this._flush(function(er) {
            done(stream2, er);
          });
        else
          done(stream2);
      });
    }
    Transform.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding);
    };
    Transform.prototype._transform = function(chunk, encoding, cb) {
      throw new Error("Not implemented");
    };
    Transform.prototype._write = function(chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
          this._read(rs.highWaterMark);
      }
    };
    Transform.prototype._read = function(n) {
      var ts = this._transformState;
      if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        ts.needTransform = true;
      }
    };
    function done(stream2, er) {
      if (er)
        return stream2.emit("error", er);
      var ws = stream2._writableState;
      var ts = stream2._transformState;
      if (ws.length)
        throw new Error("Calling transform done when ws.length != 0");
      if (ts.transforming)
        throw new Error("Calling transform done when still transforming");
      return stream2.push(null);
    }
    inherits$1(PassThrough, Transform);
    function PassThrough(options) {
      if (!(this instanceof PassThrough))
        return new PassThrough(options);
      Transform.call(this, options);
    }
    PassThrough.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
    inherits$1(Stream, EventEmitter);
    Stream.Readable = Readable;
    Stream.Writable = Writable;
    Stream.Duplex = Duplex;
    Stream.Transform = Transform;
    Stream.PassThrough = PassThrough;
    Stream.Stream = Stream;
    function Stream() {
      EventEmitter.call(this);
    }
    Stream.prototype.pipe = function(dest, options) {
      var source = this;
      function ondata(chunk) {
        if (dest.writable) {
          if (dest.write(chunk) === false && source.pause) {
            source.pause();
          }
        }
      }
      source.on("data", ondata);
      function ondrain() {
        if (source.readable && source.resume) {
          source.resume();
        }
      }
      dest.on("drain", ondrain);
      if (!dest._isStdio && (!options || options.end !== false)) {
        source.on("end", onend2);
        source.on("close", onclose);
      }
      var didOnEnd = false;
      function onend2() {
        if (didOnEnd)
          return;
        didOnEnd = true;
        dest.end();
      }
      function onclose() {
        if (didOnEnd)
          return;
        didOnEnd = true;
        if (typeof dest.destroy === "function")
          dest.destroy();
      }
      function onerror(er) {
        cleanup();
        if (EventEmitter.listenerCount(this, "error") === 0) {
          throw er;
        }
      }
      source.on("error", onerror);
      dest.on("error", onerror);
      function cleanup() {
        source.removeListener("data", ondata);
        dest.removeListener("drain", ondrain);
        source.removeListener("end", onend2);
        source.removeListener("close", onclose);
        source.removeListener("error", onerror);
        dest.removeListener("error", onerror);
        source.removeListener("end", cleanup);
        source.removeListener("close", cleanup);
        dest.removeListener("close", cleanup);
      }
      source.on("end", cleanup);
      source.on("close", cleanup);
      dest.on("close", cleanup);
      dest.emit("pipe", source);
      return dest;
    };
    var _polyfillNode_stream = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      Duplex,
      PassThrough,
      Readable,
      Stream,
      Transform,
      Writable,
      default: Stream
    });
    var require$$1$2 = /* @__PURE__ */ getAugmentedNamespace(_polyfillNode_stream);
    var cipherBase;
    var hasRequiredCipherBase;
    function requireCipherBase() {
      if (hasRequiredCipherBase)
        return cipherBase;
      hasRequiredCipherBase = 1;
      var Buffer2 = safeBufferExports.Buffer;
      var Transform2 = require$$1$2.Transform;
      var StringDecoder2 = require$$2$1.StringDecoder;
      var inherits2 = require$$3$1;
      function CipherBase(hashMode) {
        Transform2.call(this);
        this.hashMode = typeof hashMode === "string";
        if (this.hashMode) {
          this[hashMode] = this._finalOrDigest;
        } else {
          this.final = this._finalOrDigest;
        }
        if (this._final) {
          this.__final = this._final;
          this._final = null;
        }
        this._decoder = null;
        this._encoding = null;
      }
      inherits2(CipherBase, Transform2);
      CipherBase.prototype.update = function(data, inputEnc, outputEnc) {
        if (typeof data === "string") {
          data = Buffer2.from(data, inputEnc);
        }
        var outData = this._update(data);
        if (this.hashMode)
          return this;
        if (outputEnc) {
          outData = this._toString(outData, outputEnc);
        }
        return outData;
      };
      CipherBase.prototype.setAutoPadding = function() {
      };
      CipherBase.prototype.getAuthTag = function() {
        throw new Error("trying to get auth tag in unsupported state");
      };
      CipherBase.prototype.setAuthTag = function() {
        throw new Error("trying to set auth tag in unsupported state");
      };
      CipherBase.prototype.setAAD = function() {
        throw new Error("trying to set aad in unsupported state");
      };
      CipherBase.prototype._transform = function(data, _, next) {
        var err;
        try {
          if (this.hashMode) {
            this._update(data);
          } else {
            this.push(this._update(data));
          }
        } catch (e) {
          err = e;
        } finally {
          next(err);
        }
      };
      CipherBase.prototype._flush = function(done2) {
        var err;
        try {
          this.push(this.__final());
        } catch (e) {
          err = e;
        }
        done2(err);
      };
      CipherBase.prototype._finalOrDigest = function(outputEnc) {
        var outData = this.__final() || Buffer2.alloc(0);
        if (outputEnc) {
          outData = this._toString(outData, outputEnc, true);
        }
        return outData;
      };
      CipherBase.prototype._toString = function(value, enc, fin) {
        if (!this._decoder) {
          this._decoder = new StringDecoder2(enc);
          this._encoding = enc;
        }
        if (this._encoding !== enc)
          throw new Error("can't switch encodings");
        var out = this._decoder.write(value);
        if (fin) {
          out += this._decoder.end();
        }
        return out;
      };
      cipherBase = CipherBase;
      return cipherBase;
    }
    var browser$a;
    var hasRequiredBrowser$9;
    function requireBrowser$9() {
      if (hasRequiredBrowser$9)
        return browser$a;
      hasRequiredBrowser$9 = 1;
      var inherits2 = require$$3$1;
      var MD5 = requireMd5_js();
      var RIPEMD160 = requireRipemd160();
      var sha2 = requireSha_js();
      var Base2 = requireCipherBase();
      function Hash(hash2) {
        Base2.call(this, "digest");
        this._hash = hash2;
      }
      inherits2(Hash, Base2);
      Hash.prototype._update = function(data) {
        this._hash.update(data);
      };
      Hash.prototype._final = function() {
        return this._hash.digest();
      };
      browser$a = function createHash(alg) {
        alg = alg.toLowerCase();
        if (alg === "md5")
          return new MD5();
        if (alg === "rmd160" || alg === "ripemd160")
          return new RIPEMD160();
        return new Hash(sha2(alg));
      };
      return browser$a;
    }
    var legacy;
    var hasRequiredLegacy;
    function requireLegacy() {
      if (hasRequiredLegacy)
        return legacy;
      hasRequiredLegacy = 1;
      var inherits2 = require$$3$1;
      var Buffer2 = safeBufferExports.Buffer;
      var Base2 = requireCipherBase();
      var ZEROS = Buffer2.alloc(128);
      var blocksize = 64;
      function Hmac(alg, key2) {
        Base2.call(this, "digest");
        if (typeof key2 === "string") {
          key2 = Buffer2.from(key2);
        }
        this._alg = alg;
        this._key = key2;
        if (key2.length > blocksize) {
          key2 = alg(key2);
        } else if (key2.length < blocksize) {
          key2 = Buffer2.concat([key2, ZEROS], blocksize);
        }
        var ipad = this._ipad = Buffer2.allocUnsafe(blocksize);
        var opad = this._opad = Buffer2.allocUnsafe(blocksize);
        for (var i = 0; i < blocksize; i++) {
          ipad[i] = key2[i] ^ 54;
          opad[i] = key2[i] ^ 92;
        }
        this._hash = [ipad];
      }
      inherits2(Hmac, Base2);
      Hmac.prototype._update = function(data) {
        this._hash.push(data);
      };
      Hmac.prototype._final = function() {
        var h = this._alg(Buffer2.concat(this._hash));
        return this._alg(Buffer2.concat([this._opad, h]));
      };
      legacy = Hmac;
      return legacy;
    }
    var md5;
    var hasRequiredMd5;
    function requireMd5() {
      if (hasRequiredMd5)
        return md5;
      hasRequiredMd5 = 1;
      var MD5 = requireMd5_js();
      md5 = function(buffer2) {
        return new MD5().update(buffer2).digest();
      };
      return md5;
    }
    var browser$9;
    var hasRequiredBrowser$8;
    function requireBrowser$8() {
      if (hasRequiredBrowser$8)
        return browser$9;
      hasRequiredBrowser$8 = 1;
      var inherits2 = require$$3$1;
      var Legacy = requireLegacy();
      var Base2 = requireCipherBase();
      var Buffer2 = safeBufferExports.Buffer;
      var md52 = requireMd5();
      var RIPEMD160 = requireRipemd160();
      var sha2 = requireSha_js();
      var ZEROS = Buffer2.alloc(128);
      function Hmac(alg, key2) {
        Base2.call(this, "digest");
        if (typeof key2 === "string") {
          key2 = Buffer2.from(key2);
        }
        var blocksize = alg === "sha512" || alg === "sha384" ? 128 : 64;
        this._alg = alg;
        this._key = key2;
        if (key2.length > blocksize) {
          var hash2 = alg === "rmd160" ? new RIPEMD160() : sha2(alg);
          key2 = hash2.update(key2).digest();
        } else if (key2.length < blocksize) {
          key2 = Buffer2.concat([key2, ZEROS], blocksize);
        }
        var ipad = this._ipad = Buffer2.allocUnsafe(blocksize);
        var opad = this._opad = Buffer2.allocUnsafe(blocksize);
        for (var i = 0; i < blocksize; i++) {
          ipad[i] = key2[i] ^ 54;
          opad[i] = key2[i] ^ 92;
        }
        this._hash = alg === "rmd160" ? new RIPEMD160() : sha2(alg);
        this._hash.update(ipad);
      }
      inherits2(Hmac, Base2);
      Hmac.prototype._update = function(data) {
        this._hash.update(data);
      };
      Hmac.prototype._final = function() {
        var h = this._hash.digest();
        var hash2 = this._alg === "rmd160" ? new RIPEMD160() : sha2(this._alg);
        return hash2.update(this._opad).update(h).digest();
      };
      browser$9 = function createHmac(alg, key2) {
        alg = alg.toLowerCase();
        if (alg === "rmd160" || alg === "ripemd160") {
          return new Hmac("rmd160", key2);
        }
        if (alg === "md5") {
          return new Legacy(md52, key2);
        }
        return new Hmac(alg, key2);
      };
      return browser$9;
    }
    var algosExports = {};
    var algos = {
      get exports() {
        return algosExports;
      },
      set exports(v2) {
        algosExports = v2;
      }
    };
    var sha224WithRSAEncryption = {
      sign: "rsa",
      hash: "sha224",
      id: "302d300d06096086480165030402040500041c"
    };
    var sha256WithRSAEncryption = {
      sign: "rsa",
      hash: "sha256",
      id: "3031300d060960864801650304020105000420"
    };
    var sha384WithRSAEncryption = {
      sign: "rsa",
      hash: "sha384",
      id: "3041300d060960864801650304020205000430"
    };
    var sha512WithRSAEncryption = {
      sign: "rsa",
      hash: "sha512",
      id: "3051300d060960864801650304020305000440"
    };
    var sha256 = {
      sign: "ecdsa",
      hash: "sha256",
      id: ""
    };
    var sha224 = {
      sign: "ecdsa",
      hash: "sha224",
      id: ""
    };
    var sha384 = {
      sign: "ecdsa",
      hash: "sha384",
      id: ""
    };
    var sha512 = {
      sign: "ecdsa",
      hash: "sha512",
      id: ""
    };
    var DSA = {
      sign: "dsa",
      hash: "sha1",
      id: ""
    };
    var ripemd160WithRSA = {
      sign: "rsa",
      hash: "rmd160",
      id: "3021300906052b2403020105000414"
    };
    var md5WithRSAEncryption = {
      sign: "rsa",
      hash: "md5",
      id: "3020300c06082a864886f70d020505000410"
    };
    var require$$6 = {
      sha224WithRSAEncryption,
      "RSA-SHA224": {
        sign: "ecdsa/rsa",
        hash: "sha224",
        id: "302d300d06096086480165030402040500041c"
      },
      sha256WithRSAEncryption,
      "RSA-SHA256": {
        sign: "ecdsa/rsa",
        hash: "sha256",
        id: "3031300d060960864801650304020105000420"
      },
      sha384WithRSAEncryption,
      "RSA-SHA384": {
        sign: "ecdsa/rsa",
        hash: "sha384",
        id: "3041300d060960864801650304020205000430"
      },
      sha512WithRSAEncryption,
      "RSA-SHA512": {
        sign: "ecdsa/rsa",
        hash: "sha512",
        id: "3051300d060960864801650304020305000440"
      },
      "RSA-SHA1": {
        sign: "rsa",
        hash: "sha1",
        id: "3021300906052b0e03021a05000414"
      },
      "ecdsa-with-SHA1": {
        sign: "ecdsa",
        hash: "sha1",
        id: ""
      },
      sha256,
      sha224,
      sha384,
      sha512,
      "DSA-SHA": {
        sign: "dsa",
        hash: "sha1",
        id: ""
      },
      "DSA-SHA1": {
        sign: "dsa",
        hash: "sha1",
        id: ""
      },
      DSA,
      "DSA-WITH-SHA224": {
        sign: "dsa",
        hash: "sha224",
        id: ""
      },
      "DSA-SHA224": {
        sign: "dsa",
        hash: "sha224",
        id: ""
      },
      "DSA-WITH-SHA256": {
        sign: "dsa",
        hash: "sha256",
        id: ""
      },
      "DSA-SHA256": {
        sign: "dsa",
        hash: "sha256",
        id: ""
      },
      "DSA-WITH-SHA384": {
        sign: "dsa",
        hash: "sha384",
        id: ""
      },
      "DSA-SHA384": {
        sign: "dsa",
        hash: "sha384",
        id: ""
      },
      "DSA-WITH-SHA512": {
        sign: "dsa",
        hash: "sha512",
        id: ""
      },
      "DSA-SHA512": {
        sign: "dsa",
        hash: "sha512",
        id: ""
      },
      "DSA-RIPEMD160": {
        sign: "dsa",
        hash: "rmd160",
        id: ""
      },
      ripemd160WithRSA,
      "RSA-RIPEMD160": {
        sign: "rsa",
        hash: "rmd160",
        id: "3021300906052b2403020105000414"
      },
      md5WithRSAEncryption,
      "RSA-MD5": {
        sign: "rsa",
        hash: "md5",
        id: "3020300c06082a864886f70d020505000410"
      }
    };
    var hasRequiredAlgos;
    function requireAlgos() {
      if (hasRequiredAlgos)
        return algosExports;
      hasRequiredAlgos = 1;
      (function(module2) {
        module2.exports = require$$6;
      })(algos);
      return algosExports;
    }
    var browser$8 = {};
    var precondition;
    var hasRequiredPrecondition;
    function requirePrecondition() {
      if (hasRequiredPrecondition)
        return precondition;
      hasRequiredPrecondition = 1;
      var MAX_ALLOC = Math.pow(2, 30) - 1;
      precondition = function(iterations, keylen) {
        if (typeof iterations !== "number") {
          throw new TypeError("Iterations not a number");
        }
        if (iterations < 0) {
          throw new TypeError("Bad iterations");
        }
        if (typeof keylen !== "number") {
          throw new TypeError("Key length not a number");
        }
        if (keylen < 0 || keylen > MAX_ALLOC || keylen !== keylen) {
          throw new TypeError("Bad key length");
        }
      };
      return precondition;
    }
    var defaultEncoding_1;
    var hasRequiredDefaultEncoding;
    function requireDefaultEncoding() {
      if (hasRequiredDefaultEncoding)
        return defaultEncoding_1;
      hasRequiredDefaultEncoding = 1;
      var defaultEncoding;
      if (commonjsGlobal.process && commonjsGlobal.process.browser) {
        defaultEncoding = "utf-8";
      } else if (commonjsGlobal.process && commonjsGlobal.process.version) {
        var pVersionMajor = parseInt(process.version.split(".")[0].slice(1), 10);
        defaultEncoding = pVersionMajor >= 6 ? "utf-8" : "binary";
      } else {
        defaultEncoding = "utf-8";
      }
      defaultEncoding_1 = defaultEncoding;
      return defaultEncoding_1;
    }
    var toBuffer;
    var hasRequiredToBuffer;
    function requireToBuffer() {
      if (hasRequiredToBuffer)
        return toBuffer;
      hasRequiredToBuffer = 1;
      var Buffer2 = safeBufferExports.Buffer;
      toBuffer = function(thing, encoding, name2) {
        if (Buffer2.isBuffer(thing)) {
          return thing;
        } else if (typeof thing === "string") {
          return Buffer2.from(thing, encoding);
        } else if (ArrayBuffer.isView(thing)) {
          return Buffer2.from(thing.buffer);
        } else {
          throw new TypeError(name2 + " must be a string, a Buffer, a typed array or a DataView");
        }
      };
      return toBuffer;
    }
    var syncBrowser;
    var hasRequiredSyncBrowser;
    function requireSyncBrowser() {
      if (hasRequiredSyncBrowser)
        return syncBrowser;
      hasRequiredSyncBrowser = 1;
      var md52 = requireMd5();
      var RIPEMD160 = requireRipemd160();
      var sha2 = requireSha_js();
      var Buffer2 = safeBufferExports.Buffer;
      var checkParameters = requirePrecondition();
      var defaultEncoding = requireDefaultEncoding();
      var toBuffer2 = requireToBuffer();
      var ZEROS = Buffer2.alloc(128);
      var sizes = {
        md5: 16,
        sha1: 20,
        sha224: 28,
        sha256: 32,
        sha384: 48,
        sha512: 64,
        rmd160: 20,
        ripemd160: 20
      };
      function Hmac(alg, key2, saltLen) {
        var hash2 = getDigest(alg);
        var blocksize = alg === "sha512" || alg === "sha384" ? 128 : 64;
        if (key2.length > blocksize) {
          key2 = hash2(key2);
        } else if (key2.length < blocksize) {
          key2 = Buffer2.concat([key2, ZEROS], blocksize);
        }
        var ipad = Buffer2.allocUnsafe(blocksize + sizes[alg]);
        var opad = Buffer2.allocUnsafe(blocksize + sizes[alg]);
        for (var i = 0; i < blocksize; i++) {
          ipad[i] = key2[i] ^ 54;
          opad[i] = key2[i] ^ 92;
        }
        var ipad1 = Buffer2.allocUnsafe(blocksize + saltLen + 4);
        ipad.copy(ipad1, 0, 0, blocksize);
        this.ipad1 = ipad1;
        this.ipad2 = ipad;
        this.opad = opad;
        this.alg = alg;
        this.blocksize = blocksize;
        this.hash = hash2;
        this.size = sizes[alg];
      }
      Hmac.prototype.run = function(data, ipad) {
        data.copy(ipad, this.blocksize);
        var h = this.hash(ipad);
        h.copy(this.opad, this.blocksize);
        return this.hash(this.opad);
      };
      function getDigest(alg) {
        function shaFunc(data) {
          return sha2(alg).update(data).digest();
        }
        function rmd160Func(data) {
          return new RIPEMD160().update(data).digest();
        }
        if (alg === "rmd160" || alg === "ripemd160")
          return rmd160Func;
        if (alg === "md5")
          return md52;
        return shaFunc;
      }
      function pbkdf2(password, salt, iterations, keylen, digest) {
        checkParameters(iterations, keylen);
        password = toBuffer2(password, defaultEncoding, "Password");
        salt = toBuffer2(salt, defaultEncoding, "Salt");
        digest = digest || "sha1";
        var hmac2 = new Hmac(digest, password, salt.length);
        var DK = Buffer2.allocUnsafe(keylen);
        var block1 = Buffer2.allocUnsafe(salt.length + 4);
        salt.copy(block1, 0, 0, salt.length);
        var destPos = 0;
        var hLen = sizes[digest];
        var l = Math.ceil(keylen / hLen);
        for (var i = 1; i <= l; i++) {
          block1.writeUInt32BE(i, salt.length);
          var T = hmac2.run(block1, hmac2.ipad1);
          var U = T;
          for (var j = 1; j < iterations; j++) {
            U = hmac2.run(U, hmac2.ipad2);
            for (var k = 0; k < hLen; k++)
              T[k] ^= U[k];
          }
          T.copy(DK, destPos);
          destPos += hLen;
        }
        return DK;
      }
      syncBrowser = pbkdf2;
      return syncBrowser;
    }
    var async;
    var hasRequiredAsync;
    function requireAsync() {
      if (hasRequiredAsync)
        return async;
      hasRequiredAsync = 1;
      var Buffer2 = safeBufferExports.Buffer;
      var checkParameters = requirePrecondition();
      var defaultEncoding = requireDefaultEncoding();
      var sync = requireSyncBrowser();
      var toBuffer2 = requireToBuffer();
      var ZERO_BUF;
      var subtle = commonjsGlobal.crypto && commonjsGlobal.crypto.subtle;
      var toBrowser = {
        sha: "SHA-1",
        "sha-1": "SHA-1",
        sha1: "SHA-1",
        sha256: "SHA-256",
        "sha-256": "SHA-256",
        sha384: "SHA-384",
        "sha-384": "SHA-384",
        "sha-512": "SHA-512",
        sha512: "SHA-512"
      };
      var checks = [];
      function checkNative(algo) {
        if (commonjsGlobal.process && !commonjsGlobal.process.browser) {
          return Promise.resolve(false);
        }
        if (!subtle || !subtle.importKey || !subtle.deriveBits) {
          return Promise.resolve(false);
        }
        if (checks[algo] !== void 0) {
          return checks[algo];
        }
        ZERO_BUF = ZERO_BUF || Buffer2.alloc(8);
        var prom = browserPbkdf2(ZERO_BUF, ZERO_BUF, 10, 128, algo).then(function() {
          return true;
        }).catch(function() {
          return false;
        });
        checks[algo] = prom;
        return prom;
      }
      var nextTick2;
      function getNextTick() {
        if (nextTick2) {
          return nextTick2;
        }
        if (commonjsGlobal.process && commonjsGlobal.process.nextTick) {
          nextTick2 = commonjsGlobal.process.nextTick;
        } else if (commonjsGlobal.queueMicrotask) {
          nextTick2 = commonjsGlobal.queueMicrotask;
        } else if (commonjsGlobal.setImmediate) {
          nextTick2 = commonjsGlobal.setImmediate;
        } else {
          nextTick2 = commonjsGlobal.setTimeout;
        }
        return nextTick2;
      }
      function browserPbkdf2(password, salt, iterations, length2, algo) {
        return subtle.importKey("raw", password, {name: "PBKDF2"}, false, ["deriveBits"]).then(function(key2) {
          return subtle.deriveBits({
            name: "PBKDF2",
            salt,
            iterations,
            hash: {
              name: algo
            }
          }, key2, length2 << 3);
        }).then(function(res) {
          return Buffer2.from(res);
        });
      }
      function resolvePromise(promise2, callback) {
        promise2.then(function(out) {
          getNextTick()(function() {
            callback(null, out);
          });
        }, function(e) {
          getNextTick()(function() {
            callback(e);
          });
        });
      }
      async = function(password, salt, iterations, keylen, digest, callback) {
        if (typeof digest === "function") {
          callback = digest;
          digest = void 0;
        }
        digest = digest || "sha1";
        var algo = toBrowser[digest.toLowerCase()];
        if (!algo || typeof commonjsGlobal.Promise !== "function") {
          getNextTick()(function() {
            var out;
            try {
              out = sync(password, salt, iterations, keylen, digest);
            } catch (e) {
              return callback(e);
            }
            callback(null, out);
          });
          return;
        }
        checkParameters(iterations, keylen);
        password = toBuffer2(password, defaultEncoding, "Password");
        salt = toBuffer2(salt, defaultEncoding, "Salt");
        if (typeof callback !== "function")
          throw new Error("No callback provided to pbkdf2");
        resolvePromise(checkNative(algo).then(function(resp) {
          if (resp)
            return browserPbkdf2(password, salt, iterations, keylen, algo);
          return sync(password, salt, iterations, keylen, digest);
        }), callback);
      };
      return async;
    }
    var hasRequiredBrowser$7;
    function requireBrowser$7() {
      if (hasRequiredBrowser$7)
        return browser$8;
      hasRequiredBrowser$7 = 1;
      browser$8.pbkdf2 = requireAsync();
      browser$8.pbkdf2Sync = requireSyncBrowser();
      return browser$8;
    }
    var browser$7 = {};
    var des$1 = {};
    var utils$3 = {};
    var hasRequiredUtils$3;
    function requireUtils$3() {
      if (hasRequiredUtils$3)
        return utils$3;
      hasRequiredUtils$3 = 1;
      utils$3.readUInt32BE = function readUInt32BE(bytes, off2) {
        var res = bytes[0 + off2] << 24 | bytes[1 + off2] << 16 | bytes[2 + off2] << 8 | bytes[3 + off2];
        return res >>> 0;
      };
      utils$3.writeUInt32BE = function writeUInt32BE(bytes, value, off2) {
        bytes[0 + off2] = value >>> 24;
        bytes[1 + off2] = value >>> 16 & 255;
        bytes[2 + off2] = value >>> 8 & 255;
        bytes[3 + off2] = value & 255;
      };
      utils$3.ip = function ip(inL, inR, out, off2) {
        var outL = 0;
        var outR = 0;
        for (var i = 6; i >= 0; i -= 2) {
          for (var j = 0; j <= 24; j += 8) {
            outL <<= 1;
            outL |= inR >>> j + i & 1;
          }
          for (var j = 0; j <= 24; j += 8) {
            outL <<= 1;
            outL |= inL >>> j + i & 1;
          }
        }
        for (var i = 6; i >= 0; i -= 2) {
          for (var j = 1; j <= 25; j += 8) {
            outR <<= 1;
            outR |= inR >>> j + i & 1;
          }
          for (var j = 1; j <= 25; j += 8) {
            outR <<= 1;
            outR |= inL >>> j + i & 1;
          }
        }
        out[off2 + 0] = outL >>> 0;
        out[off2 + 1] = outR >>> 0;
      };
      utils$3.rip = function rip(inL, inR, out, off2) {
        var outL = 0;
        var outR = 0;
        for (var i = 0; i < 4; i++) {
          for (var j = 24; j >= 0; j -= 8) {
            outL <<= 1;
            outL |= inR >>> j + i & 1;
            outL <<= 1;
            outL |= inL >>> j + i & 1;
          }
        }
        for (var i = 4; i < 8; i++) {
          for (var j = 24; j >= 0; j -= 8) {
            outR <<= 1;
            outR |= inR >>> j + i & 1;
            outR <<= 1;
            outR |= inL >>> j + i & 1;
          }
        }
        out[off2 + 0] = outL >>> 0;
        out[off2 + 1] = outR >>> 0;
      };
      utils$3.pc1 = function pc1(inL, inR, out, off2) {
        var outL = 0;
        var outR = 0;
        for (var i = 7; i >= 5; i--) {
          for (var j = 0; j <= 24; j += 8) {
            outL <<= 1;
            outL |= inR >> j + i & 1;
          }
          for (var j = 0; j <= 24; j += 8) {
            outL <<= 1;
            outL |= inL >> j + i & 1;
          }
        }
        for (var j = 0; j <= 24; j += 8) {
          outL <<= 1;
          outL |= inR >> j + i & 1;
        }
        for (var i = 1; i <= 3; i++) {
          for (var j = 0; j <= 24; j += 8) {
            outR <<= 1;
            outR |= inR >> j + i & 1;
          }
          for (var j = 0; j <= 24; j += 8) {
            outR <<= 1;
            outR |= inL >> j + i & 1;
          }
        }
        for (var j = 0; j <= 24; j += 8) {
          outR <<= 1;
          outR |= inL >> j + i & 1;
        }
        out[off2 + 0] = outL >>> 0;
        out[off2 + 1] = outR >>> 0;
      };
      utils$3.r28shl = function r28shl(num, shift) {
        return num << shift & 268435455 | num >>> 28 - shift;
      };
      var pc2table = [
        14,
        11,
        17,
        4,
        27,
        23,
        25,
        0,
        13,
        22,
        7,
        18,
        5,
        9,
        16,
        24,
        2,
        20,
        12,
        21,
        1,
        8,
        15,
        26,
        15,
        4,
        25,
        19,
        9,
        1,
        26,
        16,
        5,
        11,
        23,
        8,
        12,
        7,
        17,
        0,
        22,
        3,
        10,
        14,
        6,
        20,
        27,
        24
      ];
      utils$3.pc2 = function pc2(inL, inR, out, off2) {
        var outL = 0;
        var outR = 0;
        var len = pc2table.length >>> 1;
        for (var i = 0; i < len; i++) {
          outL <<= 1;
          outL |= inL >>> pc2table[i] & 1;
        }
        for (var i = len; i < pc2table.length; i++) {
          outR <<= 1;
          outR |= inR >>> pc2table[i] & 1;
        }
        out[off2 + 0] = outL >>> 0;
        out[off2 + 1] = outR >>> 0;
      };
      utils$3.expand = function expand(r, out, off2) {
        var outL = 0;
        var outR = 0;
        outL = (r & 1) << 5 | r >>> 27;
        for (var i = 23; i >= 15; i -= 4) {
          outL <<= 6;
          outL |= r >>> i & 63;
        }
        for (var i = 11; i >= 3; i -= 4) {
          outR |= r >>> i & 63;
          outR <<= 6;
        }
        outR |= (r & 31) << 1 | r >>> 31;
        out[off2 + 0] = outL >>> 0;
        out[off2 + 1] = outR >>> 0;
      };
      var sTable = [
        14,
        0,
        4,
        15,
        13,
        7,
        1,
        4,
        2,
        14,
        15,
        2,
        11,
        13,
        8,
        1,
        3,
        10,
        10,
        6,
        6,
        12,
        12,
        11,
        5,
        9,
        9,
        5,
        0,
        3,
        7,
        8,
        4,
        15,
        1,
        12,
        14,
        8,
        8,
        2,
        13,
        4,
        6,
        9,
        2,
        1,
        11,
        7,
        15,
        5,
        12,
        11,
        9,
        3,
        7,
        14,
        3,
        10,
        10,
        0,
        5,
        6,
        0,
        13,
        15,
        3,
        1,
        13,
        8,
        4,
        14,
        7,
        6,
        15,
        11,
        2,
        3,
        8,
        4,
        14,
        9,
        12,
        7,
        0,
        2,
        1,
        13,
        10,
        12,
        6,
        0,
        9,
        5,
        11,
        10,
        5,
        0,
        13,
        14,
        8,
        7,
        10,
        11,
        1,
        10,
        3,
        4,
        15,
        13,
        4,
        1,
        2,
        5,
        11,
        8,
        6,
        12,
        7,
        6,
        12,
        9,
        0,
        3,
        5,
        2,
        14,
        15,
        9,
        10,
        13,
        0,
        7,
        9,
        0,
        14,
        9,
        6,
        3,
        3,
        4,
        15,
        6,
        5,
        10,
        1,
        2,
        13,
        8,
        12,
        5,
        7,
        14,
        11,
        12,
        4,
        11,
        2,
        15,
        8,
        1,
        13,
        1,
        6,
        10,
        4,
        13,
        9,
        0,
        8,
        6,
        15,
        9,
        3,
        8,
        0,
        7,
        11,
        4,
        1,
        15,
        2,
        14,
        12,
        3,
        5,
        11,
        10,
        5,
        14,
        2,
        7,
        12,
        7,
        13,
        13,
        8,
        14,
        11,
        3,
        5,
        0,
        6,
        6,
        15,
        9,
        0,
        10,
        3,
        1,
        4,
        2,
        7,
        8,
        2,
        5,
        12,
        11,
        1,
        12,
        10,
        4,
        14,
        15,
        9,
        10,
        3,
        6,
        15,
        9,
        0,
        0,
        6,
        12,
        10,
        11,
        1,
        7,
        13,
        13,
        8,
        15,
        9,
        1,
        4,
        3,
        5,
        14,
        11,
        5,
        12,
        2,
        7,
        8,
        2,
        4,
        14,
        2,
        14,
        12,
        11,
        4,
        2,
        1,
        12,
        7,
        4,
        10,
        7,
        11,
        13,
        6,
        1,
        8,
        5,
        5,
        0,
        3,
        15,
        15,
        10,
        13,
        3,
        0,
        9,
        14,
        8,
        9,
        6,
        4,
        11,
        2,
        8,
        1,
        12,
        11,
        7,
        10,
        1,
        13,
        14,
        7,
        2,
        8,
        13,
        15,
        6,
        9,
        15,
        12,
        0,
        5,
        9,
        6,
        10,
        3,
        4,
        0,
        5,
        14,
        3,
        12,
        10,
        1,
        15,
        10,
        4,
        15,
        2,
        9,
        7,
        2,
        12,
        6,
        9,
        8,
        5,
        0,
        6,
        13,
        1,
        3,
        13,
        4,
        14,
        14,
        0,
        7,
        11,
        5,
        3,
        11,
        8,
        9,
        4,
        14,
        3,
        15,
        2,
        5,
        12,
        2,
        9,
        8,
        5,
        12,
        15,
        3,
        10,
        7,
        11,
        0,
        14,
        4,
        1,
        10,
        7,
        1,
        6,
        13,
        0,
        11,
        8,
        6,
        13,
        4,
        13,
        11,
        0,
        2,
        11,
        14,
        7,
        15,
        4,
        0,
        9,
        8,
        1,
        13,
        10,
        3,
        14,
        12,
        3,
        9,
        5,
        7,
        12,
        5,
        2,
        10,
        15,
        6,
        8,
        1,
        6,
        1,
        6,
        4,
        11,
        11,
        13,
        13,
        8,
        12,
        1,
        3,
        4,
        7,
        10,
        14,
        7,
        10,
        9,
        15,
        5,
        6,
        0,
        8,
        15,
        0,
        14,
        5,
        2,
        9,
        3,
        2,
        12,
        13,
        1,
        2,
        15,
        8,
        13,
        4,
        8,
        6,
        10,
        15,
        3,
        11,
        7,
        1,
        4,
        10,
        12,
        9,
        5,
        3,
        6,
        14,
        11,
        5,
        0,
        0,
        14,
        12,
        9,
        7,
        2,
        7,
        2,
        11,
        1,
        4,
        14,
        1,
        7,
        9,
        4,
        12,
        10,
        14,
        8,
        2,
        13,
        0,
        15,
        6,
        12,
        10,
        9,
        13,
        0,
        15,
        3,
        3,
        5,
        5,
        6,
        8,
        11
      ];
      utils$3.substitute = function substitute(inL, inR) {
        var out = 0;
        for (var i = 0; i < 4; i++) {
          var b = inL >>> 18 - i * 6 & 63;
          var sb = sTable[i * 64 + b];
          out <<= 4;
          out |= sb;
        }
        for (var i = 0; i < 4; i++) {
          var b = inR >>> 18 - i * 6 & 63;
          var sb = sTable[4 * 64 + i * 64 + b];
          out <<= 4;
          out |= sb;
        }
        return out >>> 0;
      };
      var permuteTable = [
        16,
        25,
        12,
        11,
        3,
        20,
        4,
        15,
        31,
        17,
        9,
        6,
        27,
        14,
        1,
        22,
        30,
        24,
        8,
        18,
        0,
        5,
        29,
        23,
        13,
        19,
        2,
        26,
        10,
        21,
        28,
        7
      ];
      utils$3.permute = function permute(num) {
        var out = 0;
        for (var i = 0; i < permuteTable.length; i++) {
          out <<= 1;
          out |= num >>> permuteTable[i] & 1;
        }
        return out >>> 0;
      };
      utils$3.padSplit = function padSplit(num, size, group) {
        var str = num.toString(2);
        while (str.length < size)
          str = "0" + str;
        var out = [];
        for (var i = 0; i < size; i += group)
          out.push(str.slice(i, i + group));
        return out.join(" ");
      };
      return utils$3;
    }
    var minimalisticAssert;
    var hasRequiredMinimalisticAssert;
    function requireMinimalisticAssert() {
      if (hasRequiredMinimalisticAssert)
        return minimalisticAssert;
      hasRequiredMinimalisticAssert = 1;
      minimalisticAssert = assert2;
      function assert2(val, msg) {
        if (!val)
          throw new Error(msg || "Assertion failed");
      }
      assert2.equal = function assertEqual(l, r, msg) {
        if (l != r)
          throw new Error(msg || "Assertion failed: " + l + " != " + r);
      };
      return minimalisticAssert;
    }
    var cipher;
    var hasRequiredCipher;
    function requireCipher() {
      if (hasRequiredCipher)
        return cipher;
      hasRequiredCipher = 1;
      var assert2 = requireMinimalisticAssert();
      function Cipher(options) {
        this.options = options;
        this.type = this.options.type;
        this.blockSize = 8;
        this._init();
        this.buffer = new Array(this.blockSize);
        this.bufferOff = 0;
      }
      cipher = Cipher;
      Cipher.prototype._init = function _init() {
      };
      Cipher.prototype.update = function update(data) {
        if (data.length === 0)
          return [];
        if (this.type === "decrypt")
          return this._updateDecrypt(data);
        else
          return this._updateEncrypt(data);
      };
      Cipher.prototype._buffer = function _buffer(data, off2) {
        var min = Math.min(this.buffer.length - this.bufferOff, data.length - off2);
        for (var i = 0; i < min; i++)
          this.buffer[this.bufferOff + i] = data[off2 + i];
        this.bufferOff += min;
        return min;
      };
      Cipher.prototype._flushBuffer = function _flushBuffer(out, off2) {
        this._update(this.buffer, 0, out, off2);
        this.bufferOff = 0;
        return this.blockSize;
      };
      Cipher.prototype._updateEncrypt = function _updateEncrypt(data) {
        var inputOff = 0;
        var outputOff = 0;
        var count = (this.bufferOff + data.length) / this.blockSize | 0;
        var out = new Array(count * this.blockSize);
        if (this.bufferOff !== 0) {
          inputOff += this._buffer(data, inputOff);
          if (this.bufferOff === this.buffer.length)
            outputOff += this._flushBuffer(out, outputOff);
        }
        var max = data.length - (data.length - inputOff) % this.blockSize;
        for (; inputOff < max; inputOff += this.blockSize) {
          this._update(data, inputOff, out, outputOff);
          outputOff += this.blockSize;
        }
        for (; inputOff < data.length; inputOff++, this.bufferOff++)
          this.buffer[this.bufferOff] = data[inputOff];
        return out;
      };
      Cipher.prototype._updateDecrypt = function _updateDecrypt(data) {
        var inputOff = 0;
        var outputOff = 0;
        var count = Math.ceil((this.bufferOff + data.length) / this.blockSize) - 1;
        var out = new Array(count * this.blockSize);
        for (; count > 0; count--) {
          inputOff += this._buffer(data, inputOff);
          outputOff += this._flushBuffer(out, outputOff);
        }
        inputOff += this._buffer(data, inputOff);
        return out;
      };
      Cipher.prototype.final = function final(buffer2) {
        var first;
        if (buffer2)
          first = this.update(buffer2);
        var last;
        if (this.type === "encrypt")
          last = this._finalEncrypt();
        else
          last = this._finalDecrypt();
        if (first)
          return first.concat(last);
        else
          return last;
      };
      Cipher.prototype._pad = function _pad(buffer2, off2) {
        if (off2 === 0)
          return false;
        while (off2 < buffer2.length)
          buffer2[off2++] = 0;
        return true;
      };
      Cipher.prototype._finalEncrypt = function _finalEncrypt() {
        if (!this._pad(this.buffer, this.bufferOff))
          return [];
        var out = new Array(this.blockSize);
        this._update(this.buffer, 0, out, 0);
        return out;
      };
      Cipher.prototype._unpad = function _unpad(buffer2) {
        return buffer2;
      };
      Cipher.prototype._finalDecrypt = function _finalDecrypt() {
        assert2.equal(this.bufferOff, this.blockSize, "Not enough data to decrypt");
        var out = new Array(this.blockSize);
        this._flushBuffer(out, 0);
        return this._unpad(out);
      };
      return cipher;
    }
    var des;
    var hasRequiredDes$1;
    function requireDes$1() {
      if (hasRequiredDes$1)
        return des;
      hasRequiredDes$1 = 1;
      var assert2 = requireMinimalisticAssert();
      var inherits2 = require$$3$1;
      var utils2 = requireUtils$3();
      var Cipher = requireCipher();
      function DESState() {
        this.tmp = new Array(2);
        this.keys = null;
      }
      function DES(options) {
        Cipher.call(this, options);
        var state2 = new DESState();
        this._desState = state2;
        this.deriveKeys(state2, options.key);
      }
      inherits2(DES, Cipher);
      des = DES;
      DES.create = function create2(options) {
        return new DES(options);
      };
      var shiftTable = [
        1,
        1,
        2,
        2,
        2,
        2,
        2,
        2,
        1,
        2,
        2,
        2,
        2,
        2,
        2,
        1
      ];
      DES.prototype.deriveKeys = function deriveKeys(state2, key2) {
        state2.keys = new Array(16 * 2);
        assert2.equal(key2.length, this.blockSize, "Invalid key length");
        var kL = utils2.readUInt32BE(key2, 0);
        var kR = utils2.readUInt32BE(key2, 4);
        utils2.pc1(kL, kR, state2.tmp, 0);
        kL = state2.tmp[0];
        kR = state2.tmp[1];
        for (var i = 0; i < state2.keys.length; i += 2) {
          var shift = shiftTable[i >>> 1];
          kL = utils2.r28shl(kL, shift);
          kR = utils2.r28shl(kR, shift);
          utils2.pc2(kL, kR, state2.keys, i);
        }
      };
      DES.prototype._update = function _update(inp, inOff, out, outOff) {
        var state2 = this._desState;
        var l = utils2.readUInt32BE(inp, inOff);
        var r = utils2.readUInt32BE(inp, inOff + 4);
        utils2.ip(l, r, state2.tmp, 0);
        l = state2.tmp[0];
        r = state2.tmp[1];
        if (this.type === "encrypt")
          this._encrypt(state2, l, r, state2.tmp, 0);
        else
          this._decrypt(state2, l, r, state2.tmp, 0);
        l = state2.tmp[0];
        r = state2.tmp[1];
        utils2.writeUInt32BE(out, l, outOff);
        utils2.writeUInt32BE(out, r, outOff + 4);
      };
      DES.prototype._pad = function _pad(buffer2, off2) {
        var value = buffer2.length - off2;
        for (var i = off2; i < buffer2.length; i++)
          buffer2[i] = value;
        return true;
      };
      DES.prototype._unpad = function _unpad(buffer2) {
        var pad2 = buffer2[buffer2.length - 1];
        for (var i = buffer2.length - pad2; i < buffer2.length; i++)
          assert2.equal(buffer2[i], pad2);
        return buffer2.slice(0, buffer2.length - pad2);
      };
      DES.prototype._encrypt = function _encrypt(state2, lStart, rStart, out, off2) {
        var l = lStart;
        var r = rStart;
        for (var i = 0; i < state2.keys.length; i += 2) {
          var keyL = state2.keys[i];
          var keyR = state2.keys[i + 1];
          utils2.expand(r, state2.tmp, 0);
          keyL ^= state2.tmp[0];
          keyR ^= state2.tmp[1];
          var s = utils2.substitute(keyL, keyR);
          var f = utils2.permute(s);
          var t = r;
          r = (l ^ f) >>> 0;
          l = t;
        }
        utils2.rip(r, l, out, off2);
      };
      DES.prototype._decrypt = function _decrypt(state2, lStart, rStart, out, off2) {
        var l = rStart;
        var r = lStart;
        for (var i = state2.keys.length - 2; i >= 0; i -= 2) {
          var keyL = state2.keys[i];
          var keyR = state2.keys[i + 1];
          utils2.expand(l, state2.tmp, 0);
          keyL ^= state2.tmp[0];
          keyR ^= state2.tmp[1];
          var s = utils2.substitute(keyL, keyR);
          var f = utils2.permute(s);
          var t = l;
          l = (r ^ f) >>> 0;
          r = t;
        }
        utils2.rip(l, r, out, off2);
      };
      return des;
    }
    var cbc$1 = {};
    var hasRequiredCbc$1;
    function requireCbc$1() {
      if (hasRequiredCbc$1)
        return cbc$1;
      hasRequiredCbc$1 = 1;
      var assert2 = requireMinimalisticAssert();
      var inherits2 = require$$3$1;
      var proto = {};
      function CBCState(iv) {
        assert2.equal(iv.length, 8, "Invalid IV length");
        this.iv = new Array(8);
        for (var i = 0; i < this.iv.length; i++)
          this.iv[i] = iv[i];
      }
      function instantiate(Base2) {
        function CBC(options) {
          Base2.call(this, options);
          this._cbcInit();
        }
        inherits2(CBC, Base2);
        var keys2 = Object.keys(proto);
        for (var i = 0; i < keys2.length; i++) {
          var key2 = keys2[i];
          CBC.prototype[key2] = proto[key2];
        }
        CBC.create = function create2(options) {
          return new CBC(options);
        };
        return CBC;
      }
      cbc$1.instantiate = instantiate;
      proto._cbcInit = function _cbcInit() {
        var state2 = new CBCState(this.options.iv);
        this._cbcState = state2;
      };
      proto._update = function _update(inp, inOff, out, outOff) {
        var state2 = this._cbcState;
        var superProto = this.constructor.super_.prototype;
        var iv = state2.iv;
        if (this.type === "encrypt") {
          for (var i = 0; i < this.blockSize; i++)
            iv[i] ^= inp[inOff + i];
          superProto._update.call(this, iv, 0, out, outOff);
          for (var i = 0; i < this.blockSize; i++)
            iv[i] = out[outOff + i];
        } else {
          superProto._update.call(this, inp, inOff, out, outOff);
          for (var i = 0; i < this.blockSize; i++)
            out[outOff + i] ^= iv[i];
          for (var i = 0; i < this.blockSize; i++)
            iv[i] = inp[inOff + i];
        }
      };
      return cbc$1;
    }
    var ede;
    var hasRequiredEde;
    function requireEde() {
      if (hasRequiredEde)
        return ede;
      hasRequiredEde = 1;
      var assert2 = requireMinimalisticAssert();
      var inherits2 = require$$3$1;
      var Cipher = requireCipher();
      var DES = requireDes$1();
      function EDEState(type, key2) {
        assert2.equal(key2.length, 24, "Invalid key length");
        var k1 = key2.slice(0, 8);
        var k2 = key2.slice(8, 16);
        var k3 = key2.slice(16, 24);
        if (type === "encrypt") {
          this.ciphers = [
            DES.create({type: "encrypt", key: k1}),
            DES.create({type: "decrypt", key: k2}),
            DES.create({type: "encrypt", key: k3})
          ];
        } else {
          this.ciphers = [
            DES.create({type: "decrypt", key: k3}),
            DES.create({type: "encrypt", key: k2}),
            DES.create({type: "decrypt", key: k1})
          ];
        }
      }
      function EDE(options) {
        Cipher.call(this, options);
        var state2 = new EDEState(this.type, this.options.key);
        this._edeState = state2;
      }
      inherits2(EDE, Cipher);
      ede = EDE;
      EDE.create = function create2(options) {
        return new EDE(options);
      };
      EDE.prototype._update = function _update(inp, inOff, out, outOff) {
        var state2 = this._edeState;
        state2.ciphers[0]._update(inp, inOff, out, outOff);
        state2.ciphers[1]._update(out, outOff, out, outOff);
        state2.ciphers[2]._update(out, outOff, out, outOff);
      };
      EDE.prototype._pad = DES.prototype._pad;
      EDE.prototype._unpad = DES.prototype._unpad;
      return ede;
    }
    var hasRequiredDes;
    function requireDes() {
      if (hasRequiredDes)
        return des$1;
      hasRequiredDes = 1;
      des$1.utils = requireUtils$3();
      des$1.Cipher = requireCipher();
      des$1.DES = requireDes$1();
      des$1.CBC = requireCbc$1();
      des$1.EDE = requireEde();
      return des$1;
    }
    var browserifyDes;
    var hasRequiredBrowserifyDes;
    function requireBrowserifyDes() {
      if (hasRequiredBrowserifyDes)
        return browserifyDes;
      hasRequiredBrowserifyDes = 1;
      var CipherBase = requireCipherBase();
      var des2 = requireDes();
      var inherits2 = require$$3$1;
      var Buffer2 = safeBufferExports.Buffer;
      var modes2 = {
        "des-ede3-cbc": des2.CBC.instantiate(des2.EDE),
        "des-ede3": des2.EDE,
        "des-ede-cbc": des2.CBC.instantiate(des2.EDE),
        "des-ede": des2.EDE,
        "des-cbc": des2.CBC.instantiate(des2.DES),
        "des-ecb": des2.DES
      };
      modes2.des = modes2["des-cbc"];
      modes2.des3 = modes2["des-ede3-cbc"];
      browserifyDes = DES;
      inherits2(DES, CipherBase);
      function DES(opts) {
        CipherBase.call(this);
        var modeName = opts.mode.toLowerCase();
        var mode = modes2[modeName];
        var type;
        if (opts.decrypt) {
          type = "decrypt";
        } else {
          type = "encrypt";
        }
        var key2 = opts.key;
        if (!Buffer2.isBuffer(key2)) {
          key2 = Buffer2.from(key2);
        }
        if (modeName === "des-ede" || modeName === "des-ede-cbc") {
          key2 = Buffer2.concat([key2, key2.slice(0, 8)]);
        }
        var iv = opts.iv;
        if (!Buffer2.isBuffer(iv)) {
          iv = Buffer2.from(iv);
        }
        this._des = mode.create({
          key: key2,
          iv,
          type
        });
      }
      DES.prototype._update = function(data) {
        return Buffer2.from(this._des.update(data));
      };
      DES.prototype._final = function() {
        return Buffer2.from(this._des.final());
      };
      return browserifyDes;
    }
    var browser$6 = {};
    var encrypter = {};
    var ecb = {};
    var hasRequiredEcb;
    function requireEcb() {
      if (hasRequiredEcb)
        return ecb;
      hasRequiredEcb = 1;
      ecb.encrypt = function(self2, block) {
        return self2._cipher.encryptBlock(block);
      };
      ecb.decrypt = function(self2, block) {
        return self2._cipher.decryptBlock(block);
      };
      return ecb;
    }
    var cbc = {};
    var bufferXor;
    var hasRequiredBufferXor;
    function requireBufferXor() {
      if (hasRequiredBufferXor)
        return bufferXor;
      hasRequiredBufferXor = 1;
      bufferXor = function xor2(a, b) {
        var length2 = Math.min(a.length, b.length);
        var buffer2 = new Buffer(length2);
        for (var i = 0; i < length2; ++i) {
          buffer2[i] = a[i] ^ b[i];
        }
        return buffer2;
      };
      return bufferXor;
    }
    var hasRequiredCbc;
    function requireCbc() {
      if (hasRequiredCbc)
        return cbc;
      hasRequiredCbc = 1;
      var xor2 = requireBufferXor();
      cbc.encrypt = function(self2, block) {
        var data = xor2(block, self2._prev);
        self2._prev = self2._cipher.encryptBlock(data);
        return self2._prev;
      };
      cbc.decrypt = function(self2, block) {
        var pad2 = self2._prev;
        self2._prev = block;
        var out = self2._cipher.decryptBlock(block);
        return xor2(out, pad2);
      };
      return cbc;
    }
    var cfb = {};
    var hasRequiredCfb;
    function requireCfb() {
      if (hasRequiredCfb)
        return cfb;
      hasRequiredCfb = 1;
      var Buffer2 = safeBufferExports.Buffer;
      var xor2 = requireBufferXor();
      function encryptStart(self2, data, decrypt2) {
        var len = data.length;
        var out = xor2(data, self2._cache);
        self2._cache = self2._cache.slice(len);
        self2._prev = Buffer2.concat([self2._prev, decrypt2 ? data : out]);
        return out;
      }
      cfb.encrypt = function(self2, data, decrypt2) {
        var out = Buffer2.allocUnsafe(0);
        var len;
        while (data.length) {
          if (self2._cache.length === 0) {
            self2._cache = self2._cipher.encryptBlock(self2._prev);
            self2._prev = Buffer2.allocUnsafe(0);
          }
          if (self2._cache.length <= data.length) {
            len = self2._cache.length;
            out = Buffer2.concat([out, encryptStart(self2, data.slice(0, len), decrypt2)]);
            data = data.slice(len);
          } else {
            out = Buffer2.concat([out, encryptStart(self2, data, decrypt2)]);
            break;
          }
        }
        return out;
      };
      return cfb;
    }
    var cfb8 = {};
    var hasRequiredCfb8;
    function requireCfb8() {
      if (hasRequiredCfb8)
        return cfb8;
      hasRequiredCfb8 = 1;
      var Buffer2 = safeBufferExports.Buffer;
      function encryptByte(self2, byteParam, decrypt2) {
        var pad2 = self2._cipher.encryptBlock(self2._prev);
        var out = pad2[0] ^ byteParam;
        self2._prev = Buffer2.concat([
          self2._prev.slice(1),
          Buffer2.from([decrypt2 ? byteParam : out])
        ]);
        return out;
      }
      cfb8.encrypt = function(self2, chunk, decrypt2) {
        var len = chunk.length;
        var out = Buffer2.allocUnsafe(len);
        var i = -1;
        while (++i < len) {
          out[i] = encryptByte(self2, chunk[i], decrypt2);
        }
        return out;
      };
      return cfb8;
    }
    var cfb1 = {};
    var hasRequiredCfb1;
    function requireCfb1() {
      if (hasRequiredCfb1)
        return cfb1;
      hasRequiredCfb1 = 1;
      var Buffer2 = safeBufferExports.Buffer;
      function encryptByte(self2, byteParam, decrypt2) {
        var pad2;
        var i = -1;
        var len = 8;
        var out = 0;
        var bit, value;
        while (++i < len) {
          pad2 = self2._cipher.encryptBlock(self2._prev);
          bit = byteParam & 1 << 7 - i ? 128 : 0;
          value = pad2[0] ^ bit;
          out += (value & 128) >> i % 8;
          self2._prev = shiftIn(self2._prev, decrypt2 ? bit : value);
        }
        return out;
      }
      function shiftIn(buffer2, value) {
        var len = buffer2.length;
        var i = -1;
        var out = Buffer2.allocUnsafe(buffer2.length);
        buffer2 = Buffer2.concat([buffer2, Buffer2.from([value])]);
        while (++i < len) {
          out[i] = buffer2[i] << 1 | buffer2[i + 1] >> 7;
        }
        return out;
      }
      cfb1.encrypt = function(self2, chunk, decrypt2) {
        var len = chunk.length;
        var out = Buffer2.allocUnsafe(len);
        var i = -1;
        while (++i < len) {
          out[i] = encryptByte(self2, chunk[i], decrypt2);
        }
        return out;
      };
      return cfb1;
    }
    var ofb = {};
    var hasRequiredOfb;
    function requireOfb() {
      if (hasRequiredOfb)
        return ofb;
      hasRequiredOfb = 1;
      var xor2 = requireBufferXor();
      function getBlock(self2) {
        self2._prev = self2._cipher.encryptBlock(self2._prev);
        return self2._prev;
      }
      ofb.encrypt = function(self2, chunk) {
        while (self2._cache.length < chunk.length) {
          self2._cache = Buffer.concat([self2._cache, getBlock(self2)]);
        }
        var pad2 = self2._cache.slice(0, chunk.length);
        self2._cache = self2._cache.slice(chunk.length);
        return xor2(chunk, pad2);
      };
      return ofb;
    }
    var ctr = {};
    var incr32_1;
    var hasRequiredIncr32;
    function requireIncr32() {
      if (hasRequiredIncr32)
        return incr32_1;
      hasRequiredIncr32 = 1;
      function incr32(iv) {
        var len = iv.length;
        var item;
        while (len--) {
          item = iv.readUInt8(len);
          if (item === 255) {
            iv.writeUInt8(0, len);
          } else {
            item++;
            iv.writeUInt8(item, len);
            break;
          }
        }
      }
      incr32_1 = incr32;
      return incr32_1;
    }
    var hasRequiredCtr;
    function requireCtr() {
      if (hasRequiredCtr)
        return ctr;
      hasRequiredCtr = 1;
      var xor2 = requireBufferXor();
      var Buffer2 = safeBufferExports.Buffer;
      var incr32 = requireIncr32();
      function getBlock(self2) {
        var out = self2._cipher.encryptBlockRaw(self2._prev);
        incr32(self2._prev);
        return out;
      }
      var blockSize = 16;
      ctr.encrypt = function(self2, chunk) {
        var chunkNum = Math.ceil(chunk.length / blockSize);
        var start = self2._cache.length;
        self2._cache = Buffer2.concat([
          self2._cache,
          Buffer2.allocUnsafe(chunkNum * blockSize)
        ]);
        for (var i = 0; i < chunkNum; i++) {
          var out = getBlock(self2);
          var offset = start + i * blockSize;
          self2._cache.writeUInt32BE(out[0], offset + 0);
          self2._cache.writeUInt32BE(out[1], offset + 4);
          self2._cache.writeUInt32BE(out[2], offset + 8);
          self2._cache.writeUInt32BE(out[3], offset + 12);
        }
        var pad2 = self2._cache.slice(0, chunk.length);
        self2._cache = self2._cache.slice(chunk.length);
        return xor2(chunk, pad2);
      };
      return ctr;
    }
    var aes128 = {
      cipher: "AES",
      key: 128,
      iv: 16,
      mode: "CBC",
      type: "block"
    };
    var aes192 = {
      cipher: "AES",
      key: 192,
      iv: 16,
      mode: "CBC",
      type: "block"
    };
    var aes256 = {
      cipher: "AES",
      key: 256,
      iv: 16,
      mode: "CBC",
      type: "block"
    };
    var require$$2 = {
      "aes-128-ecb": {
        cipher: "AES",
        key: 128,
        iv: 0,
        mode: "ECB",
        type: "block"
      },
      "aes-192-ecb": {
        cipher: "AES",
        key: 192,
        iv: 0,
        mode: "ECB",
        type: "block"
      },
      "aes-256-ecb": {
        cipher: "AES",
        key: 256,
        iv: 0,
        mode: "ECB",
        type: "block"
      },
      "aes-128-cbc": {
        cipher: "AES",
        key: 128,
        iv: 16,
        mode: "CBC",
        type: "block"
      },
      "aes-192-cbc": {
        cipher: "AES",
        key: 192,
        iv: 16,
        mode: "CBC",
        type: "block"
      },
      "aes-256-cbc": {
        cipher: "AES",
        key: 256,
        iv: 16,
        mode: "CBC",
        type: "block"
      },
      aes128,
      aes192,
      aes256,
      "aes-128-cfb": {
        cipher: "AES",
        key: 128,
        iv: 16,
        mode: "CFB",
        type: "stream"
      },
      "aes-192-cfb": {
        cipher: "AES",
        key: 192,
        iv: 16,
        mode: "CFB",
        type: "stream"
      },
      "aes-256-cfb": {
        cipher: "AES",
        key: 256,
        iv: 16,
        mode: "CFB",
        type: "stream"
      },
      "aes-128-cfb8": {
        cipher: "AES",
        key: 128,
        iv: 16,
        mode: "CFB8",
        type: "stream"
      },
      "aes-192-cfb8": {
        cipher: "AES",
        key: 192,
        iv: 16,
        mode: "CFB8",
        type: "stream"
      },
      "aes-256-cfb8": {
        cipher: "AES",
        key: 256,
        iv: 16,
        mode: "CFB8",
        type: "stream"
      },
      "aes-128-cfb1": {
        cipher: "AES",
        key: 128,
        iv: 16,
        mode: "CFB1",
        type: "stream"
      },
      "aes-192-cfb1": {
        cipher: "AES",
        key: 192,
        iv: 16,
        mode: "CFB1",
        type: "stream"
      },
      "aes-256-cfb1": {
        cipher: "AES",
        key: 256,
        iv: 16,
        mode: "CFB1",
        type: "stream"
      },
      "aes-128-ofb": {
        cipher: "AES",
        key: 128,
        iv: 16,
        mode: "OFB",
        type: "stream"
      },
      "aes-192-ofb": {
        cipher: "AES",
        key: 192,
        iv: 16,
        mode: "OFB",
        type: "stream"
      },
      "aes-256-ofb": {
        cipher: "AES",
        key: 256,
        iv: 16,
        mode: "OFB",
        type: "stream"
      },
      "aes-128-ctr": {
        cipher: "AES",
        key: 128,
        iv: 16,
        mode: "CTR",
        type: "stream"
      },
      "aes-192-ctr": {
        cipher: "AES",
        key: 192,
        iv: 16,
        mode: "CTR",
        type: "stream"
      },
      "aes-256-ctr": {
        cipher: "AES",
        key: 256,
        iv: 16,
        mode: "CTR",
        type: "stream"
      },
      "aes-128-gcm": {
        cipher: "AES",
        key: 128,
        iv: 12,
        mode: "GCM",
        type: "auth"
      },
      "aes-192-gcm": {
        cipher: "AES",
        key: 192,
        iv: 12,
        mode: "GCM",
        type: "auth"
      },
      "aes-256-gcm": {
        cipher: "AES",
        key: 256,
        iv: 12,
        mode: "GCM",
        type: "auth"
      }
    };
    var modes_1;
    var hasRequiredModes$1;
    function requireModes$1() {
      if (hasRequiredModes$1)
        return modes_1;
      hasRequiredModes$1 = 1;
      var modeModules = {
        ECB: requireEcb(),
        CBC: requireCbc(),
        CFB: requireCfb(),
        CFB8: requireCfb8(),
        CFB1: requireCfb1(),
        OFB: requireOfb(),
        CTR: requireCtr(),
        GCM: requireCtr()
      };
      var modes2 = require$$2;
      for (var key2 in modes2) {
        modes2[key2].module = modeModules[modes2[key2].mode];
      }
      modes_1 = modes2;
      return modes_1;
    }
    var aes$1 = {};
    var hasRequiredAes;
    function requireAes() {
      if (hasRequiredAes)
        return aes$1;
      hasRequiredAes = 1;
      var Buffer2 = safeBufferExports.Buffer;
      function asUInt32Array(buf2) {
        if (!Buffer2.isBuffer(buf2))
          buf2 = Buffer2.from(buf2);
        var len = buf2.length / 4 | 0;
        var out = new Array(len);
        for (var i = 0; i < len; i++) {
          out[i] = buf2.readUInt32BE(i * 4);
        }
        return out;
      }
      function scrubVec(v2) {
        for (var i = 0; i < v2.length; v2++) {
          v2[i] = 0;
        }
      }
      function cryptBlock(M, keySchedule, SUB_MIX, SBOX, nRounds) {
        var SUB_MIX0 = SUB_MIX[0];
        var SUB_MIX1 = SUB_MIX[1];
        var SUB_MIX2 = SUB_MIX[2];
        var SUB_MIX3 = SUB_MIX[3];
        var s0 = M[0] ^ keySchedule[0];
        var s1 = M[1] ^ keySchedule[1];
        var s2 = M[2] ^ keySchedule[2];
        var s3 = M[3] ^ keySchedule[3];
        var t0, t1, t2, t3;
        var ksRow = 4;
        for (var round = 1; round < nRounds; round++) {
          t0 = SUB_MIX0[s0 >>> 24] ^ SUB_MIX1[s1 >>> 16 & 255] ^ SUB_MIX2[s2 >>> 8 & 255] ^ SUB_MIX3[s3 & 255] ^ keySchedule[ksRow++];
          t1 = SUB_MIX0[s1 >>> 24] ^ SUB_MIX1[s2 >>> 16 & 255] ^ SUB_MIX2[s3 >>> 8 & 255] ^ SUB_MIX3[s0 & 255] ^ keySchedule[ksRow++];
          t2 = SUB_MIX0[s2 >>> 24] ^ SUB_MIX1[s3 >>> 16 & 255] ^ SUB_MIX2[s0 >>> 8 & 255] ^ SUB_MIX3[s1 & 255] ^ keySchedule[ksRow++];
          t3 = SUB_MIX0[s3 >>> 24] ^ SUB_MIX1[s0 >>> 16 & 255] ^ SUB_MIX2[s1 >>> 8 & 255] ^ SUB_MIX3[s2 & 255] ^ keySchedule[ksRow++];
          s0 = t0;
          s1 = t1;
          s2 = t2;
          s3 = t3;
        }
        t0 = (SBOX[s0 >>> 24] << 24 | SBOX[s1 >>> 16 & 255] << 16 | SBOX[s2 >>> 8 & 255] << 8 | SBOX[s3 & 255]) ^ keySchedule[ksRow++];
        t1 = (SBOX[s1 >>> 24] << 24 | SBOX[s2 >>> 16 & 255] << 16 | SBOX[s3 >>> 8 & 255] << 8 | SBOX[s0 & 255]) ^ keySchedule[ksRow++];
        t2 = (SBOX[s2 >>> 24] << 24 | SBOX[s3 >>> 16 & 255] << 16 | SBOX[s0 >>> 8 & 255] << 8 | SBOX[s1 & 255]) ^ keySchedule[ksRow++];
        t3 = (SBOX[s3 >>> 24] << 24 | SBOX[s0 >>> 16 & 255] << 16 | SBOX[s1 >>> 8 & 255] << 8 | SBOX[s2 & 255]) ^ keySchedule[ksRow++];
        t0 = t0 >>> 0;
        t1 = t1 >>> 0;
        t2 = t2 >>> 0;
        t3 = t3 >>> 0;
        return [t0, t1, t2, t3];
      }
      var RCON = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54];
      var G = function() {
        var d = new Array(256);
        for (var j = 0; j < 256; j++) {
          if (j < 128) {
            d[j] = j << 1;
          } else {
            d[j] = j << 1 ^ 283;
          }
        }
        var SBOX = [];
        var INV_SBOX = [];
        var SUB_MIX = [[], [], [], []];
        var INV_SUB_MIX = [[], [], [], []];
        var x = 0;
        var xi = 0;
        for (var i = 0; i < 256; ++i) {
          var sx = xi ^ xi << 1 ^ xi << 2 ^ xi << 3 ^ xi << 4;
          sx = sx >>> 8 ^ sx & 255 ^ 99;
          SBOX[x] = sx;
          INV_SBOX[sx] = x;
          var x2 = d[x];
          var x4 = d[x2];
          var x8 = d[x4];
          var t = d[sx] * 257 ^ sx * 16843008;
          SUB_MIX[0][x] = t << 24 | t >>> 8;
          SUB_MIX[1][x] = t << 16 | t >>> 16;
          SUB_MIX[2][x] = t << 8 | t >>> 24;
          SUB_MIX[3][x] = t;
          t = x8 * 16843009 ^ x4 * 65537 ^ x2 * 257 ^ x * 16843008;
          INV_SUB_MIX[0][sx] = t << 24 | t >>> 8;
          INV_SUB_MIX[1][sx] = t << 16 | t >>> 16;
          INV_SUB_MIX[2][sx] = t << 8 | t >>> 24;
          INV_SUB_MIX[3][sx] = t;
          if (x === 0) {
            x = xi = 1;
          } else {
            x = x2 ^ d[d[d[x8 ^ x2]]];
            xi ^= d[d[xi]];
          }
        }
        return {
          SBOX,
          INV_SBOX,
          SUB_MIX,
          INV_SUB_MIX
        };
      }();
      function AES(key2) {
        this._key = asUInt32Array(key2);
        this._reset();
      }
      AES.blockSize = 4 * 4;
      AES.keySize = 256 / 8;
      AES.prototype.blockSize = AES.blockSize;
      AES.prototype.keySize = AES.keySize;
      AES.prototype._reset = function() {
        var keyWords = this._key;
        var keySize = keyWords.length;
        var nRounds = keySize + 6;
        var ksRows = (nRounds + 1) * 4;
        var keySchedule = [];
        for (var k = 0; k < keySize; k++) {
          keySchedule[k] = keyWords[k];
        }
        for (k = keySize; k < ksRows; k++) {
          var t = keySchedule[k - 1];
          if (k % keySize === 0) {
            t = t << 8 | t >>> 24;
            t = G.SBOX[t >>> 24] << 24 | G.SBOX[t >>> 16 & 255] << 16 | G.SBOX[t >>> 8 & 255] << 8 | G.SBOX[t & 255];
            t ^= RCON[k / keySize | 0] << 24;
          } else if (keySize > 6 && k % keySize === 4) {
            t = G.SBOX[t >>> 24] << 24 | G.SBOX[t >>> 16 & 255] << 16 | G.SBOX[t >>> 8 & 255] << 8 | G.SBOX[t & 255];
          }
          keySchedule[k] = keySchedule[k - keySize] ^ t;
        }
        var invKeySchedule = [];
        for (var ik = 0; ik < ksRows; ik++) {
          var ksR = ksRows - ik;
          var tt = keySchedule[ksR - (ik % 4 ? 0 : 4)];
          if (ik < 4 || ksR <= 4) {
            invKeySchedule[ik] = tt;
          } else {
            invKeySchedule[ik] = G.INV_SUB_MIX[0][G.SBOX[tt >>> 24]] ^ G.INV_SUB_MIX[1][G.SBOX[tt >>> 16 & 255]] ^ G.INV_SUB_MIX[2][G.SBOX[tt >>> 8 & 255]] ^ G.INV_SUB_MIX[3][G.SBOX[tt & 255]];
          }
        }
        this._nRounds = nRounds;
        this._keySchedule = keySchedule;
        this._invKeySchedule = invKeySchedule;
      };
      AES.prototype.encryptBlockRaw = function(M) {
        M = asUInt32Array(M);
        return cryptBlock(M, this._keySchedule, G.SUB_MIX, G.SBOX, this._nRounds);
      };
      AES.prototype.encryptBlock = function(M) {
        var out = this.encryptBlockRaw(M);
        var buf2 = Buffer2.allocUnsafe(16);
        buf2.writeUInt32BE(out[0], 0);
        buf2.writeUInt32BE(out[1], 4);
        buf2.writeUInt32BE(out[2], 8);
        buf2.writeUInt32BE(out[3], 12);
        return buf2;
      };
      AES.prototype.decryptBlock = function(M) {
        M = asUInt32Array(M);
        var m1 = M[1];
        M[1] = M[3];
        M[3] = m1;
        var out = cryptBlock(M, this._invKeySchedule, G.INV_SUB_MIX, G.INV_SBOX, this._nRounds);
        var buf2 = Buffer2.allocUnsafe(16);
        buf2.writeUInt32BE(out[0], 0);
        buf2.writeUInt32BE(out[3], 4);
        buf2.writeUInt32BE(out[2], 8);
        buf2.writeUInt32BE(out[1], 12);
        return buf2;
      };
      AES.prototype.scrub = function() {
        scrubVec(this._keySchedule);
        scrubVec(this._invKeySchedule);
        scrubVec(this._key);
      };
      aes$1.AES = AES;
      return aes$1;
    }
    var ghash;
    var hasRequiredGhash;
    function requireGhash() {
      if (hasRequiredGhash)
        return ghash;
      hasRequiredGhash = 1;
      var Buffer2 = safeBufferExports.Buffer;
      var ZEROES = Buffer2.alloc(16, 0);
      function toArray(buf2) {
        return [
          buf2.readUInt32BE(0),
          buf2.readUInt32BE(4),
          buf2.readUInt32BE(8),
          buf2.readUInt32BE(12)
        ];
      }
      function fromArray2(out) {
        var buf2 = Buffer2.allocUnsafe(16);
        buf2.writeUInt32BE(out[0] >>> 0, 0);
        buf2.writeUInt32BE(out[1] >>> 0, 4);
        buf2.writeUInt32BE(out[2] >>> 0, 8);
        buf2.writeUInt32BE(out[3] >>> 0, 12);
        return buf2;
      }
      function GHASH(key2) {
        this.h = key2;
        this.state = Buffer2.alloc(16, 0);
        this.cache = Buffer2.allocUnsafe(0);
      }
      GHASH.prototype.ghash = function(block) {
        var i = -1;
        while (++i < block.length) {
          this.state[i] ^= block[i];
        }
        this._multiply();
      };
      GHASH.prototype._multiply = function() {
        var Vi = toArray(this.h);
        var Zi = [0, 0, 0, 0];
        var j, xi, lsbVi;
        var i = -1;
        while (++i < 128) {
          xi = (this.state[~~(i / 8)] & 1 << 7 - i % 8) !== 0;
          if (xi) {
            Zi[0] ^= Vi[0];
            Zi[1] ^= Vi[1];
            Zi[2] ^= Vi[2];
            Zi[3] ^= Vi[3];
          }
          lsbVi = (Vi[3] & 1) !== 0;
          for (j = 3; j > 0; j--) {
            Vi[j] = Vi[j] >>> 1 | (Vi[j - 1] & 1) << 31;
          }
          Vi[0] = Vi[0] >>> 1;
          if (lsbVi) {
            Vi[0] = Vi[0] ^ 225 << 24;
          }
        }
        this.state = fromArray2(Zi);
      };
      GHASH.prototype.update = function(buf2) {
        this.cache = Buffer2.concat([this.cache, buf2]);
        var chunk;
        while (this.cache.length >= 16) {
          chunk = this.cache.slice(0, 16);
          this.cache = this.cache.slice(16);
          this.ghash(chunk);
        }
      };
      GHASH.prototype.final = function(abl, bl) {
        if (this.cache.length) {
          this.ghash(Buffer2.concat([this.cache, ZEROES], 16));
        }
        this.ghash(fromArray2([0, abl, 0, bl]));
        return this.state;
      };
      ghash = GHASH;
      return ghash;
    }
    var authCipher;
    var hasRequiredAuthCipher;
    function requireAuthCipher() {
      if (hasRequiredAuthCipher)
        return authCipher;
      hasRequiredAuthCipher = 1;
      var aes2 = requireAes();
      var Buffer2 = safeBufferExports.Buffer;
      var Transform2 = requireCipherBase();
      var inherits2 = require$$3$1;
      var GHASH = requireGhash();
      var xor2 = requireBufferXor();
      var incr32 = requireIncr32();
      function xorTest(a, b) {
        var out = 0;
        if (a.length !== b.length)
          out++;
        var len = Math.min(a.length, b.length);
        for (var i = 0; i < len; ++i) {
          out += a[i] ^ b[i];
        }
        return out;
      }
      function calcIv(self2, iv, ck) {
        if (iv.length === 12) {
          self2._finID = Buffer2.concat([iv, Buffer2.from([0, 0, 0, 1])]);
          return Buffer2.concat([iv, Buffer2.from([0, 0, 0, 2])]);
        }
        var ghash2 = new GHASH(ck);
        var len = iv.length;
        var toPad = len % 16;
        ghash2.update(iv);
        if (toPad) {
          toPad = 16 - toPad;
          ghash2.update(Buffer2.alloc(toPad, 0));
        }
        ghash2.update(Buffer2.alloc(8, 0));
        var ivBits = len * 8;
        var tail = Buffer2.alloc(8);
        tail.writeUIntBE(ivBits, 0, 8);
        ghash2.update(tail);
        self2._finID = ghash2.state;
        var out = Buffer2.from(self2._finID);
        incr32(out);
        return out;
      }
      function StreamCipher(mode, key2, iv, decrypt2) {
        Transform2.call(this);
        var h = Buffer2.alloc(4, 0);
        this._cipher = new aes2.AES(key2);
        var ck = this._cipher.encryptBlock(h);
        this._ghash = new GHASH(ck);
        iv = calcIv(this, iv, ck);
        this._prev = Buffer2.from(iv);
        this._cache = Buffer2.allocUnsafe(0);
        this._secCache = Buffer2.allocUnsafe(0);
        this._decrypt = decrypt2;
        this._alen = 0;
        this._len = 0;
        this._mode = mode;
        this._authTag = null;
        this._called = false;
      }
      inherits2(StreamCipher, Transform2);
      StreamCipher.prototype._update = function(chunk) {
        if (!this._called && this._alen) {
          var rump = 16 - this._alen % 16;
          if (rump < 16) {
            rump = Buffer2.alloc(rump, 0);
            this._ghash.update(rump);
          }
        }
        this._called = true;
        var out = this._mode.encrypt(this, chunk);
        if (this._decrypt) {
          this._ghash.update(chunk);
        } else {
          this._ghash.update(out);
        }
        this._len += chunk.length;
        return out;
      };
      StreamCipher.prototype._final = function() {
        if (this._decrypt && !this._authTag)
          throw new Error("Unsupported state or unable to authenticate data");
        var tag = xor2(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID));
        if (this._decrypt && xorTest(tag, this._authTag))
          throw new Error("Unsupported state or unable to authenticate data");
        this._authTag = tag;
        this._cipher.scrub();
      };
      StreamCipher.prototype.getAuthTag = function getAuthTag() {
        if (this._decrypt || !Buffer2.isBuffer(this._authTag))
          throw new Error("Attempting to get auth tag in unsupported state");
        return this._authTag;
      };
      StreamCipher.prototype.setAuthTag = function setAuthTag(tag) {
        if (!this._decrypt)
          throw new Error("Attempting to set auth tag in unsupported state");
        this._authTag = tag;
      };
      StreamCipher.prototype.setAAD = function setAAD(buf2) {
        if (this._called)
          throw new Error("Attempting to set AAD in unsupported state");
        this._ghash.update(buf2);
        this._alen += buf2.length;
      };
      authCipher = StreamCipher;
      return authCipher;
    }
    var streamCipher;
    var hasRequiredStreamCipher;
    function requireStreamCipher() {
      if (hasRequiredStreamCipher)
        return streamCipher;
      hasRequiredStreamCipher = 1;
      var aes2 = requireAes();
      var Buffer2 = safeBufferExports.Buffer;
      var Transform2 = requireCipherBase();
      var inherits2 = require$$3$1;
      function StreamCipher(mode, key2, iv, decrypt2) {
        Transform2.call(this);
        this._cipher = new aes2.AES(key2);
        this._prev = Buffer2.from(iv);
        this._cache = Buffer2.allocUnsafe(0);
        this._secCache = Buffer2.allocUnsafe(0);
        this._decrypt = decrypt2;
        this._mode = mode;
      }
      inherits2(StreamCipher, Transform2);
      StreamCipher.prototype._update = function(chunk) {
        return this._mode.encrypt(this, chunk, this._decrypt);
      };
      StreamCipher.prototype._final = function() {
        this._cipher.scrub();
      };
      streamCipher = StreamCipher;
      return streamCipher;
    }
    var evp_bytestokey;
    var hasRequiredEvp_bytestokey;
    function requireEvp_bytestokey() {
      if (hasRequiredEvp_bytestokey)
        return evp_bytestokey;
      hasRequiredEvp_bytestokey = 1;
      var Buffer2 = safeBufferExports.Buffer;
      var MD5 = requireMd5_js();
      function EVP_BytesToKey(password, salt, keyBits, ivLen) {
        if (!Buffer2.isBuffer(password))
          password = Buffer2.from(password, "binary");
        if (salt) {
          if (!Buffer2.isBuffer(salt))
            salt = Buffer2.from(salt, "binary");
          if (salt.length !== 8)
            throw new RangeError("salt should be Buffer with 8 byte length");
        }
        var keyLen = keyBits / 8;
        var key2 = Buffer2.alloc(keyLen);
        var iv = Buffer2.alloc(ivLen || 0);
        var tmp = Buffer2.alloc(0);
        while (keyLen > 0 || ivLen > 0) {
          var hash2 = new MD5();
          hash2.update(tmp);
          hash2.update(password);
          if (salt)
            hash2.update(salt);
          tmp = hash2.digest();
          var used = 0;
          if (keyLen > 0) {
            var keyStart = key2.length - keyLen;
            used = Math.min(keyLen, tmp.length);
            tmp.copy(key2, keyStart, 0, used);
            keyLen -= used;
          }
          if (used < tmp.length && ivLen > 0) {
            var ivStart = iv.length - ivLen;
            var length2 = Math.min(ivLen, tmp.length - used);
            tmp.copy(iv, ivStart, used, used + length2);
            ivLen -= length2;
          }
        }
        tmp.fill(0);
        return {key: key2, iv};
      }
      evp_bytestokey = EVP_BytesToKey;
      return evp_bytestokey;
    }
    var hasRequiredEncrypter;
    function requireEncrypter() {
      if (hasRequiredEncrypter)
        return encrypter;
      hasRequiredEncrypter = 1;
      var MODES = requireModes$1();
      var AuthCipher = requireAuthCipher();
      var Buffer2 = safeBufferExports.Buffer;
      var StreamCipher = requireStreamCipher();
      var Transform2 = requireCipherBase();
      var aes2 = requireAes();
      var ebtk = requireEvp_bytestokey();
      var inherits2 = require$$3$1;
      function Cipher(mode, key2, iv) {
        Transform2.call(this);
        this._cache = new Splitter();
        this._cipher = new aes2.AES(key2);
        this._prev = Buffer2.from(iv);
        this._mode = mode;
        this._autopadding = true;
      }
      inherits2(Cipher, Transform2);
      Cipher.prototype._update = function(data) {
        this._cache.add(data);
        var chunk;
        var thing;
        var out = [];
        while (chunk = this._cache.get()) {
          thing = this._mode.encrypt(this, chunk);
          out.push(thing);
        }
        return Buffer2.concat(out);
      };
      var PADDING = Buffer2.alloc(16, 16);
      Cipher.prototype._final = function() {
        var chunk = this._cache.flush();
        if (this._autopadding) {
          chunk = this._mode.encrypt(this, chunk);
          this._cipher.scrub();
          return chunk;
        }
        if (!chunk.equals(PADDING)) {
          this._cipher.scrub();
          throw new Error("data not multiple of block length");
        }
      };
      Cipher.prototype.setAutoPadding = function(setTo) {
        this._autopadding = !!setTo;
        return this;
      };
      function Splitter() {
        this.cache = Buffer2.allocUnsafe(0);
      }
      Splitter.prototype.add = function(data) {
        this.cache = Buffer2.concat([this.cache, data]);
      };
      Splitter.prototype.get = function() {
        if (this.cache.length > 15) {
          var out = this.cache.slice(0, 16);
          this.cache = this.cache.slice(16);
          return out;
        }
        return null;
      };
      Splitter.prototype.flush = function() {
        var len = 16 - this.cache.length;
        var padBuff = Buffer2.allocUnsafe(len);
        var i = -1;
        while (++i < len) {
          padBuff.writeUInt8(len, i);
        }
        return Buffer2.concat([this.cache, padBuff]);
      };
      function createCipheriv(suite, password, iv) {
        var config2 = MODES[suite.toLowerCase()];
        if (!config2)
          throw new TypeError("invalid suite type");
        if (typeof password === "string")
          password = Buffer2.from(password);
        if (password.length !== config2.key / 8)
          throw new TypeError("invalid key length " + password.length);
        if (typeof iv === "string")
          iv = Buffer2.from(iv);
        if (config2.mode !== "GCM" && iv.length !== config2.iv)
          throw new TypeError("invalid iv length " + iv.length);
        if (config2.type === "stream") {
          return new StreamCipher(config2.module, password, iv);
        } else if (config2.type === "auth") {
          return new AuthCipher(config2.module, password, iv);
        }
        return new Cipher(config2.module, password, iv);
      }
      function createCipher(suite, password) {
        var config2 = MODES[suite.toLowerCase()];
        if (!config2)
          throw new TypeError("invalid suite type");
        var keys2 = ebtk(password, false, config2.key, config2.iv);
        return createCipheriv(suite, keys2.key, keys2.iv);
      }
      encrypter.createCipheriv = createCipheriv;
      encrypter.createCipher = createCipher;
      return encrypter;
    }
    var decrypter = {};
    var hasRequiredDecrypter;
    function requireDecrypter() {
      if (hasRequiredDecrypter)
        return decrypter;
      hasRequiredDecrypter = 1;
      var AuthCipher = requireAuthCipher();
      var Buffer2 = safeBufferExports.Buffer;
      var MODES = requireModes$1();
      var StreamCipher = requireStreamCipher();
      var Transform2 = requireCipherBase();
      var aes2 = requireAes();
      var ebtk = requireEvp_bytestokey();
      var inherits2 = require$$3$1;
      function Decipher(mode, key2, iv) {
        Transform2.call(this);
        this._cache = new Splitter();
        this._last = void 0;
        this._cipher = new aes2.AES(key2);
        this._prev = Buffer2.from(iv);
        this._mode = mode;
        this._autopadding = true;
      }
      inherits2(Decipher, Transform2);
      Decipher.prototype._update = function(data) {
        this._cache.add(data);
        var chunk;
        var thing;
        var out = [];
        while (chunk = this._cache.get(this._autopadding)) {
          thing = this._mode.decrypt(this, chunk);
          out.push(thing);
        }
        return Buffer2.concat(out);
      };
      Decipher.prototype._final = function() {
        var chunk = this._cache.flush();
        if (this._autopadding) {
          return unpad(this._mode.decrypt(this, chunk));
        } else if (chunk) {
          throw new Error("data not multiple of block length");
        }
      };
      Decipher.prototype.setAutoPadding = function(setTo) {
        this._autopadding = !!setTo;
        return this;
      };
      function Splitter() {
        this.cache = Buffer2.allocUnsafe(0);
      }
      Splitter.prototype.add = function(data) {
        this.cache = Buffer2.concat([this.cache, data]);
      };
      Splitter.prototype.get = function(autoPadding) {
        var out;
        if (autoPadding) {
          if (this.cache.length > 16) {
            out = this.cache.slice(0, 16);
            this.cache = this.cache.slice(16);
            return out;
          }
        } else {
          if (this.cache.length >= 16) {
            out = this.cache.slice(0, 16);
            this.cache = this.cache.slice(16);
            return out;
          }
        }
        return null;
      };
      Splitter.prototype.flush = function() {
        if (this.cache.length)
          return this.cache;
      };
      function unpad(last) {
        var padded = last[15];
        if (padded < 1 || padded > 16) {
          throw new Error("unable to decrypt data");
        }
        var i = -1;
        while (++i < padded) {
          if (last[i + (16 - padded)] !== padded) {
            throw new Error("unable to decrypt data");
          }
        }
        if (padded === 16)
          return;
        return last.slice(0, 16 - padded);
      }
      function createDecipheriv(suite, password, iv) {
        var config2 = MODES[suite.toLowerCase()];
        if (!config2)
          throw new TypeError("invalid suite type");
        if (typeof iv === "string")
          iv = Buffer2.from(iv);
        if (config2.mode !== "GCM" && iv.length !== config2.iv)
          throw new TypeError("invalid iv length " + iv.length);
        if (typeof password === "string")
          password = Buffer2.from(password);
        if (password.length !== config2.key / 8)
          throw new TypeError("invalid key length " + password.length);
        if (config2.type === "stream") {
          return new StreamCipher(config2.module, password, iv, true);
        } else if (config2.type === "auth") {
          return new AuthCipher(config2.module, password, iv, true);
        }
        return new Decipher(config2.module, password, iv);
      }
      function createDecipher(suite, password) {
        var config2 = MODES[suite.toLowerCase()];
        if (!config2)
          throw new TypeError("invalid suite type");
        var keys2 = ebtk(password, false, config2.key, config2.iv);
        return createDecipheriv(suite, keys2.key, keys2.iv);
      }
      decrypter.createDecipher = createDecipher;
      decrypter.createDecipheriv = createDecipheriv;
      return decrypter;
    }
    var hasRequiredBrowser$6;
    function requireBrowser$6() {
      if (hasRequiredBrowser$6)
        return browser$6;
      hasRequiredBrowser$6 = 1;
      var ciphers2 = requireEncrypter();
      var deciphers = requireDecrypter();
      var modes2 = require$$2;
      function getCiphers() {
        return Object.keys(modes2);
      }
      browser$6.createCipher = browser$6.Cipher = ciphers2.createCipher;
      browser$6.createCipheriv = browser$6.Cipheriv = ciphers2.createCipheriv;
      browser$6.createDecipher = browser$6.Decipher = deciphers.createDecipher;
      browser$6.createDecipheriv = browser$6.Decipheriv = deciphers.createDecipheriv;
      browser$6.listCiphers = browser$6.getCiphers = getCiphers;
      return browser$6;
    }
    var modes = {};
    var hasRequiredModes;
    function requireModes() {
      if (hasRequiredModes)
        return modes;
      hasRequiredModes = 1;
      (function(exports2) {
        exports2["des-ecb"] = {
          key: 8,
          iv: 0
        };
        exports2["des-cbc"] = exports2.des = {
          key: 8,
          iv: 8
        };
        exports2["des-ede3-cbc"] = exports2.des3 = {
          key: 24,
          iv: 8
        };
        exports2["des-ede3"] = {
          key: 24,
          iv: 0
        };
        exports2["des-ede-cbc"] = {
          key: 16,
          iv: 8
        };
        exports2["des-ede"] = {
          key: 16,
          iv: 0
        };
      })(modes);
      return modes;
    }
    var hasRequiredBrowser$5;
    function requireBrowser$5() {
      if (hasRequiredBrowser$5)
        return browser$7;
      hasRequiredBrowser$5 = 1;
      var DES = requireBrowserifyDes();
      var aes2 = requireBrowser$6();
      var aesModes = requireModes$1();
      var desModes = requireModes();
      var ebtk = requireEvp_bytestokey();
      function createCipher(suite, password) {
        suite = suite.toLowerCase();
        var keyLen, ivLen;
        if (aesModes[suite]) {
          keyLen = aesModes[suite].key;
          ivLen = aesModes[suite].iv;
        } else if (desModes[suite]) {
          keyLen = desModes[suite].key * 8;
          ivLen = desModes[suite].iv;
        } else {
          throw new TypeError("invalid suite type");
        }
        var keys2 = ebtk(password, false, keyLen, ivLen);
        return createCipheriv(suite, keys2.key, keys2.iv);
      }
      function createDecipher(suite, password) {
        suite = suite.toLowerCase();
        var keyLen, ivLen;
        if (aesModes[suite]) {
          keyLen = aesModes[suite].key;
          ivLen = aesModes[suite].iv;
        } else if (desModes[suite]) {
          keyLen = desModes[suite].key * 8;
          ivLen = desModes[suite].iv;
        } else {
          throw new TypeError("invalid suite type");
        }
        var keys2 = ebtk(password, false, keyLen, ivLen);
        return createDecipheriv(suite, keys2.key, keys2.iv);
      }
      function createCipheriv(suite, key2, iv) {
        suite = suite.toLowerCase();
        if (aesModes[suite])
          return aes2.createCipheriv(suite, key2, iv);
        if (desModes[suite])
          return new DES({key: key2, iv, mode: suite});
        throw new TypeError("invalid suite type");
      }
      function createDecipheriv(suite, key2, iv) {
        suite = suite.toLowerCase();
        if (aesModes[suite])
          return aes2.createDecipheriv(suite, key2, iv);
        if (desModes[suite])
          return new DES({key: key2, iv, mode: suite, decrypt: true});
        throw new TypeError("invalid suite type");
      }
      function getCiphers() {
        return Object.keys(desModes).concat(aes2.getCiphers());
      }
      browser$7.createCipher = browser$7.Cipher = createCipher;
      browser$7.createCipheriv = browser$7.Cipheriv = createCipheriv;
      browser$7.createDecipher = browser$7.Decipher = createDecipher;
      browser$7.createDecipheriv = browser$7.Decipheriv = createDecipheriv;
      browser$7.listCiphers = browser$7.getCiphers = getCiphers;
      return browser$7;
    }
    var browser$5 = {};
    var bnExports$1 = {};
    var bn$1 = {
      get exports() {
        return bnExports$1;
      },
      set exports(v2) {
        bnExports$1 = v2;
      }
    };
    var hasRequiredBn$1;
    function requireBn$1() {
      if (hasRequiredBn$1)
        return bnExports$1;
      hasRequiredBn$1 = 1;
      (function(module2) {
        (function(module3, exports2) {
          function assert2(val, msg) {
            if (!val)
              throw new Error(msg || "Assertion failed");
          }
          function inherits2(ctor, superCtor) {
            ctor.super_ = superCtor;
            var TempCtor = function() {
            };
            TempCtor.prototype = superCtor.prototype;
            ctor.prototype = new TempCtor();
            ctor.prototype.constructor = ctor;
          }
          function BN(number2, base2, endian) {
            if (BN.isBN(number2)) {
              return number2;
            }
            this.negative = 0;
            this.words = null;
            this.length = 0;
            this.red = null;
            if (number2 !== null) {
              if (base2 === "le" || base2 === "be") {
                endian = base2;
                base2 = 10;
              }
              this._init(number2 || 0, base2 || 10, endian || "be");
            }
          }
          if (typeof module3 === "object") {
            module3.exports = BN;
          } else {
            exports2.BN = BN;
          }
          BN.BN = BN;
          BN.wordSize = 26;
          var Buffer2;
          try {
            if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
              Buffer2 = window.Buffer;
            } else {
              Buffer2 = require$$6$1.Buffer;
            }
          } catch (e) {
          }
          BN.isBN = function isBN(num) {
            if (num instanceof BN) {
              return true;
            }
            return num !== null && typeof num === "object" && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
          };
          BN.max = function max(left, right) {
            if (left.cmp(right) > 0)
              return left;
            return right;
          };
          BN.min = function min(left, right) {
            if (left.cmp(right) < 0)
              return left;
            return right;
          };
          BN.prototype._init = function init2(number2, base2, endian) {
            if (typeof number2 === "number") {
              return this._initNumber(number2, base2, endian);
            }
            if (typeof number2 === "object") {
              return this._initArray(number2, base2, endian);
            }
            if (base2 === "hex") {
              base2 = 16;
            }
            assert2(base2 === (base2 | 0) && base2 >= 2 && base2 <= 36);
            number2 = number2.toString().replace(/\s+/g, "");
            var start = 0;
            if (number2[0] === "-") {
              start++;
              this.negative = 1;
            }
            if (start < number2.length) {
              if (base2 === 16) {
                this._parseHex(number2, start, endian);
              } else {
                this._parseBase(number2, base2, start);
                if (endian === "le") {
                  this._initArray(this.toArray(), base2, endian);
                }
              }
            }
          };
          BN.prototype._initNumber = function _initNumber(number2, base2, endian) {
            if (number2 < 0) {
              this.negative = 1;
              number2 = -number2;
            }
            if (number2 < 67108864) {
              this.words = [number2 & 67108863];
              this.length = 1;
            } else if (number2 < 4503599627370496) {
              this.words = [
                number2 & 67108863,
                number2 / 67108864 & 67108863
              ];
              this.length = 2;
            } else {
              assert2(number2 < 9007199254740992);
              this.words = [
                number2 & 67108863,
                number2 / 67108864 & 67108863,
                1
              ];
              this.length = 3;
            }
            if (endian !== "le")
              return;
            this._initArray(this.toArray(), base2, endian);
          };
          BN.prototype._initArray = function _initArray(number2, base2, endian) {
            assert2(typeof number2.length === "number");
            if (number2.length <= 0) {
              this.words = [0];
              this.length = 1;
              return this;
            }
            this.length = Math.ceil(number2.length / 3);
            this.words = new Array(this.length);
            for (var i = 0; i < this.length; i++) {
              this.words[i] = 0;
            }
            var j, w;
            var off2 = 0;
            if (endian === "be") {
              for (i = number2.length - 1, j = 0; i >= 0; i -= 3) {
                w = number2[i] | number2[i - 1] << 8 | number2[i - 2] << 16;
                this.words[j] |= w << off2 & 67108863;
                this.words[j + 1] = w >>> 26 - off2 & 67108863;
                off2 += 24;
                if (off2 >= 26) {
                  off2 -= 26;
                  j++;
                }
              }
            } else if (endian === "le") {
              for (i = 0, j = 0; i < number2.length; i += 3) {
                w = number2[i] | number2[i + 1] << 8 | number2[i + 2] << 16;
                this.words[j] |= w << off2 & 67108863;
                this.words[j + 1] = w >>> 26 - off2 & 67108863;
                off2 += 24;
                if (off2 >= 26) {
                  off2 -= 26;
                  j++;
                }
              }
            }
            return this.strip();
          };
          function parseHex4Bits(string, index2) {
            var c = string.charCodeAt(index2);
            if (c >= 65 && c <= 70) {
              return c - 55;
            } else if (c >= 97 && c <= 102) {
              return c - 87;
            } else {
              return c - 48 & 15;
            }
          }
          function parseHexByte(string, lowerBound, index2) {
            var r = parseHex4Bits(string, index2);
            if (index2 - 1 >= lowerBound) {
              r |= parseHex4Bits(string, index2 - 1) << 4;
            }
            return r;
          }
          BN.prototype._parseHex = function _parseHex(number2, start, endian) {
            this.length = Math.ceil((number2.length - start) / 6);
            this.words = new Array(this.length);
            for (var i = 0; i < this.length; i++) {
              this.words[i] = 0;
            }
            var off2 = 0;
            var j = 0;
            var w;
            if (endian === "be") {
              for (i = number2.length - 1; i >= start; i -= 2) {
                w = parseHexByte(number2, start, i) << off2;
                this.words[j] |= w & 67108863;
                if (off2 >= 18) {
                  off2 -= 18;
                  j += 1;
                  this.words[j] |= w >>> 26;
                } else {
                  off2 += 8;
                }
              }
            } else {
              var parseLength = number2.length - start;
              for (i = parseLength % 2 === 0 ? start + 1 : start; i < number2.length; i += 2) {
                w = parseHexByte(number2, start, i) << off2;
                this.words[j] |= w & 67108863;
                if (off2 >= 18) {
                  off2 -= 18;
                  j += 1;
                  this.words[j] |= w >>> 26;
                } else {
                  off2 += 8;
                }
              }
            }
            this.strip();
          };
          function parseBase(str, start, end, mul) {
            var r = 0;
            var len = Math.min(str.length, end);
            for (var i = start; i < len; i++) {
              var c = str.charCodeAt(i) - 48;
              r *= mul;
              if (c >= 49) {
                r += c - 49 + 10;
              } else if (c >= 17) {
                r += c - 17 + 10;
              } else {
                r += c;
              }
            }
            return r;
          }
          BN.prototype._parseBase = function _parseBase(number2, base2, start) {
            this.words = [0];
            this.length = 1;
            for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base2) {
              limbLen++;
            }
            limbLen--;
            limbPow = limbPow / base2 | 0;
            var total = number2.length - start;
            var mod = total % limbLen;
            var end = Math.min(total, total - mod) + start;
            var word = 0;
            for (var i = start; i < end; i += limbLen) {
              word = parseBase(number2, i, i + limbLen, base2);
              this.imuln(limbPow);
              if (this.words[0] + word < 67108864) {
                this.words[0] += word;
              } else {
                this._iaddn(word);
              }
            }
            if (mod !== 0) {
              var pow = 1;
              word = parseBase(number2, i, number2.length, base2);
              for (i = 0; i < mod; i++) {
                pow *= base2;
              }
              this.imuln(pow);
              if (this.words[0] + word < 67108864) {
                this.words[0] += word;
              } else {
                this._iaddn(word);
              }
            }
            this.strip();
          };
          BN.prototype.copy = function copy(dest) {
            dest.words = new Array(this.length);
            for (var i = 0; i < this.length; i++) {
              dest.words[i] = this.words[i];
            }
            dest.length = this.length;
            dest.negative = this.negative;
            dest.red = this.red;
          };
          BN.prototype.clone = function clone() {
            var r = new BN(null);
            this.copy(r);
            return r;
          };
          BN.prototype._expand = function _expand(size) {
            while (this.length < size) {
              this.words[this.length++] = 0;
            }
            return this;
          };
          BN.prototype.strip = function strip() {
            while (this.length > 1 && this.words[this.length - 1] === 0) {
              this.length--;
            }
            return this._normSign();
          };
          BN.prototype._normSign = function _normSign() {
            if (this.length === 1 && this.words[0] === 0) {
              this.negative = 0;
            }
            return this;
          };
          BN.prototype.inspect = function inspect2() {
            return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
          };
          var zeros = [
            "",
            "0",
            "00",
            "000",
            "0000",
            "00000",
            "000000",
            "0000000",
            "00000000",
            "000000000",
            "0000000000",
            "00000000000",
            "000000000000",
            "0000000000000",
            "00000000000000",
            "000000000000000",
            "0000000000000000",
            "00000000000000000",
            "000000000000000000",
            "0000000000000000000",
            "00000000000000000000",
            "000000000000000000000",
            "0000000000000000000000",
            "00000000000000000000000",
            "000000000000000000000000",
            "0000000000000000000000000"
          ];
          var groupSizes = [
            0,
            0,
            25,
            16,
            12,
            11,
            10,
            9,
            8,
            8,
            7,
            7,
            7,
            7,
            6,
            6,
            6,
            6,
            6,
            6,
            6,
            5,
            5,
            5,
            5,
            5,
            5,
            5,
            5,
            5,
            5,
            5,
            5,
            5,
            5,
            5,
            5
          ];
          var groupBases = [
            0,
            0,
            33554432,
            43046721,
            16777216,
            48828125,
            60466176,
            40353607,
            16777216,
            43046721,
            1e7,
            19487171,
            35831808,
            62748517,
            7529536,
            11390625,
            16777216,
            24137569,
            34012224,
            47045881,
            64e6,
            4084101,
            5153632,
            6436343,
            7962624,
            9765625,
            11881376,
            14348907,
            17210368,
            20511149,
            243e5,
            28629151,
            33554432,
            39135393,
            45435424,
            52521875,
            60466176
          ];
          BN.prototype.toString = function toString2(base2, padding) {
            base2 = base2 || 10;
            padding = padding | 0 || 1;
            var out;
            if (base2 === 16 || base2 === "hex") {
              out = "";
              var off2 = 0;
              var carry = 0;
              for (var i = 0; i < this.length; i++) {
                var w = this.words[i];
                var word = ((w << off2 | carry) & 16777215).toString(16);
                carry = w >>> 24 - off2 & 16777215;
                if (carry !== 0 || i !== this.length - 1) {
                  out = zeros[6 - word.length] + word + out;
                } else {
                  out = word + out;
                }
                off2 += 2;
                if (off2 >= 26) {
                  off2 -= 26;
                  i--;
                }
              }
              if (carry !== 0) {
                out = carry.toString(16) + out;
              }
              while (out.length % padding !== 0) {
                out = "0" + out;
              }
              if (this.negative !== 0) {
                out = "-" + out;
              }
              return out;
            }
            if (base2 === (base2 | 0) && base2 >= 2 && base2 <= 36) {
              var groupSize = groupSizes[base2];
              var groupBase = groupBases[base2];
              out = "";
              var c = this.clone();
              c.negative = 0;
              while (!c.isZero()) {
                var r = c.modn(groupBase).toString(base2);
                c = c.idivn(groupBase);
                if (!c.isZero()) {
                  out = zeros[groupSize - r.length] + r + out;
                } else {
                  out = r + out;
                }
              }
              if (this.isZero()) {
                out = "0" + out;
              }
              while (out.length % padding !== 0) {
                out = "0" + out;
              }
              if (this.negative !== 0) {
                out = "-" + out;
              }
              return out;
            }
            assert2(false, "Base should be between 2 and 36");
          };
          BN.prototype.toNumber = function toNumber() {
            var ret = this.words[0];
            if (this.length === 2) {
              ret += this.words[1] * 67108864;
            } else if (this.length === 3 && this.words[2] === 1) {
              ret += 4503599627370496 + this.words[1] * 67108864;
            } else if (this.length > 2) {
              assert2(false, "Number can only safely store up to 53 bits");
            }
            return this.negative !== 0 ? -ret : ret;
          };
          BN.prototype.toJSON = function toJSON() {
            return this.toString(16);
          };
          BN.prototype.toBuffer = function toBuffer2(endian, length2) {
            assert2(typeof Buffer2 !== "undefined");
            return this.toArrayLike(Buffer2, endian, length2);
          };
          BN.prototype.toArray = function toArray(endian, length2) {
            return this.toArrayLike(Array, endian, length2);
          };
          BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length2) {
            var byteLength2 = this.byteLength();
            var reqLength = length2 || Math.max(1, byteLength2);
            assert2(byteLength2 <= reqLength, "byte array longer than desired length");
            assert2(reqLength > 0, "Requested array length <= 0");
            this.strip();
            var littleEndian = endian === "le";
            var res = new ArrayType(reqLength);
            var b, i;
            var q = this.clone();
            if (!littleEndian) {
              for (i = 0; i < reqLength - byteLength2; i++) {
                res[i] = 0;
              }
              for (i = 0; !q.isZero(); i++) {
                b = q.andln(255);
                q.iushrn(8);
                res[reqLength - i - 1] = b;
              }
            } else {
              for (i = 0; !q.isZero(); i++) {
                b = q.andln(255);
                q.iushrn(8);
                res[i] = b;
              }
              for (; i < reqLength; i++) {
                res[i] = 0;
              }
            }
            return res;
          };
          if (Math.clz32) {
            BN.prototype._countBits = function _countBits(w) {
              return 32 - Math.clz32(w);
            };
          } else {
            BN.prototype._countBits = function _countBits(w) {
              var t = w;
              var r = 0;
              if (t >= 4096) {
                r += 13;
                t >>>= 13;
              }
              if (t >= 64) {
                r += 7;
                t >>>= 7;
              }
              if (t >= 8) {
                r += 4;
                t >>>= 4;
              }
              if (t >= 2) {
                r += 2;
                t >>>= 2;
              }
              return r + t;
            };
          }
          BN.prototype._zeroBits = function _zeroBits(w) {
            if (w === 0)
              return 26;
            var t = w;
            var r = 0;
            if ((t & 8191) === 0) {
              r += 13;
              t >>>= 13;
            }
            if ((t & 127) === 0) {
              r += 7;
              t >>>= 7;
            }
            if ((t & 15) === 0) {
              r += 4;
              t >>>= 4;
            }
            if ((t & 3) === 0) {
              r += 2;
              t >>>= 2;
            }
            if ((t & 1) === 0) {
              r++;
            }
            return r;
          };
          BN.prototype.bitLength = function bitLength() {
            var w = this.words[this.length - 1];
            var hi = this._countBits(w);
            return (this.length - 1) * 26 + hi;
          };
          function toBitArray(num) {
            var w = new Array(num.bitLength());
            for (var bit = 0; bit < w.length; bit++) {
              var off2 = bit / 26 | 0;
              var wbit = bit % 26;
              w[bit] = (num.words[off2] & 1 << wbit) >>> wbit;
            }
            return w;
          }
          BN.prototype.zeroBits = function zeroBits() {
            if (this.isZero())
              return 0;
            var r = 0;
            for (var i = 0; i < this.length; i++) {
              var b = this._zeroBits(this.words[i]);
              r += b;
              if (b !== 26)
                break;
            }
            return r;
          };
          BN.prototype.byteLength = function byteLength2() {
            return Math.ceil(this.bitLength() / 8);
          };
          BN.prototype.toTwos = function toTwos(width) {
            if (this.negative !== 0) {
              return this.abs().inotn(width).iaddn(1);
            }
            return this.clone();
          };
          BN.prototype.fromTwos = function fromTwos(width) {
            if (this.testn(width - 1)) {
              return this.notn(width).iaddn(1).ineg();
            }
            return this.clone();
          };
          BN.prototype.isNeg = function isNeg() {
            return this.negative !== 0;
          };
          BN.prototype.neg = function neg() {
            return this.clone().ineg();
          };
          BN.prototype.ineg = function ineg() {
            if (!this.isZero()) {
              this.negative ^= 1;
            }
            return this;
          };
          BN.prototype.iuor = function iuor(num) {
            while (this.length < num.length) {
              this.words[this.length++] = 0;
            }
            for (var i = 0; i < num.length; i++) {
              this.words[i] = this.words[i] | num.words[i];
            }
            return this.strip();
          };
          BN.prototype.ior = function ior(num) {
            assert2((this.negative | num.negative) === 0);
            return this.iuor(num);
          };
          BN.prototype.or = function or2(num) {
            if (this.length > num.length)
              return this.clone().ior(num);
            return num.clone().ior(this);
          };
          BN.prototype.uor = function uor(num) {
            if (this.length > num.length)
              return this.clone().iuor(num);
            return num.clone().iuor(this);
          };
          BN.prototype.iuand = function iuand(num) {
            var b;
            if (this.length > num.length) {
              b = num;
            } else {
              b = this;
            }
            for (var i = 0; i < b.length; i++) {
              this.words[i] = this.words[i] & num.words[i];
            }
            this.length = b.length;
            return this.strip();
          };
          BN.prototype.iand = function iand(num) {
            assert2((this.negative | num.negative) === 0);
            return this.iuand(num);
          };
          BN.prototype.and = function and(num) {
            if (this.length > num.length)
              return this.clone().iand(num);
            return num.clone().iand(this);
          };
          BN.prototype.uand = function uand(num) {
            if (this.length > num.length)
              return this.clone().iuand(num);
            return num.clone().iuand(this);
          };
          BN.prototype.iuxor = function iuxor(num) {
            var a;
            var b;
            if (this.length > num.length) {
              a = this;
              b = num;
            } else {
              a = num;
              b = this;
            }
            for (var i = 0; i < b.length; i++) {
              this.words[i] = a.words[i] ^ b.words[i];
            }
            if (this !== a) {
              for (; i < a.length; i++) {
                this.words[i] = a.words[i];
              }
            }
            this.length = a.length;
            return this.strip();
          };
          BN.prototype.ixor = function ixor(num) {
            assert2((this.negative | num.negative) === 0);
            return this.iuxor(num);
          };
          BN.prototype.xor = function xor2(num) {
            if (this.length > num.length)
              return this.clone().ixor(num);
            return num.clone().ixor(this);
          };
          BN.prototype.uxor = function uxor(num) {
            if (this.length > num.length)
              return this.clone().iuxor(num);
            return num.clone().iuxor(this);
          };
          BN.prototype.inotn = function inotn(width) {
            assert2(typeof width === "number" && width >= 0);
            var bytesNeeded = Math.ceil(width / 26) | 0;
            var bitsLeft = width % 26;
            this._expand(bytesNeeded);
            if (bitsLeft > 0) {
              bytesNeeded--;
            }
            for (var i = 0; i < bytesNeeded; i++) {
              this.words[i] = ~this.words[i] & 67108863;
            }
            if (bitsLeft > 0) {
              this.words[i] = ~this.words[i] & 67108863 >> 26 - bitsLeft;
            }
            return this.strip();
          };
          BN.prototype.notn = function notn(width) {
            return this.clone().inotn(width);
          };
          BN.prototype.setn = function setn(bit, val) {
            assert2(typeof bit === "number" && bit >= 0);
            var off2 = bit / 26 | 0;
            var wbit = bit % 26;
            this._expand(off2 + 1);
            if (val) {
              this.words[off2] = this.words[off2] | 1 << wbit;
            } else {
              this.words[off2] = this.words[off2] & ~(1 << wbit);
            }
            return this.strip();
          };
          BN.prototype.iadd = function iadd(num) {
            var r;
            if (this.negative !== 0 && num.negative === 0) {
              this.negative = 0;
              r = this.isub(num);
              this.negative ^= 1;
              return this._normSign();
            } else if (this.negative === 0 && num.negative !== 0) {
              num.negative = 0;
              r = this.isub(num);
              num.negative = 1;
              return r._normSign();
            }
            var a, b;
            if (this.length > num.length) {
              a = this;
              b = num;
            } else {
              a = num;
              b = this;
            }
            var carry = 0;
            for (var i = 0; i < b.length; i++) {
              r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
              this.words[i] = r & 67108863;
              carry = r >>> 26;
            }
            for (; carry !== 0 && i < a.length; i++) {
              r = (a.words[i] | 0) + carry;
              this.words[i] = r & 67108863;
              carry = r >>> 26;
            }
            this.length = a.length;
            if (carry !== 0) {
              this.words[this.length] = carry;
              this.length++;
            } else if (a !== this) {
              for (; i < a.length; i++) {
                this.words[i] = a.words[i];
              }
            }
            return this;
          };
          BN.prototype.add = function add(num) {
            var res;
            if (num.negative !== 0 && this.negative === 0) {
              num.negative = 0;
              res = this.sub(num);
              num.negative ^= 1;
              return res;
            } else if (num.negative === 0 && this.negative !== 0) {
              this.negative = 0;
              res = num.sub(this);
              this.negative = 1;
              return res;
            }
            if (this.length > num.length)
              return this.clone().iadd(num);
            return num.clone().iadd(this);
          };
          BN.prototype.isub = function isub(num) {
            if (num.negative !== 0) {
              num.negative = 0;
              var r = this.iadd(num);
              num.negative = 1;
              return r._normSign();
            } else if (this.negative !== 0) {
              this.negative = 0;
              this.iadd(num);
              this.negative = 1;
              return this._normSign();
            }
            var cmp = this.cmp(num);
            if (cmp === 0) {
              this.negative = 0;
              this.length = 1;
              this.words[0] = 0;
              return this;
            }
            var a, b;
            if (cmp > 0) {
              a = this;
              b = num;
            } else {
              a = num;
              b = this;
            }
            var carry = 0;
            for (var i = 0; i < b.length; i++) {
              r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
              carry = r >> 26;
              this.words[i] = r & 67108863;
            }
            for (; carry !== 0 && i < a.length; i++) {
              r = (a.words[i] | 0) + carry;
              carry = r >> 26;
              this.words[i] = r & 67108863;
            }
            if (carry === 0 && i < a.length && a !== this) {
              for (; i < a.length; i++) {
                this.words[i] = a.words[i];
              }
            }
            this.length = Math.max(this.length, i);
            if (a !== this) {
              this.negative = 1;
            }
            return this.strip();
          };
          BN.prototype.sub = function sub(num) {
            return this.clone().isub(num);
          };
          function smallMulTo(self2, num, out) {
            out.negative = num.negative ^ self2.negative;
            var len = self2.length + num.length | 0;
            out.length = len;
            len = len - 1 | 0;
            var a = self2.words[0] | 0;
            var b = num.words[0] | 0;
            var r = a * b;
            var lo = r & 67108863;
            var carry = r / 67108864 | 0;
            out.words[0] = lo;
            for (var k = 1; k < len; k++) {
              var ncarry = carry >>> 26;
              var rword = carry & 67108863;
              var maxJ = Math.min(k, num.length - 1);
              for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
                var i = k - j | 0;
                a = self2.words[i] | 0;
                b = num.words[j] | 0;
                r = a * b + rword;
                ncarry += r / 67108864 | 0;
                rword = r & 67108863;
              }
              out.words[k] = rword | 0;
              carry = ncarry | 0;
            }
            if (carry !== 0) {
              out.words[k] = carry | 0;
            } else {
              out.length--;
            }
            return out.strip();
          }
          var comb10MulTo = function comb10MulTo2(self2, num, out) {
            var a = self2.words;
            var b = num.words;
            var o = out.words;
            var c = 0;
            var lo;
            var mid;
            var hi;
            var a0 = a[0] | 0;
            var al0 = a0 & 8191;
            var ah0 = a0 >>> 13;
            var a1 = a[1] | 0;
            var al1 = a1 & 8191;
            var ah1 = a1 >>> 13;
            var a2 = a[2] | 0;
            var al2 = a2 & 8191;
            var ah2 = a2 >>> 13;
            var a3 = a[3] | 0;
            var al3 = a3 & 8191;
            var ah3 = a3 >>> 13;
            var a4 = a[4] | 0;
            var al4 = a4 & 8191;
            var ah4 = a4 >>> 13;
            var a5 = a[5] | 0;
            var al5 = a5 & 8191;
            var ah5 = a5 >>> 13;
            var a6 = a[6] | 0;
            var al6 = a6 & 8191;
            var ah6 = a6 >>> 13;
            var a7 = a[7] | 0;
            var al7 = a7 & 8191;
            var ah7 = a7 >>> 13;
            var a8 = a[8] | 0;
            var al8 = a8 & 8191;
            var ah8 = a8 >>> 13;
            var a9 = a[9] | 0;
            var al9 = a9 & 8191;
            var ah9 = a9 >>> 13;
            var b0 = b[0] | 0;
            var bl0 = b0 & 8191;
            var bh0 = b0 >>> 13;
            var b1 = b[1] | 0;
            var bl1 = b1 & 8191;
            var bh1 = b1 >>> 13;
            var b2 = b[2] | 0;
            var bl2 = b2 & 8191;
            var bh2 = b2 >>> 13;
            var b3 = b[3] | 0;
            var bl3 = b3 & 8191;
            var bh3 = b3 >>> 13;
            var b4 = b[4] | 0;
            var bl4 = b4 & 8191;
            var bh4 = b4 >>> 13;
            var b5 = b[5] | 0;
            var bl5 = b5 & 8191;
            var bh5 = b5 >>> 13;
            var b6 = b[6] | 0;
            var bl6 = b6 & 8191;
            var bh6 = b6 >>> 13;
            var b7 = b[7] | 0;
            var bl7 = b7 & 8191;
            var bh7 = b7 >>> 13;
            var b8 = b[8] | 0;
            var bl8 = b8 & 8191;
            var bh8 = b8 >>> 13;
            var b9 = b[9] | 0;
            var bl9 = b9 & 8191;
            var bh9 = b9 >>> 13;
            out.negative = self2.negative ^ num.negative;
            out.length = 19;
            lo = Math.imul(al0, bl0);
            mid = Math.imul(al0, bh0);
            mid = mid + Math.imul(ah0, bl0) | 0;
            hi = Math.imul(ah0, bh0);
            var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
            c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
            w0 &= 67108863;
            lo = Math.imul(al1, bl0);
            mid = Math.imul(al1, bh0);
            mid = mid + Math.imul(ah1, bl0) | 0;
            hi = Math.imul(ah1, bh0);
            lo = lo + Math.imul(al0, bl1) | 0;
            mid = mid + Math.imul(al0, bh1) | 0;
            mid = mid + Math.imul(ah0, bl1) | 0;
            hi = hi + Math.imul(ah0, bh1) | 0;
            var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
            c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
            w1 &= 67108863;
            lo = Math.imul(al2, bl0);
            mid = Math.imul(al2, bh0);
            mid = mid + Math.imul(ah2, bl0) | 0;
            hi = Math.imul(ah2, bh0);
            lo = lo + Math.imul(al1, bl1) | 0;
            mid = mid + Math.imul(al1, bh1) | 0;
            mid = mid + Math.imul(ah1, bl1) | 0;
            hi = hi + Math.imul(ah1, bh1) | 0;
            lo = lo + Math.imul(al0, bl2) | 0;
            mid = mid + Math.imul(al0, bh2) | 0;
            mid = mid + Math.imul(ah0, bl2) | 0;
            hi = hi + Math.imul(ah0, bh2) | 0;
            var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
            c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
            w2 &= 67108863;
            lo = Math.imul(al3, bl0);
            mid = Math.imul(al3, bh0);
            mid = mid + Math.imul(ah3, bl0) | 0;
            hi = Math.imul(ah3, bh0);
            lo = lo + Math.imul(al2, bl1) | 0;
            mid = mid + Math.imul(al2, bh1) | 0;
            mid = mid + Math.imul(ah2, bl1) | 0;
            hi = hi + Math.imul(ah2, bh1) | 0;
            lo = lo + Math.imul(al1, bl2) | 0;
            mid = mid + Math.imul(al1, bh2) | 0;
            mid = mid + Math.imul(ah1, bl2) | 0;
            hi = hi + Math.imul(ah1, bh2) | 0;
            lo = lo + Math.imul(al0, bl3) | 0;
            mid = mid + Math.imul(al0, bh3) | 0;
            mid = mid + Math.imul(ah0, bl3) | 0;
            hi = hi + Math.imul(ah0, bh3) | 0;
            var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
            c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
            w3 &= 67108863;
            lo = Math.imul(al4, bl0);
            mid = Math.imul(al4, bh0);
            mid = mid + Math.imul(ah4, bl0) | 0;
            hi = Math.imul(ah4, bh0);
            lo = lo + Math.imul(al3, bl1) | 0;
            mid = mid + Math.imul(al3, bh1) | 0;
            mid = mid + Math.imul(ah3, bl1) | 0;
            hi = hi + Math.imul(ah3, bh1) | 0;
            lo = lo + Math.imul(al2, bl2) | 0;
            mid = mid + Math.imul(al2, bh2) | 0;
            mid = mid + Math.imul(ah2, bl2) | 0;
            hi = hi + Math.imul(ah2, bh2) | 0;
            lo = lo + Math.imul(al1, bl3) | 0;
            mid = mid + Math.imul(al1, bh3) | 0;
            mid = mid + Math.imul(ah1, bl3) | 0;
            hi = hi + Math.imul(ah1, bh3) | 0;
            lo = lo + Math.imul(al0, bl4) | 0;
            mid = mid + Math.imul(al0, bh4) | 0;
            mid = mid + Math.imul(ah0, bl4) | 0;
            hi = hi + Math.imul(ah0, bh4) | 0;
            var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
            c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
            w4 &= 67108863;
            lo = Math.imul(al5, bl0);
            mid = Math.imul(al5, bh0);
            mid = mid + Math.imul(ah5, bl0) | 0;
            hi = Math.imul(ah5, bh0);
            lo = lo + Math.imul(al4, bl1) | 0;
            mid = mid + Math.imul(al4, bh1) | 0;
            mid = mid + Math.imul(ah4, bl1) | 0;
            hi = hi + Math.imul(ah4, bh1) | 0;
            lo = lo + Math.imul(al3, bl2) | 0;
            mid = mid + Math.imul(al3, bh2) | 0;
            mid = mid + Math.imul(ah3, bl2) | 0;
            hi = hi + Math.imul(ah3, bh2) | 0;
            lo = lo + Math.imul(al2, bl3) | 0;
            mid = mid + Math.imul(al2, bh3) | 0;
            mid = mid + Math.imul(ah2, bl3) | 0;
            hi = hi + Math.imul(ah2, bh3) | 0;
            lo = lo + Math.imul(al1, bl4) | 0;
            mid = mid + Math.imul(al1, bh4) | 0;
            mid = mid + Math.imul(ah1, bl4) | 0;
            hi = hi + Math.imul(ah1, bh4) | 0;
            lo = lo + Math.imul(al0, bl5) | 0;
            mid = mid + Math.imul(al0, bh5) | 0;
            mid = mid + Math.imul(ah0, bl5) | 0;
            hi = hi + Math.imul(ah0, bh5) | 0;
            var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
            c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
            w5 &= 67108863;
            lo = Math.imul(al6, bl0);
            mid = Math.imul(al6, bh0);
            mid = mid + Math.imul(ah6, bl0) | 0;
            hi = Math.imul(ah6, bh0);
            lo = lo + Math.imul(al5, bl1) | 0;
            mid = mid + Math.imul(al5, bh1) | 0;
            mid = mid + Math.imul(ah5, bl1) | 0;
            hi = hi + Math.imul(ah5, bh1) | 0;
            lo = lo + Math.imul(al4, bl2) | 0;
            mid = mid + Math.imul(al4, bh2) | 0;
            mid = mid + Math.imul(ah4, bl2) | 0;
            hi = hi + Math.imul(ah4, bh2) | 0;
            lo = lo + Math.imul(al3, bl3) | 0;
            mid = mid + Math.imul(al3, bh3) | 0;
            mid = mid + Math.imul(ah3, bl3) | 0;
            hi = hi + Math.imul(ah3, bh3) | 0;
            lo = lo + Math.imul(al2, bl4) | 0;
            mid = mid + Math.imul(al2, bh4) | 0;
            mid = mid + Math.imul(ah2, bl4) | 0;
            hi = hi + Math.imul(ah2, bh4) | 0;
            lo = lo + Math.imul(al1, bl5) | 0;
            mid = mid + Math.imul(al1, bh5) | 0;
            mid = mid + Math.imul(ah1, bl5) | 0;
            hi = hi + Math.imul(ah1, bh5) | 0;
            lo = lo + Math.imul(al0, bl6) | 0;
            mid = mid + Math.imul(al0, bh6) | 0;
            mid = mid + Math.imul(ah0, bl6) | 0;
            hi = hi + Math.imul(ah0, bh6) | 0;
            var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
            c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
            w6 &= 67108863;
            lo = Math.imul(al7, bl0);
            mid = Math.imul(al7, bh0);
            mid = mid + Math.imul(ah7, bl0) | 0;
            hi = Math.imul(ah7, bh0);
            lo = lo + Math.imul(al6, bl1) | 0;
            mid = mid + Math.imul(al6, bh1) | 0;
            mid = mid + Math.imul(ah6, bl1) | 0;
            hi = hi + Math.imul(ah6, bh1) | 0;
            lo = lo + Math.imul(al5, bl2) | 0;
            mid = mid + Math.imul(al5, bh2) | 0;
            mid = mid + Math.imul(ah5, bl2) | 0;
            hi = hi + Math.imul(ah5, bh2) | 0;
            lo = lo + Math.imul(al4, bl3) | 0;
            mid = mid + Math.imul(al4, bh3) | 0;
            mid = mid + Math.imul(ah4, bl3) | 0;
            hi = hi + Math.imul(ah4, bh3) | 0;
            lo = lo + Math.imul(al3, bl4) | 0;
            mid = mid + Math.imul(al3, bh4) | 0;
            mid = mid + Math.imul(ah3, bl4) | 0;
            hi = hi + Math.imul(ah3, bh4) | 0;
            lo = lo + Math.imul(al2, bl5) | 0;
            mid = mid + Math.imul(al2, bh5) | 0;
            mid = mid + Math.imul(ah2, bl5) | 0;
            hi = hi + Math.imul(ah2, bh5) | 0;
            lo = lo + Math.imul(al1, bl6) | 0;
            mid = mid + Math.imul(al1, bh6) | 0;
            mid = mid + Math.imul(ah1, bl6) | 0;
            hi = hi + Math.imul(ah1, bh6) | 0;
            lo = lo + Math.imul(al0, bl7) | 0;
            mid = mid + Math.imul(al0, bh7) | 0;
            mid = mid + Math.imul(ah0, bl7) | 0;
            hi = hi + Math.imul(ah0, bh7) | 0;
            var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
            c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
            w7 &= 67108863;
            lo = Math.imul(al8, bl0);
            mid = Math.imul(al8, bh0);
            mid = mid + Math.imul(ah8, bl0) | 0;
            hi = Math.imul(ah8, bh0);
            lo = lo + Math.imul(al7, bl1) | 0;
            mid = mid + Math.imul(al7, bh1) | 0;
            mid = mid + Math.imul(ah7, bl1) | 0;
            hi = hi + Math.imul(ah7, bh1) | 0;
            lo = lo + Math.imul(al6, bl2) | 0;
            mid = mid + Math.imul(al6, bh2) | 0;
            mid = mid + Math.imul(ah6, bl2) | 0;
            hi = hi + Math.imul(ah6, bh2) | 0;
            lo = lo + Math.imul(al5, bl3) | 0;
            mid = mid + Math.imul(al5, bh3) | 0;
            mid = mid + Math.imul(ah5, bl3) | 0;
            hi = hi + Math.imul(ah5, bh3) | 0;
            lo = lo + Math.imul(al4, bl4) | 0;
            mid = mid + Math.imul(al4, bh4) | 0;
            mid = mid + Math.imul(ah4, bl4) | 0;
            hi = hi + Math.imul(ah4, bh4) | 0;
            lo = lo + Math.imul(al3, bl5) | 0;
            mid = mid + Math.imul(al3, bh5) | 0;
            mid = mid + Math.imul(ah3, bl5) | 0;
            hi = hi + Math.imul(ah3, bh5) | 0;
            lo = lo + Math.imul(al2, bl6) | 0;
            mid = mid + Math.imul(al2, bh6) | 0;
            mid = mid + Math.imul(ah2, bl6) | 0;
            hi = hi + Math.imul(ah2, bh6) | 0;
            lo = lo + Math.imul(al1, bl7) | 0;
            mid = mid + Math.imul(al1, bh7) | 0;
            mid = mid + Math.imul(ah1, bl7) | 0;
            hi = hi + Math.imul(ah1, bh7) | 0;
            lo = lo + Math.imul(al0, bl8) | 0;
            mid = mid + Math.imul(al0, bh8) | 0;
            mid = mid + Math.imul(ah0, bl8) | 0;
            hi = hi + Math.imul(ah0, bh8) | 0;
            var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
            c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
            w8 &= 67108863;
            lo = Math.imul(al9, bl0);
            mid = Math.imul(al9, bh0);
            mid = mid + Math.imul(ah9, bl0) | 0;
            hi = Math.imul(ah9, bh0);
            lo = lo + Math.imul(al8, bl1) | 0;
            mid = mid + Math.imul(al8, bh1) | 0;
            mid = mid + Math.imul(ah8, bl1) | 0;
            hi = hi + Math.imul(ah8, bh1) | 0;
            lo = lo + Math.imul(al7, bl2) | 0;
            mid = mid + Math.imul(al7, bh2) | 0;
            mid = mid + Math.imul(ah7, bl2) | 0;
            hi = hi + Math.imul(ah7, bh2) | 0;
            lo = lo + Math.imul(al6, bl3) | 0;
            mid = mid + Math.imul(al6, bh3) | 0;
            mid = mid + Math.imul(ah6, bl3) | 0;
            hi = hi + Math.imul(ah6, bh3) | 0;
            lo = lo + Math.imul(al5, bl4) | 0;
            mid = mid + Math.imul(al5, bh4) | 0;
            mid = mid + Math.imul(ah5, bl4) | 0;
            hi = hi + Math.imul(ah5, bh4) | 0;
            lo = lo + Math.imul(al4, bl5) | 0;
            mid = mid + Math.imul(al4, bh5) | 0;
            mid = mid + Math.imul(ah4, bl5) | 0;
            hi = hi + Math.imul(ah4, bh5) | 0;
            lo = lo + Math.imul(al3, bl6) | 0;
            mid = mid + Math.imul(al3, bh6) | 0;
            mid = mid + Math.imul(ah3, bl6) | 0;
            hi = hi + Math.imul(ah3, bh6) | 0;
            lo = lo + Math.imul(al2, bl7) | 0;
            mid = mid + Math.imul(al2, bh7) | 0;
            mid = mid + Math.imul(ah2, bl7) | 0;
            hi = hi + Math.imul(ah2, bh7) | 0;
            lo = lo + Math.imul(al1, bl8) | 0;
            mid = mid + Math.imul(al1, bh8) | 0;
            mid = mid + Math.imul(ah1, bl8) | 0;
            hi = hi + Math.imul(ah1, bh8) | 0;
            lo = lo + Math.imul(al0, bl9) | 0;
            mid = mid + Math.imul(al0, bh9) | 0;
            mid = mid + Math.imul(ah0, bl9) | 0;
            hi = hi + Math.imul(ah0, bh9) | 0;
            var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
            c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
            w9 &= 67108863;
            lo = Math.imul(al9, bl1);
            mid = Math.imul(al9, bh1);
            mid = mid + Math.imul(ah9, bl1) | 0;
            hi = Math.imul(ah9, bh1);
            lo = lo + Math.imul(al8, bl2) | 0;
            mid = mid + Math.imul(al8, bh2) | 0;
            mid = mid + Math.imul(ah8, bl2) | 0;
            hi = hi + Math.imul(ah8, bh2) | 0;
            lo = lo + Math.imul(al7, bl3) | 0;
            mid = mid + Math.imul(al7, bh3) | 0;
            mid = mid + Math.imul(ah7, bl3) | 0;
            hi = hi + Math.imul(ah7, bh3) | 0;
            lo = lo + Math.imul(al6, bl4) | 0;
            mid = mid + Math.imul(al6, bh4) | 0;
            mid = mid + Math.imul(ah6, bl4) | 0;
            hi = hi + Math.imul(ah6, bh4) | 0;
            lo = lo + Math.imul(al5, bl5) | 0;
            mid = mid + Math.imul(al5, bh5) | 0;
            mid = mid + Math.imul(ah5, bl5) | 0;
            hi = hi + Math.imul(ah5, bh5) | 0;
            lo = lo + Math.imul(al4, bl6) | 0;
            mid = mid + Math.imul(al4, bh6) | 0;
            mid = mid + Math.imul(ah4, bl6) | 0;
            hi = hi + Math.imul(ah4, bh6) | 0;
            lo = lo + Math.imul(al3, bl7) | 0;
            mid = mid + Math.imul(al3, bh7) | 0;
            mid = mid + Math.imul(ah3, bl7) | 0;
            hi = hi + Math.imul(ah3, bh7) | 0;
            lo = lo + Math.imul(al2, bl8) | 0;
            mid = mid + Math.imul(al2, bh8) | 0;
            mid = mid + Math.imul(ah2, bl8) | 0;
            hi = hi + Math.imul(ah2, bh8) | 0;
            lo = lo + Math.imul(al1, bl9) | 0;
            mid = mid + Math.imul(al1, bh9) | 0;
            mid = mid + Math.imul(ah1, bl9) | 0;
            hi = hi + Math.imul(ah1, bh9) | 0;
            var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
            c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
            w10 &= 67108863;
            lo = Math.imul(al9, bl2);
            mid = Math.imul(al9, bh2);
            mid = mid + Math.imul(ah9, bl2) | 0;
            hi = Math.imul(ah9, bh2);
            lo = lo + Math.imul(al8, bl3) | 0;
            mid = mid + Math.imul(al8, bh3) | 0;
            mid = mid + Math.imul(ah8, bl3) | 0;
            hi = hi + Math.imul(ah8, bh3) | 0;
            lo = lo + Math.imul(al7, bl4) | 0;
            mid = mid + Math.imul(al7, bh4) | 0;
            mid = mid + Math.imul(ah7, bl4) | 0;
            hi = hi + Math.imul(ah7, bh4) | 0;
            lo = lo + Math.imul(al6, bl5) | 0;
            mid = mid + Math.imul(al6, bh5) | 0;
            mid = mid + Math.imul(ah6, bl5) | 0;
            hi = hi + Math.imul(ah6, bh5) | 0;
            lo = lo + Math.imul(al5, bl6) | 0;
            mid = mid + Math.imul(al5, bh6) | 0;
            mid = mid + Math.imul(ah5, bl6) | 0;
            hi = hi + Math.imul(ah5, bh6) | 0;
            lo = lo + Math.imul(al4, bl7) | 0;
            mid = mid + Math.imul(al4, bh7) | 0;
            mid = mid + Math.imul(ah4, bl7) | 0;
            hi = hi + Math.imul(ah4, bh7) | 0;
            lo = lo + Math.imul(al3, bl8) | 0;
            mid = mid + Math.imul(al3, bh8) | 0;
            mid = mid + Math.imul(ah3, bl8) | 0;
            hi = hi + Math.imul(ah3, bh8) | 0;
            lo = lo + Math.imul(al2, bl9) | 0;
            mid = mid + Math.imul(al2, bh9) | 0;
            mid = mid + Math.imul(ah2, bl9) | 0;
            hi = hi + Math.imul(ah2, bh9) | 0;
            var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
            c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
            w11 &= 67108863;
            lo = Math.imul(al9, bl3);
            mid = Math.imul(al9, bh3);
            mid = mid + Math.imul(ah9, bl3) | 0;
            hi = Math.imul(ah9, bh3);
            lo = lo + Math.imul(al8, bl4) | 0;
            mid = mid + Math.imul(al8, bh4) | 0;
            mid = mid + Math.imul(ah8, bl4) | 0;
            hi = hi + Math.imul(ah8, bh4) | 0;
            lo = lo + Math.imul(al7, bl5) | 0;
            mid = mid + Math.imul(al7, bh5) | 0;
            mid = mid + Math.imul(ah7, bl5) | 0;
            hi = hi + Math.imul(ah7, bh5) | 0;
            lo = lo + Math.imul(al6, bl6) | 0;
            mid = mid + Math.imul(al6, bh6) | 0;
            mid = mid + Math.imul(ah6, bl6) | 0;
            hi = hi + Math.imul(ah6, bh6) | 0;
            lo = lo + Math.imul(al5, bl7) | 0;
            mid = mid + Math.imul(al5, bh7) | 0;
            mid = mid + Math.imul(ah5, bl7) | 0;
            hi = hi + Math.imul(ah5, bh7) | 0;
            lo = lo + Math.imul(al4, bl8) | 0;
            mid = mid + Math.imul(al4, bh8) | 0;
            mid = mid + Math.imul(ah4, bl8) | 0;
            hi = hi + Math.imul(ah4, bh8) | 0;
            lo = lo + Math.imul(al3, bl9) | 0;
            mid = mid + Math.imul(al3, bh9) | 0;
            mid = mid + Math.imul(ah3, bl9) | 0;
            hi = hi + Math.imul(ah3, bh9) | 0;
            var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
            c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
            w12 &= 67108863;
            lo = Math.imul(al9, bl4);
            mid = Math.imul(al9, bh4);
            mid = mid + Math.imul(ah9, bl4) | 0;
            hi = Math.imul(ah9, bh4);
            lo = lo + Math.imul(al8, bl5) | 0;
            mid = mid + Math.imul(al8, bh5) | 0;
            mid = mid + Math.imul(ah8, bl5) | 0;
            hi = hi + Math.imul(ah8, bh5) | 0;
            lo = lo + Math.imul(al7, bl6) | 0;
            mid = mid + Math.imul(al7, bh6) | 0;
            mid = mid + Math.imul(ah7, bl6) | 0;
            hi = hi + Math.imul(ah7, bh6) | 0;
            lo = lo + Math.imul(al6, bl7) | 0;
            mid = mid + Math.imul(al6, bh7) | 0;
            mid = mid + Math.imul(ah6, bl7) | 0;
            hi = hi + Math.imul(ah6, bh7) | 0;
            lo = lo + Math.imul(al5, bl8) | 0;
            mid = mid + Math.imul(al5, bh8) | 0;
            mid = mid + Math.imul(ah5, bl8) | 0;
            hi = hi + Math.imul(ah5, bh8) | 0;
            lo = lo + Math.imul(al4, bl9) | 0;
            mid = mid + Math.imul(al4, bh9) | 0;
            mid = mid + Math.imul(ah4, bl9) | 0;
            hi = hi + Math.imul(ah4, bh9) | 0;
            var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
            c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
            w13 &= 67108863;
            lo = Math.imul(al9, bl5);
            mid = Math.imul(al9, bh5);
            mid = mid + Math.imul(ah9, bl5) | 0;
            hi = Math.imul(ah9, bh5);
            lo = lo + Math.imul(al8, bl6) | 0;
            mid = mid + Math.imul(al8, bh6) | 0;
            mid = mid + Math.imul(ah8, bl6) | 0;
            hi = hi + Math.imul(ah8, bh6) | 0;
            lo = lo + Math.imul(al7, bl7) | 0;
            mid = mid + Math.imul(al7, bh7) | 0;
            mid = mid + Math.imul(ah7, bl7) | 0;
            hi = hi + Math.imul(ah7, bh7) | 0;
            lo = lo + Math.imul(al6, bl8) | 0;
            mid = mid + Math.imul(al6, bh8) | 0;
            mid = mid + Math.imul(ah6, bl8) | 0;
            hi = hi + Math.imul(ah6, bh8) | 0;
            lo = lo + Math.imul(al5, bl9) | 0;
            mid = mid + Math.imul(al5, bh9) | 0;
            mid = mid + Math.imul(ah5, bl9) | 0;
            hi = hi + Math.imul(ah5, bh9) | 0;
            var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
            c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
            w14 &= 67108863;
            lo = Math.imul(al9, bl6);
            mid = Math.imul(al9, bh6);
            mid = mid + Math.imul(ah9, bl6) | 0;
            hi = Math.imul(ah9, bh6);
            lo = lo + Math.imul(al8, bl7) | 0;
            mid = mid + Math.imul(al8, bh7) | 0;
            mid = mid + Math.imul(ah8, bl7) | 0;
            hi = hi + Math.imul(ah8, bh7) | 0;
            lo = lo + Math.imul(al7, bl8) | 0;
            mid = mid + Math.imul(al7, bh8) | 0;
            mid = mid + Math.imul(ah7, bl8) | 0;
            hi = hi + Math.imul(ah7, bh8) | 0;
            lo = lo + Math.imul(al6, bl9) | 0;
            mid = mid + Math.imul(al6, bh9) | 0;
            mid = mid + Math.imul(ah6, bl9) | 0;
            hi = hi + Math.imul(ah6, bh9) | 0;
            var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
            c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
            w15 &= 67108863;
            lo = Math.imul(al9, bl7);
            mid = Math.imul(al9, bh7);
            mid = mid + Math.imul(ah9, bl7) | 0;
            hi = Math.imul(ah9, bh7);
            lo = lo + Math.imul(al8, bl8) | 0;
            mid = mid + Math.imul(al8, bh8) | 0;
            mid = mid + Math.imul(ah8, bl8) | 0;
            hi = hi + Math.imul(ah8, bh8) | 0;
            lo = lo + Math.imul(al7, bl9) | 0;
            mid = mid + Math.imul(al7, bh9) | 0;
            mid = mid + Math.imul(ah7, bl9) | 0;
            hi = hi + Math.imul(ah7, bh9) | 0;
            var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
            c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
            w16 &= 67108863;
            lo = Math.imul(al9, bl8);
            mid = Math.imul(al9, bh8);
            mid = mid + Math.imul(ah9, bl8) | 0;
            hi = Math.imul(ah9, bh8);
            lo = lo + Math.imul(al8, bl9) | 0;
            mid = mid + Math.imul(al8, bh9) | 0;
            mid = mid + Math.imul(ah8, bl9) | 0;
            hi = hi + Math.imul(ah8, bh9) | 0;
            var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
            c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
            w17 &= 67108863;
            lo = Math.imul(al9, bl9);
            mid = Math.imul(al9, bh9);
            mid = mid + Math.imul(ah9, bl9) | 0;
            hi = Math.imul(ah9, bh9);
            var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
            c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
            w18 &= 67108863;
            o[0] = w0;
            o[1] = w1;
            o[2] = w2;
            o[3] = w3;
            o[4] = w4;
            o[5] = w5;
            o[6] = w6;
            o[7] = w7;
            o[8] = w8;
            o[9] = w9;
            o[10] = w10;
            o[11] = w11;
            o[12] = w12;
            o[13] = w13;
            o[14] = w14;
            o[15] = w15;
            o[16] = w16;
            o[17] = w17;
            o[18] = w18;
            if (c !== 0) {
              o[19] = c;
              out.length++;
            }
            return out;
          };
          if (!Math.imul) {
            comb10MulTo = smallMulTo;
          }
          function bigMulTo(self2, num, out) {
            out.negative = num.negative ^ self2.negative;
            out.length = self2.length + num.length;
            var carry = 0;
            var hncarry = 0;
            for (var k = 0; k < out.length - 1; k++) {
              var ncarry = hncarry;
              hncarry = 0;
              var rword = carry & 67108863;
              var maxJ = Math.min(k, num.length - 1);
              for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
                var i = k - j;
                var a = self2.words[i] | 0;
                var b = num.words[j] | 0;
                var r = a * b;
                var lo = r & 67108863;
                ncarry = ncarry + (r / 67108864 | 0) | 0;
                lo = lo + rword | 0;
                rword = lo & 67108863;
                ncarry = ncarry + (lo >>> 26) | 0;
                hncarry += ncarry >>> 26;
                ncarry &= 67108863;
              }
              out.words[k] = rword;
              carry = ncarry;
              ncarry = hncarry;
            }
            if (carry !== 0) {
              out.words[k] = carry;
            } else {
              out.length--;
            }
            return out.strip();
          }
          function jumboMulTo(self2, num, out) {
            var fftm = new FFTM();
            return fftm.mulp(self2, num, out);
          }
          BN.prototype.mulTo = function mulTo(num, out) {
            var res;
            var len = this.length + num.length;
            if (this.length === 10 && num.length === 10) {
              res = comb10MulTo(this, num, out);
            } else if (len < 63) {
              res = smallMulTo(this, num, out);
            } else if (len < 1024) {
              res = bigMulTo(this, num, out);
            } else {
              res = jumboMulTo(this, num, out);
            }
            return res;
          };
          function FFTM(x, y) {
            this.x = x;
            this.y = y;
          }
          FFTM.prototype.makeRBT = function makeRBT(N) {
            var t = new Array(N);
            var l = BN.prototype._countBits(N) - 1;
            for (var i = 0; i < N; i++) {
              t[i] = this.revBin(i, l, N);
            }
            return t;
          };
          FFTM.prototype.revBin = function revBin(x, l, N) {
            if (x === 0 || x === N - 1)
              return x;
            var rb = 0;
            for (var i = 0; i < l; i++) {
              rb |= (x & 1) << l - i - 1;
              x >>= 1;
            }
            return rb;
          };
          FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
            for (var i = 0; i < N; i++) {
              rtws[i] = rws[rbt[i]];
              itws[i] = iws[rbt[i]];
            }
          };
          FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
            this.permute(rbt, rws, iws, rtws, itws, N);
            for (var s = 1; s < N; s <<= 1) {
              var l = s << 1;
              var rtwdf = Math.cos(2 * Math.PI / l);
              var itwdf = Math.sin(2 * Math.PI / l);
              for (var p = 0; p < N; p += l) {
                var rtwdf_ = rtwdf;
                var itwdf_ = itwdf;
                for (var j = 0; j < s; j++) {
                  var re = rtws[p + j];
                  var ie = itws[p + j];
                  var ro = rtws[p + j + s];
                  var io = itws[p + j + s];
                  var rx = rtwdf_ * ro - itwdf_ * io;
                  io = rtwdf_ * io + itwdf_ * ro;
                  ro = rx;
                  rtws[p + j] = re + ro;
                  itws[p + j] = ie + io;
                  rtws[p + j + s] = re - ro;
                  itws[p + j + s] = ie - io;
                  if (j !== l) {
                    rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                    itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                    rtwdf_ = rx;
                  }
                }
              }
            }
          };
          FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
            var N = Math.max(m, n) | 1;
            var odd = N & 1;
            var i = 0;
            for (N = N / 2 | 0; N; N = N >>> 1) {
              i++;
            }
            return 1 << i + 1 + odd;
          };
          FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
            if (N <= 1)
              return;
            for (var i = 0; i < N / 2; i++) {
              var t = rws[i];
              rws[i] = rws[N - i - 1];
              rws[N - i - 1] = t;
              t = iws[i];
              iws[i] = -iws[N - i - 1];
              iws[N - i - 1] = -t;
            }
          };
          FFTM.prototype.normalize13b = function normalize13b(ws, N) {
            var carry = 0;
            for (var i = 0; i < N / 2; i++) {
              var w = Math.round(ws[2 * i + 1] / N) * 8192 + Math.round(ws[2 * i] / N) + carry;
              ws[i] = w & 67108863;
              if (w < 67108864) {
                carry = 0;
              } else {
                carry = w / 67108864 | 0;
              }
            }
            return ws;
          };
          FFTM.prototype.convert13b = function convert13b(ws, len, rws, N) {
            var carry = 0;
            for (var i = 0; i < len; i++) {
              carry = carry + (ws[i] | 0);
              rws[2 * i] = carry & 8191;
              carry = carry >>> 13;
              rws[2 * i + 1] = carry & 8191;
              carry = carry >>> 13;
            }
            for (i = 2 * len; i < N; ++i) {
              rws[i] = 0;
            }
            assert2(carry === 0);
            assert2((carry & ~8191) === 0);
          };
          FFTM.prototype.stub = function stub(N) {
            var ph = new Array(N);
            for (var i = 0; i < N; i++) {
              ph[i] = 0;
            }
            return ph;
          };
          FFTM.prototype.mulp = function mulp(x, y, out) {
            var N = 2 * this.guessLen13b(x.length, y.length);
            var rbt = this.makeRBT(N);
            var _ = this.stub(N);
            var rws = new Array(N);
            var rwst = new Array(N);
            var iwst = new Array(N);
            var nrws = new Array(N);
            var nrwst = new Array(N);
            var niwst = new Array(N);
            var rmws = out.words;
            rmws.length = N;
            this.convert13b(x.words, x.length, rws, N);
            this.convert13b(y.words, y.length, nrws, N);
            this.transform(rws, _, rwst, iwst, N, rbt);
            this.transform(nrws, _, nrwst, niwst, N, rbt);
            for (var i = 0; i < N; i++) {
              var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
              iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
              rwst[i] = rx;
            }
            this.conjugate(rwst, iwst, N);
            this.transform(rwst, iwst, rmws, _, N, rbt);
            this.conjugate(rmws, _, N);
            this.normalize13b(rmws, N);
            out.negative = x.negative ^ y.negative;
            out.length = x.length + y.length;
            return out.strip();
          };
          BN.prototype.mul = function mul(num) {
            var out = new BN(null);
            out.words = new Array(this.length + num.length);
            return this.mulTo(num, out);
          };
          BN.prototype.mulf = function mulf(num) {
            var out = new BN(null);
            out.words = new Array(this.length + num.length);
            return jumboMulTo(this, num, out);
          };
          BN.prototype.imul = function imul(num) {
            return this.clone().mulTo(num, this);
          };
          BN.prototype.imuln = function imuln(num) {
            assert2(typeof num === "number");
            assert2(num < 67108864);
            var carry = 0;
            for (var i = 0; i < this.length; i++) {
              var w = (this.words[i] | 0) * num;
              var lo = (w & 67108863) + (carry & 67108863);
              carry >>= 26;
              carry += w / 67108864 | 0;
              carry += lo >>> 26;
              this.words[i] = lo & 67108863;
            }
            if (carry !== 0) {
              this.words[i] = carry;
              this.length++;
            }
            return this;
          };
          BN.prototype.muln = function muln(num) {
            return this.clone().imuln(num);
          };
          BN.prototype.sqr = function sqr() {
            return this.mul(this);
          };
          BN.prototype.isqr = function isqr() {
            return this.imul(this.clone());
          };
          BN.prototype.pow = function pow(num) {
            var w = toBitArray(num);
            if (w.length === 0)
              return new BN(1);
            var res = this;
            for (var i = 0; i < w.length; i++, res = res.sqr()) {
              if (w[i] !== 0)
                break;
            }
            if (++i < w.length) {
              for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
                if (w[i] === 0)
                  continue;
                res = res.mul(q);
              }
            }
            return res;
          };
          BN.prototype.iushln = function iushln(bits) {
            assert2(typeof bits === "number" && bits >= 0);
            var r = bits % 26;
            var s = (bits - r) / 26;
            var carryMask = 67108863 >>> 26 - r << 26 - r;
            var i;
            if (r !== 0) {
              var carry = 0;
              for (i = 0; i < this.length; i++) {
                var newCarry = this.words[i] & carryMask;
                var c = (this.words[i] | 0) - newCarry << r;
                this.words[i] = c | carry;
                carry = newCarry >>> 26 - r;
              }
              if (carry) {
                this.words[i] = carry;
                this.length++;
              }
            }
            if (s !== 0) {
              for (i = this.length - 1; i >= 0; i--) {
                this.words[i + s] = this.words[i];
              }
              for (i = 0; i < s; i++) {
                this.words[i] = 0;
              }
              this.length += s;
            }
            return this.strip();
          };
          BN.prototype.ishln = function ishln(bits) {
            assert2(this.negative === 0);
            return this.iushln(bits);
          };
          BN.prototype.iushrn = function iushrn(bits, hint, extended) {
            assert2(typeof bits === "number" && bits >= 0);
            var h;
            if (hint) {
              h = (hint - hint % 26) / 26;
            } else {
              h = 0;
            }
            var r = bits % 26;
            var s = Math.min((bits - r) / 26, this.length);
            var mask2 = 67108863 ^ 67108863 >>> r << r;
            var maskedWords = extended;
            h -= s;
            h = Math.max(0, h);
            if (maskedWords) {
              for (var i = 0; i < s; i++) {
                maskedWords.words[i] = this.words[i];
              }
              maskedWords.length = s;
            }
            if (s === 0)
              ;
            else if (this.length > s) {
              this.length -= s;
              for (i = 0; i < this.length; i++) {
                this.words[i] = this.words[i + s];
              }
            } else {
              this.words[0] = 0;
              this.length = 1;
            }
            var carry = 0;
            for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
              var word = this.words[i] | 0;
              this.words[i] = carry << 26 - r | word >>> r;
              carry = word & mask2;
            }
            if (maskedWords && carry !== 0) {
              maskedWords.words[maskedWords.length++] = carry;
            }
            if (this.length === 0) {
              this.words[0] = 0;
              this.length = 1;
            }
            return this.strip();
          };
          BN.prototype.ishrn = function ishrn(bits, hint, extended) {
            assert2(this.negative === 0);
            return this.iushrn(bits, hint, extended);
          };
          BN.prototype.shln = function shln(bits) {
            return this.clone().ishln(bits);
          };
          BN.prototype.ushln = function ushln(bits) {
            return this.clone().iushln(bits);
          };
          BN.prototype.shrn = function shrn(bits) {
            return this.clone().ishrn(bits);
          };
          BN.prototype.ushrn = function ushrn(bits) {
            return this.clone().iushrn(bits);
          };
          BN.prototype.testn = function testn(bit) {
            assert2(typeof bit === "number" && bit >= 0);
            var r = bit % 26;
            var s = (bit - r) / 26;
            var q = 1 << r;
            if (this.length <= s)
              return false;
            var w = this.words[s];
            return !!(w & q);
          };
          BN.prototype.imaskn = function imaskn(bits) {
            assert2(typeof bits === "number" && bits >= 0);
            var r = bits % 26;
            var s = (bits - r) / 26;
            assert2(this.negative === 0, "imaskn works only with positive numbers");
            if (this.length <= s) {
              return this;
            }
            if (r !== 0) {
              s++;
            }
            this.length = Math.min(s, this.length);
            if (r !== 0) {
              var mask2 = 67108863 ^ 67108863 >>> r << r;
              this.words[this.length - 1] &= mask2;
            }
            return this.strip();
          };
          BN.prototype.maskn = function maskn(bits) {
            return this.clone().imaskn(bits);
          };
          BN.prototype.iaddn = function iaddn(num) {
            assert2(typeof num === "number");
            assert2(num < 67108864);
            if (num < 0)
              return this.isubn(-num);
            if (this.negative !== 0) {
              if (this.length === 1 && (this.words[0] | 0) < num) {
                this.words[0] = num - (this.words[0] | 0);
                this.negative = 0;
                return this;
              }
              this.negative = 0;
              this.isubn(num);
              this.negative = 1;
              return this;
            }
            return this._iaddn(num);
          };
          BN.prototype._iaddn = function _iaddn(num) {
            this.words[0] += num;
            for (var i = 0; i < this.length && this.words[i] >= 67108864; i++) {
              this.words[i] -= 67108864;
              if (i === this.length - 1) {
                this.words[i + 1] = 1;
              } else {
                this.words[i + 1]++;
              }
            }
            this.length = Math.max(this.length, i + 1);
            return this;
          };
          BN.prototype.isubn = function isubn(num) {
            assert2(typeof num === "number");
            assert2(num < 67108864);
            if (num < 0)
              return this.iaddn(-num);
            if (this.negative !== 0) {
              this.negative = 0;
              this.iaddn(num);
              this.negative = 1;
              return this;
            }
            this.words[0] -= num;
            if (this.length === 1 && this.words[0] < 0) {
              this.words[0] = -this.words[0];
              this.negative = 1;
            } else {
              for (var i = 0; i < this.length && this.words[i] < 0; i++) {
                this.words[i] += 67108864;
                this.words[i + 1] -= 1;
              }
            }
            return this.strip();
          };
          BN.prototype.addn = function addn(num) {
            return this.clone().iaddn(num);
          };
          BN.prototype.subn = function subn(num) {
            return this.clone().isubn(num);
          };
          BN.prototype.iabs = function iabs() {
            this.negative = 0;
            return this;
          };
          BN.prototype.abs = function abs() {
            return this.clone().iabs();
          };
          BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
            var len = num.length + shift;
            var i;
            this._expand(len);
            var w;
            var carry = 0;
            for (i = 0; i < num.length; i++) {
              w = (this.words[i + shift] | 0) + carry;
              var right = (num.words[i] | 0) * mul;
              w -= right & 67108863;
              carry = (w >> 26) - (right / 67108864 | 0);
              this.words[i + shift] = w & 67108863;
            }
            for (; i < this.length - shift; i++) {
              w = (this.words[i + shift] | 0) + carry;
              carry = w >> 26;
              this.words[i + shift] = w & 67108863;
            }
            if (carry === 0)
              return this.strip();
            assert2(carry === -1);
            carry = 0;
            for (i = 0; i < this.length; i++) {
              w = -(this.words[i] | 0) + carry;
              carry = w >> 26;
              this.words[i] = w & 67108863;
            }
            this.negative = 1;
            return this.strip();
          };
          BN.prototype._wordDiv = function _wordDiv(num, mode) {
            var shift = this.length - num.length;
            var a = this.clone();
            var b = num;
            var bhi = b.words[b.length - 1] | 0;
            var bhiBits = this._countBits(bhi);
            shift = 26 - bhiBits;
            if (shift !== 0) {
              b = b.ushln(shift);
              a.iushln(shift);
              bhi = b.words[b.length - 1] | 0;
            }
            var m = a.length - b.length;
            var q;
            if (mode !== "mod") {
              q = new BN(null);
              q.length = m + 1;
              q.words = new Array(q.length);
              for (var i = 0; i < q.length; i++) {
                q.words[i] = 0;
              }
            }
            var diff = a.clone()._ishlnsubmul(b, 1, m);
            if (diff.negative === 0) {
              a = diff;
              if (q) {
                q.words[m] = 1;
              }
            }
            for (var j = m - 1; j >= 0; j--) {
              var qj = (a.words[b.length + j] | 0) * 67108864 + (a.words[b.length + j - 1] | 0);
              qj = Math.min(qj / bhi | 0, 67108863);
              a._ishlnsubmul(b, qj, j);
              while (a.negative !== 0) {
                qj--;
                a.negative = 0;
                a._ishlnsubmul(b, 1, j);
                if (!a.isZero()) {
                  a.negative ^= 1;
                }
              }
              if (q) {
                q.words[j] = qj;
              }
            }
            if (q) {
              q.strip();
            }
            a.strip();
            if (mode !== "div" && shift !== 0) {
              a.iushrn(shift);
            }
            return {
              div: q || null,
              mod: a
            };
          };
          BN.prototype.divmod = function divmod(num, mode, positive) {
            assert2(!num.isZero());
            if (this.isZero()) {
              return {
                div: new BN(0),
                mod: new BN(0)
              };
            }
            var div, mod, res;
            if (this.negative !== 0 && num.negative === 0) {
              res = this.neg().divmod(num, mode);
              if (mode !== "mod") {
                div = res.div.neg();
              }
              if (mode !== "div") {
                mod = res.mod.neg();
                if (positive && mod.negative !== 0) {
                  mod.iadd(num);
                }
              }
              return {
                div,
                mod
              };
            }
            if (this.negative === 0 && num.negative !== 0) {
              res = this.divmod(num.neg(), mode);
              if (mode !== "mod") {
                div = res.div.neg();
              }
              return {
                div,
                mod: res.mod
              };
            }
            if ((this.negative & num.negative) !== 0) {
              res = this.neg().divmod(num.neg(), mode);
              if (mode !== "div") {
                mod = res.mod.neg();
                if (positive && mod.negative !== 0) {
                  mod.isub(num);
                }
              }
              return {
                div: res.div,
                mod
              };
            }
            if (num.length > this.length || this.cmp(num) < 0) {
              return {
                div: new BN(0),
                mod: this
              };
            }
            if (num.length === 1) {
              if (mode === "div") {
                return {
                  div: this.divn(num.words[0]),
                  mod: null
                };
              }
              if (mode === "mod") {
                return {
                  div: null,
                  mod: new BN(this.modn(num.words[0]))
                };
              }
              return {
                div: this.divn(num.words[0]),
                mod: new BN(this.modn(num.words[0]))
              };
            }
            return this._wordDiv(num, mode);
          };
          BN.prototype.div = function div(num) {
            return this.divmod(num, "div", false).div;
          };
          BN.prototype.mod = function mod(num) {
            return this.divmod(num, "mod", false).mod;
          };
          BN.prototype.umod = function umod(num) {
            return this.divmod(num, "mod", true).mod;
          };
          BN.prototype.divRound = function divRound(num) {
            var dm = this.divmod(num);
            if (dm.mod.isZero())
              return dm.div;
            var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
            var half = num.ushrn(1);
            var r2 = num.andln(1);
            var cmp = mod.cmp(half);
            if (cmp < 0 || r2 === 1 && cmp === 0)
              return dm.div;
            return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
          };
          BN.prototype.modn = function modn(num) {
            assert2(num <= 67108863);
            var p = (1 << 26) % num;
            var acc = 0;
            for (var i = this.length - 1; i >= 0; i--) {
              acc = (p * acc + (this.words[i] | 0)) % num;
            }
            return acc;
          };
          BN.prototype.idivn = function idivn(num) {
            assert2(num <= 67108863);
            var carry = 0;
            for (var i = this.length - 1; i >= 0; i--) {
              var w = (this.words[i] | 0) + carry * 67108864;
              this.words[i] = w / num | 0;
              carry = w % num;
            }
            return this.strip();
          };
          BN.prototype.divn = function divn(num) {
            return this.clone().idivn(num);
          };
          BN.prototype.egcd = function egcd(p) {
            assert2(p.negative === 0);
            assert2(!p.isZero());
            var x = this;
            var y = p.clone();
            if (x.negative !== 0) {
              x = x.umod(p);
            } else {
              x = x.clone();
            }
            var A = new BN(1);
            var B = new BN(0);
            var C = new BN(0);
            var D = new BN(1);
            var g = 0;
            while (x.isEven() && y.isEven()) {
              x.iushrn(1);
              y.iushrn(1);
              ++g;
            }
            var yp = y.clone();
            var xp = x.clone();
            while (!x.isZero()) {
              for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
                ;
              if (i > 0) {
                x.iushrn(i);
                while (i-- > 0) {
                  if (A.isOdd() || B.isOdd()) {
                    A.iadd(yp);
                    B.isub(xp);
                  }
                  A.iushrn(1);
                  B.iushrn(1);
                }
              }
              for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
                ;
              if (j > 0) {
                y.iushrn(j);
                while (j-- > 0) {
                  if (C.isOdd() || D.isOdd()) {
                    C.iadd(yp);
                    D.isub(xp);
                  }
                  C.iushrn(1);
                  D.iushrn(1);
                }
              }
              if (x.cmp(y) >= 0) {
                x.isub(y);
                A.isub(C);
                B.isub(D);
              } else {
                y.isub(x);
                C.isub(A);
                D.isub(B);
              }
            }
            return {
              a: C,
              b: D,
              gcd: y.iushln(g)
            };
          };
          BN.prototype._invmp = function _invmp(p) {
            assert2(p.negative === 0);
            assert2(!p.isZero());
            var a = this;
            var b = p.clone();
            if (a.negative !== 0) {
              a = a.umod(p);
            } else {
              a = a.clone();
            }
            var x1 = new BN(1);
            var x2 = new BN(0);
            var delta = b.clone();
            while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
              for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
                ;
              if (i > 0) {
                a.iushrn(i);
                while (i-- > 0) {
                  if (x1.isOdd()) {
                    x1.iadd(delta);
                  }
                  x1.iushrn(1);
                }
              }
              for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
                ;
              if (j > 0) {
                b.iushrn(j);
                while (j-- > 0) {
                  if (x2.isOdd()) {
                    x2.iadd(delta);
                  }
                  x2.iushrn(1);
                }
              }
              if (a.cmp(b) >= 0) {
                a.isub(b);
                x1.isub(x2);
              } else {
                b.isub(a);
                x2.isub(x1);
              }
            }
            var res;
            if (a.cmpn(1) === 0) {
              res = x1;
            } else {
              res = x2;
            }
            if (res.cmpn(0) < 0) {
              res.iadd(p);
            }
            return res;
          };
          BN.prototype.gcd = function gcd(num) {
            if (this.isZero())
              return num.abs();
            if (num.isZero())
              return this.abs();
            var a = this.clone();
            var b = num.clone();
            a.negative = 0;
            b.negative = 0;
            for (var shift = 0; a.isEven() && b.isEven(); shift++) {
              a.iushrn(1);
              b.iushrn(1);
            }
            do {
              while (a.isEven()) {
                a.iushrn(1);
              }
              while (b.isEven()) {
                b.iushrn(1);
              }
              var r = a.cmp(b);
              if (r < 0) {
                var t = a;
                a = b;
                b = t;
              } else if (r === 0 || b.cmpn(1) === 0) {
                break;
              }
              a.isub(b);
            } while (true);
            return b.iushln(shift);
          };
          BN.prototype.invm = function invm(num) {
            return this.egcd(num).a.umod(num);
          };
          BN.prototype.isEven = function isEven() {
            return (this.words[0] & 1) === 0;
          };
          BN.prototype.isOdd = function isOdd() {
            return (this.words[0] & 1) === 1;
          };
          BN.prototype.andln = function andln(num) {
            return this.words[0] & num;
          };
          BN.prototype.bincn = function bincn(bit) {
            assert2(typeof bit === "number");
            var r = bit % 26;
            var s = (bit - r) / 26;
            var q = 1 << r;
            if (this.length <= s) {
              this._expand(s + 1);
              this.words[s] |= q;
              return this;
            }
            var carry = q;
            for (var i = s; carry !== 0 && i < this.length; i++) {
              var w = this.words[i] | 0;
              w += carry;
              carry = w >>> 26;
              w &= 67108863;
              this.words[i] = w;
            }
            if (carry !== 0) {
              this.words[i] = carry;
              this.length++;
            }
            return this;
          };
          BN.prototype.isZero = function isZero() {
            return this.length === 1 && this.words[0] === 0;
          };
          BN.prototype.cmpn = function cmpn(num) {
            var negative = num < 0;
            if (this.negative !== 0 && !negative)
              return -1;
            if (this.negative === 0 && negative)
              return 1;
            this.strip();
            var res;
            if (this.length > 1) {
              res = 1;
            } else {
              if (negative) {
                num = -num;
              }
              assert2(num <= 67108863, "Number is too big");
              var w = this.words[0] | 0;
              res = w === num ? 0 : w < num ? -1 : 1;
            }
            if (this.negative !== 0)
              return -res | 0;
            return res;
          };
          BN.prototype.cmp = function cmp(num) {
            if (this.negative !== 0 && num.negative === 0)
              return -1;
            if (this.negative === 0 && num.negative !== 0)
              return 1;
            var res = this.ucmp(num);
            if (this.negative !== 0)
              return -res | 0;
            return res;
          };
          BN.prototype.ucmp = function ucmp(num) {
            if (this.length > num.length)
              return 1;
            if (this.length < num.length)
              return -1;
            var res = 0;
            for (var i = this.length - 1; i >= 0; i--) {
              var a = this.words[i] | 0;
              var b = num.words[i] | 0;
              if (a === b)
                continue;
              if (a < b) {
                res = -1;
              } else if (a > b) {
                res = 1;
              }
              break;
            }
            return res;
          };
          BN.prototype.gtn = function gtn(num) {
            return this.cmpn(num) === 1;
          };
          BN.prototype.gt = function gt(num) {
            return this.cmp(num) === 1;
          };
          BN.prototype.gten = function gten(num) {
            return this.cmpn(num) >= 0;
          };
          BN.prototype.gte = function gte(num) {
            return this.cmp(num) >= 0;
          };
          BN.prototype.ltn = function ltn(num) {
            return this.cmpn(num) === -1;
          };
          BN.prototype.lt = function lt(num) {
            return this.cmp(num) === -1;
          };
          BN.prototype.lten = function lten(num) {
            return this.cmpn(num) <= 0;
          };
          BN.prototype.lte = function lte(num) {
            return this.cmp(num) <= 0;
          };
          BN.prototype.eqn = function eqn(num) {
            return this.cmpn(num) === 0;
          };
          BN.prototype.eq = function eq(num) {
            return this.cmp(num) === 0;
          };
          BN.red = function red(num) {
            return new Red(num);
          };
          BN.prototype.toRed = function toRed(ctx) {
            assert2(!this.red, "Already a number in reduction context");
            assert2(this.negative === 0, "red works only with positives");
            return ctx.convertTo(this)._forceRed(ctx);
          };
          BN.prototype.fromRed = function fromRed() {
            assert2(this.red, "fromRed works only with numbers in reduction context");
            return this.red.convertFrom(this);
          };
          BN.prototype._forceRed = function _forceRed(ctx) {
            this.red = ctx;
            return this;
          };
          BN.prototype.forceRed = function forceRed(ctx) {
            assert2(!this.red, "Already a number in reduction context");
            return this._forceRed(ctx);
          };
          BN.prototype.redAdd = function redAdd(num) {
            assert2(this.red, "redAdd works only with red numbers");
            return this.red.add(this, num);
          };
          BN.prototype.redIAdd = function redIAdd(num) {
            assert2(this.red, "redIAdd works only with red numbers");
            return this.red.iadd(this, num);
          };
          BN.prototype.redSub = function redSub(num) {
            assert2(this.red, "redSub works only with red numbers");
            return this.red.sub(this, num);
          };
          BN.prototype.redISub = function redISub(num) {
            assert2(this.red, "redISub works only with red numbers");
            return this.red.isub(this, num);
          };
          BN.prototype.redShl = function redShl(num) {
            assert2(this.red, "redShl works only with red numbers");
            return this.red.shl(this, num);
          };
          BN.prototype.redMul = function redMul(num) {
            assert2(this.red, "redMul works only with red numbers");
            this.red._verify2(this, num);
            return this.red.mul(this, num);
          };
          BN.prototype.redIMul = function redIMul(num) {
            assert2(this.red, "redMul works only with red numbers");
            this.red._verify2(this, num);
            return this.red.imul(this, num);
          };
          BN.prototype.redSqr = function redSqr() {
            assert2(this.red, "redSqr works only with red numbers");
            this.red._verify1(this);
            return this.red.sqr(this);
          };
          BN.prototype.redISqr = function redISqr() {
            assert2(this.red, "redISqr works only with red numbers");
            this.red._verify1(this);
            return this.red.isqr(this);
          };
          BN.prototype.redSqrt = function redSqrt() {
            assert2(this.red, "redSqrt works only with red numbers");
            this.red._verify1(this);
            return this.red.sqrt(this);
          };
          BN.prototype.redInvm = function redInvm() {
            assert2(this.red, "redInvm works only with red numbers");
            this.red._verify1(this);
            return this.red.invm(this);
          };
          BN.prototype.redNeg = function redNeg() {
            assert2(this.red, "redNeg works only with red numbers");
            this.red._verify1(this);
            return this.red.neg(this);
          };
          BN.prototype.redPow = function redPow(num) {
            assert2(this.red && !num.red, "redPow(normalNum)");
            this.red._verify1(this);
            return this.red.pow(this, num);
          };
          var primes = {
            k256: null,
            p224: null,
            p192: null,
            p25519: null
          };
          function MPrime(name2, p) {
            this.name = name2;
            this.p = new BN(p, 16);
            this.n = this.p.bitLength();
            this.k = new BN(1).iushln(this.n).isub(this.p);
            this.tmp = this._tmp();
          }
          MPrime.prototype._tmp = function _tmp() {
            var tmp = new BN(null);
            tmp.words = new Array(Math.ceil(this.n / 13));
            return tmp;
          };
          MPrime.prototype.ireduce = function ireduce(num) {
            var r = num;
            var rlen;
            do {
              this.split(r, this.tmp);
              r = this.imulK(r);
              r = r.iadd(this.tmp);
              rlen = r.bitLength();
            } while (rlen > this.n);
            var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
            if (cmp === 0) {
              r.words[0] = 0;
              r.length = 1;
            } else if (cmp > 0) {
              r.isub(this.p);
            } else {
              if (r.strip !== void 0) {
                r.strip();
              } else {
                r._strip();
              }
            }
            return r;
          };
          MPrime.prototype.split = function split(input, out) {
            input.iushrn(this.n, 0, out);
          };
          MPrime.prototype.imulK = function imulK(num) {
            return num.imul(this.k);
          };
          function K256() {
            MPrime.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
          }
          inherits2(K256, MPrime);
          K256.prototype.split = function split(input, output) {
            var mask2 = 4194303;
            var outLen = Math.min(input.length, 9);
            for (var i = 0; i < outLen; i++) {
              output.words[i] = input.words[i];
            }
            output.length = outLen;
            if (input.length <= 9) {
              input.words[0] = 0;
              input.length = 1;
              return;
            }
            var prev = input.words[9];
            output.words[output.length++] = prev & mask2;
            for (i = 10; i < input.length; i++) {
              var next = input.words[i] | 0;
              input.words[i - 10] = (next & mask2) << 4 | prev >>> 22;
              prev = next;
            }
            prev >>>= 22;
            input.words[i - 10] = prev;
            if (prev === 0 && input.length > 10) {
              input.length -= 10;
            } else {
              input.length -= 9;
            }
          };
          K256.prototype.imulK = function imulK(num) {
            num.words[num.length] = 0;
            num.words[num.length + 1] = 0;
            num.length += 2;
            var lo = 0;
            for (var i = 0; i < num.length; i++) {
              var w = num.words[i] | 0;
              lo += w * 977;
              num.words[i] = lo & 67108863;
              lo = w * 64 + (lo / 67108864 | 0);
            }
            if (num.words[num.length - 1] === 0) {
              num.length--;
              if (num.words[num.length - 1] === 0) {
                num.length--;
              }
            }
            return num;
          };
          function P224() {
            MPrime.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
          }
          inherits2(P224, MPrime);
          function P192() {
            MPrime.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
          }
          inherits2(P192, MPrime);
          function P25519() {
            MPrime.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
          }
          inherits2(P25519, MPrime);
          P25519.prototype.imulK = function imulK(num) {
            var carry = 0;
            for (var i = 0; i < num.length; i++) {
              var hi = (num.words[i] | 0) * 19 + carry;
              var lo = hi & 67108863;
              hi >>>= 26;
              num.words[i] = lo;
              carry = hi;
            }
            if (carry !== 0) {
              num.words[num.length++] = carry;
            }
            return num;
          };
          BN._prime = function prime(name2) {
            if (primes[name2])
              return primes[name2];
            var prime2;
            if (name2 === "k256") {
              prime2 = new K256();
            } else if (name2 === "p224") {
              prime2 = new P224();
            } else if (name2 === "p192") {
              prime2 = new P192();
            } else if (name2 === "p25519") {
              prime2 = new P25519();
            } else {
              throw new Error("Unknown prime " + name2);
            }
            primes[name2] = prime2;
            return prime2;
          };
          function Red(m) {
            if (typeof m === "string") {
              var prime = BN._prime(m);
              this.m = prime.p;
              this.prime = prime;
            } else {
              assert2(m.gtn(1), "modulus must be greater than 1");
              this.m = m;
              this.prime = null;
            }
          }
          Red.prototype._verify1 = function _verify1(a) {
            assert2(a.negative === 0, "red works only with positives");
            assert2(a.red, "red works only with red numbers");
          };
          Red.prototype._verify2 = function _verify2(a, b) {
            assert2((a.negative | b.negative) === 0, "red works only with positives");
            assert2(a.red && a.red === b.red, "red works only with red numbers");
          };
          Red.prototype.imod = function imod(a) {
            if (this.prime)
              return this.prime.ireduce(a)._forceRed(this);
            return a.umod(this.m)._forceRed(this);
          };
          Red.prototype.neg = function neg(a) {
            if (a.isZero()) {
              return a.clone();
            }
            return this.m.sub(a)._forceRed(this);
          };
          Red.prototype.add = function add(a, b) {
            this._verify2(a, b);
            var res = a.add(b);
            if (res.cmp(this.m) >= 0) {
              res.isub(this.m);
            }
            return res._forceRed(this);
          };
          Red.prototype.iadd = function iadd(a, b) {
            this._verify2(a, b);
            var res = a.iadd(b);
            if (res.cmp(this.m) >= 0) {
              res.isub(this.m);
            }
            return res;
          };
          Red.prototype.sub = function sub(a, b) {
            this._verify2(a, b);
            var res = a.sub(b);
            if (res.cmpn(0) < 0) {
              res.iadd(this.m);
            }
            return res._forceRed(this);
          };
          Red.prototype.isub = function isub(a, b) {
            this._verify2(a, b);
            var res = a.isub(b);
            if (res.cmpn(0) < 0) {
              res.iadd(this.m);
            }
            return res;
          };
          Red.prototype.shl = function shl(a, num) {
            this._verify1(a);
            return this.imod(a.ushln(num));
          };
          Red.prototype.imul = function imul(a, b) {
            this._verify2(a, b);
            return this.imod(a.imul(b));
          };
          Red.prototype.mul = function mul(a, b) {
            this._verify2(a, b);
            return this.imod(a.mul(b));
          };
          Red.prototype.isqr = function isqr(a) {
            return this.imul(a, a.clone());
          };
          Red.prototype.sqr = function sqr(a) {
            return this.mul(a, a);
          };
          Red.prototype.sqrt = function sqrt(a) {
            if (a.isZero())
              return a.clone();
            var mod3 = this.m.andln(3);
            assert2(mod3 % 2 === 1);
            if (mod3 === 3) {
              var pow = this.m.add(new BN(1)).iushrn(2);
              return this.pow(a, pow);
            }
            var q = this.m.subn(1);
            var s = 0;
            while (!q.isZero() && q.andln(1) === 0) {
              s++;
              q.iushrn(1);
            }
            assert2(!q.isZero());
            var one = new BN(1).toRed(this);
            var nOne = one.redNeg();
            var lpow = this.m.subn(1).iushrn(1);
            var z = this.m.bitLength();
            z = new BN(2 * z * z).toRed(this);
            while (this.pow(z, lpow).cmp(nOne) !== 0) {
              z.redIAdd(nOne);
            }
            var c = this.pow(z, q);
            var r = this.pow(a, q.addn(1).iushrn(1));
            var t = this.pow(a, q);
            var m = s;
            while (t.cmp(one) !== 0) {
              var tmp = t;
              for (var i = 0; tmp.cmp(one) !== 0; i++) {
                tmp = tmp.redSqr();
              }
              assert2(i < m);
              var b = this.pow(c, new BN(1).iushln(m - i - 1));
              r = r.redMul(b);
              c = b.redSqr();
              t = t.redMul(c);
              m = i;
            }
            return r;
          };
          Red.prototype.invm = function invm(a) {
            var inv = a._invmp(this.m);
            if (inv.negative !== 0) {
              inv.negative = 0;
              return this.imod(inv).redNeg();
            } else {
              return this.imod(inv);
            }
          };
          Red.prototype.pow = function pow(a, num) {
            if (num.isZero())
              return new BN(1).toRed(this);
            if (num.cmpn(1) === 0)
              return a.clone();
            var windowSize = 4;
            var wnd = new Array(1 << windowSize);
            wnd[0] = new BN(1).toRed(this);
            wnd[1] = a;
            for (var i = 2; i < wnd.length; i++) {
              wnd[i] = this.mul(wnd[i - 1], a);
            }
            var res = wnd[0];
            var current = 0;
            var currentLen = 0;
            var start = num.bitLength() % 26;
            if (start === 0) {
              start = 26;
            }
            for (i = num.length - 1; i >= 0; i--) {
              var word = num.words[i];
              for (var j = start - 1; j >= 0; j--) {
                var bit = word >> j & 1;
                if (res !== wnd[0]) {
                  res = this.sqr(res);
                }
                if (bit === 0 && current === 0) {
                  currentLen = 0;
                  continue;
                }
                current <<= 1;
                current |= bit;
                currentLen++;
                if (currentLen !== windowSize && (i !== 0 || j !== 0))
                  continue;
                res = this.mul(res, wnd[current]);
                currentLen = 0;
                current = 0;
              }
              start = 26;
            }
            return res;
          };
          Red.prototype.convertTo = function convertTo(num) {
            var r = num.umod(this.m);
            return r === num ? r.clone() : r;
          };
          Red.prototype.convertFrom = function convertFrom(num) {
            var res = num.clone();
            res.red = null;
            return res;
          };
          BN.mont = function mont2(num) {
            return new Mont(num);
          };
          function Mont(m) {
            Red.call(this, m);
            this.shift = this.m.bitLength();
            if (this.shift % 26 !== 0) {
              this.shift += 26 - this.shift % 26;
            }
            this.r = new BN(1).iushln(this.shift);
            this.r2 = this.imod(this.r.sqr());
            this.rinv = this.r._invmp(this.m);
            this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
            this.minv = this.minv.umod(this.r);
            this.minv = this.r.sub(this.minv);
          }
          inherits2(Mont, Red);
          Mont.prototype.convertTo = function convertTo(num) {
            return this.imod(num.ushln(this.shift));
          };
          Mont.prototype.convertFrom = function convertFrom(num) {
            var r = this.imod(num.mul(this.rinv));
            r.red = null;
            return r;
          };
          Mont.prototype.imul = function imul(a, b) {
            if (a.isZero() || b.isZero()) {
              a.words[0] = 0;
              a.length = 1;
              return a;
            }
            var t = a.imul(b);
            var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
            var u = t.isub(c).iushrn(this.shift);
            var res = u;
            if (u.cmp(this.m) >= 0) {
              res = u.isub(this.m);
            } else if (u.cmpn(0) < 0) {
              res = u.iadd(this.m);
            }
            return res._forceRed(this);
          };
          Mont.prototype.mul = function mul(a, b) {
            if (a.isZero() || b.isZero())
              return new BN(0)._forceRed(this);
            var t = a.mul(b);
            var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
            var u = t.isub(c).iushrn(this.shift);
            var res = u;
            if (u.cmp(this.m) >= 0) {
              res = u.isub(this.m);
            } else if (u.cmpn(0) < 0) {
              res = u.iadd(this.m);
            }
            return res._forceRed(this);
          };
          Mont.prototype.invm = function invm(a) {
            var res = this.imod(a._invmp(this.m).mul(this.r2));
            return res._forceRed(this);
          };
        })(module2, commonjsGlobal);
      })(bn$1);
      return bnExports$1;
    }
    var brorandExports = {};
    var brorand = {
      get exports() {
        return brorandExports;
      },
      set exports(v2) {
        brorandExports = v2;
      }
    };
    var hasRequiredBrorand;
    function requireBrorand() {
      if (hasRequiredBrorand)
        return brorandExports;
      hasRequiredBrorand = 1;
      var r;
      brorand.exports = function rand(len) {
        if (!r)
          r = new Rand(null);
        return r.generate(len);
      };
      function Rand(rand) {
        this.rand = rand;
      }
      brorandExports.Rand = Rand;
      Rand.prototype.generate = function generate(len) {
        return this._rand(len);
      };
      Rand.prototype._rand = function _rand(n) {
        if (this.rand.getBytes)
          return this.rand.getBytes(n);
        var res = new Uint8Array(n);
        for (var i = 0; i < res.length; i++)
          res[i] = this.rand.getByte();
        return res;
      };
      if (typeof self === "object") {
        if (self.crypto && self.crypto.getRandomValues) {
          Rand.prototype._rand = function _rand(n) {
            var arr = new Uint8Array(n);
            self.crypto.getRandomValues(arr);
            return arr;
          };
        } else if (self.msCrypto && self.msCrypto.getRandomValues) {
          Rand.prototype._rand = function _rand(n) {
            var arr = new Uint8Array(n);
            self.msCrypto.getRandomValues(arr);
            return arr;
          };
        } else if (typeof window === "object") {
          Rand.prototype._rand = function() {
            throw new Error("Not implemented yet");
          };
        }
      } else {
        try {
          var crypto2 = requireCryptoBrowserify();
          if (typeof crypto2.randomBytes !== "function")
            throw new Error("Not supported");
          Rand.prototype._rand = function _rand(n) {
            return crypto2.randomBytes(n);
          };
        } catch (e) {
        }
      }
      return brorandExports;
    }
    var mr;
    var hasRequiredMr;
    function requireMr() {
      if (hasRequiredMr)
        return mr;
      hasRequiredMr = 1;
      var bn2 = requireBn$1();
      var brorand2 = requireBrorand();
      function MillerRabin(rand) {
        this.rand = rand || new brorand2.Rand();
      }
      mr = MillerRabin;
      MillerRabin.create = function create2(rand) {
        return new MillerRabin(rand);
      };
      MillerRabin.prototype._randbelow = function _randbelow(n) {
        var len = n.bitLength();
        var min_bytes = Math.ceil(len / 8);
        do
          var a = new bn2(this.rand.generate(min_bytes));
        while (a.cmp(n) >= 0);
        return a;
      };
      MillerRabin.prototype._randrange = function _randrange(start, stop) {
        var size = stop.sub(start);
        return start.add(this._randbelow(size));
      };
      MillerRabin.prototype.test = function test(n, k, cb) {
        var len = n.bitLength();
        var red = bn2.mont(n);
        var rone = new bn2(1).toRed(red);
        if (!k)
          k = Math.max(1, len / 48 | 0);
        var n1 = n.subn(1);
        for (var s = 0; !n1.testn(s); s++) {
        }
        var d = n.shrn(s);
        var rn1 = n1.toRed(red);
        var prime = true;
        for (; k > 0; k--) {
          var a = this._randrange(new bn2(2), n1);
          if (cb)
            cb(a);
          var x = a.toRed(red).redPow(d);
          if (x.cmp(rone) === 0 || x.cmp(rn1) === 0)
            continue;
          for (var i = 1; i < s; i++) {
            x = x.redSqr();
            if (x.cmp(rone) === 0)
              return false;
            if (x.cmp(rn1) === 0)
              break;
          }
          if (i === s)
            return false;
        }
        return prime;
      };
      MillerRabin.prototype.getDivisor = function getDivisor(n, k) {
        var len = n.bitLength();
        var red = bn2.mont(n);
        var rone = new bn2(1).toRed(red);
        if (!k)
          k = Math.max(1, len / 48 | 0);
        var n1 = n.subn(1);
        for (var s = 0; !n1.testn(s); s++) {
        }
        var d = n.shrn(s);
        var rn1 = n1.toRed(red);
        for (; k > 0; k--) {
          var a = this._randrange(new bn2(2), n1);
          var g = n.gcd(a);
          if (g.cmpn(1) !== 0)
            return g;
          var x = a.toRed(red).redPow(d);
          if (x.cmp(rone) === 0 || x.cmp(rn1) === 0)
            continue;
          for (var i = 1; i < s; i++) {
            x = x.redSqr();
            if (x.cmp(rone) === 0)
              return x.fromRed().subn(1).gcd(n);
            if (x.cmp(rn1) === 0)
              break;
          }
          if (i === s) {
            x = x.redSqr();
            return x.fromRed().subn(1).gcd(n);
          }
        }
        return false;
      };
      return mr;
    }
    var generatePrime;
    var hasRequiredGeneratePrime;
    function requireGeneratePrime() {
      if (hasRequiredGeneratePrime)
        return generatePrime;
      hasRequiredGeneratePrime = 1;
      var randomBytes2 = browserExports$1;
      generatePrime = findPrime;
      findPrime.simpleSieve = simpleSieve;
      findPrime.fermatTest = fermatTest;
      var BN = requireBn$1();
      var TWENTYFOUR = new BN(24);
      var MillerRabin = requireMr();
      var millerRabin = new MillerRabin();
      var ONE = new BN(1);
      var TWO = new BN(2);
      var FIVE = new BN(5);
      new BN(16);
      new BN(8);
      var TEN = new BN(10);
      var THREE = new BN(3);
      new BN(7);
      var ELEVEN = new BN(11);
      var FOUR = new BN(4);
      new BN(12);
      var primes = null;
      function _getPrimes() {
        if (primes !== null)
          return primes;
        var limit = 1048576;
        var res = [];
        res[0] = 2;
        for (var i = 1, k = 3; k < limit; k += 2) {
          var sqrt = Math.ceil(Math.sqrt(k));
          for (var j = 0; j < i && res[j] <= sqrt; j++)
            if (k % res[j] === 0)
              break;
          if (i !== j && res[j] <= sqrt)
            continue;
          res[i++] = k;
        }
        primes = res;
        return res;
      }
      function simpleSieve(p) {
        var primes2 = _getPrimes();
        for (var i = 0; i < primes2.length; i++)
          if (p.modn(primes2[i]) === 0) {
            if (p.cmpn(primes2[i]) === 0) {
              return true;
            } else {
              return false;
            }
          }
        return true;
      }
      function fermatTest(p) {
        var red = BN.mont(p);
        return TWO.toRed(red).redPow(p.subn(1)).fromRed().cmpn(1) === 0;
      }
      function findPrime(bits, gen) {
        if (bits < 16) {
          if (gen === 2 || gen === 5) {
            return new BN([140, 123]);
          } else {
            return new BN([140, 39]);
          }
        }
        gen = new BN(gen);
        var num, n2;
        while (true) {
          num = new BN(randomBytes2(Math.ceil(bits / 8)));
          while (num.bitLength() > bits) {
            num.ishrn(1);
          }
          if (num.isEven()) {
            num.iadd(ONE);
          }
          if (!num.testn(1)) {
            num.iadd(TWO);
          }
          if (!gen.cmp(TWO)) {
            while (num.mod(TWENTYFOUR).cmp(ELEVEN)) {
              num.iadd(FOUR);
            }
          } else if (!gen.cmp(FIVE)) {
            while (num.mod(TEN).cmp(THREE)) {
              num.iadd(FOUR);
            }
          }
          n2 = num.shrn(1);
          if (simpleSieve(n2) && simpleSieve(num) && fermatTest(n2) && fermatTest(num) && millerRabin.test(n2) && millerRabin.test(num)) {
            return num;
          }
        }
      }
      return generatePrime;
    }
    var modp1 = {
      gen: "02",
      prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff"
    };
    var modp2 = {
      gen: "02",
      prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff"
    };
    var modp5 = {
      gen: "02",
      prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff"
    };
    var modp14 = {
      gen: "02",
      prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff"
    };
    var modp15 = {
      gen: "02",
      prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff"
    };
    var modp16 = {
      gen: "02",
      prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff"
    };
    var modp17 = {
      gen: "02",
      prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff"
    };
    var modp18 = {
      gen: "02",
      prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff"
    };
    var require$$1$1 = {
      modp1,
      modp2,
      modp5,
      modp14,
      modp15,
      modp16,
      modp17,
      modp18
    };
    var dh;
    var hasRequiredDh;
    function requireDh() {
      if (hasRequiredDh)
        return dh;
      hasRequiredDh = 1;
      var BN = requireBn$1();
      var MillerRabin = requireMr();
      var millerRabin = new MillerRabin();
      var TWENTYFOUR = new BN(24);
      var ELEVEN = new BN(11);
      var TEN = new BN(10);
      var THREE = new BN(3);
      var SEVEN = new BN(7);
      var primes = requireGeneratePrime();
      var randomBytes2 = browserExports$1;
      dh = DH;
      function setPublicKey(pub, enc) {
        enc = enc || "utf8";
        if (!Buffer.isBuffer(pub)) {
          pub = new Buffer(pub, enc);
        }
        this._pub = new BN(pub);
        return this;
      }
      function setPrivateKey(priv, enc) {
        enc = enc || "utf8";
        if (!Buffer.isBuffer(priv)) {
          priv = new Buffer(priv, enc);
        }
        this._priv = new BN(priv);
        return this;
      }
      var primeCache = {};
      function checkPrime(prime, generator) {
        var gen = generator.toString("hex");
        var hex = [gen, prime.toString(16)].join("_");
        if (hex in primeCache) {
          return primeCache[hex];
        }
        var error = 0;
        if (prime.isEven() || !primes.simpleSieve || !primes.fermatTest(prime) || !millerRabin.test(prime)) {
          error += 1;
          if (gen === "02" || gen === "05") {
            error += 8;
          } else {
            error += 4;
          }
          primeCache[hex] = error;
          return error;
        }
        if (!millerRabin.test(prime.shrn(1))) {
          error += 2;
        }
        var rem;
        switch (gen) {
          case "02":
            if (prime.mod(TWENTYFOUR).cmp(ELEVEN)) {
              error += 8;
            }
            break;
          case "05":
            rem = prime.mod(TEN);
            if (rem.cmp(THREE) && rem.cmp(SEVEN)) {
              error += 8;
            }
            break;
          default:
            error += 4;
        }
        primeCache[hex] = error;
        return error;
      }
      function DH(prime, generator, malleable) {
        this.setGenerator(generator);
        this.__prime = new BN(prime);
        this._prime = BN.mont(this.__prime);
        this._primeLen = prime.length;
        this._pub = void 0;
        this._priv = void 0;
        this._primeCode = void 0;
        if (malleable) {
          this.setPublicKey = setPublicKey;
          this.setPrivateKey = setPrivateKey;
        } else {
          this._primeCode = 8;
        }
      }
      Object.defineProperty(DH.prototype, "verifyError", {
        enumerable: true,
        get: function() {
          if (typeof this._primeCode !== "number") {
            this._primeCode = checkPrime(this.__prime, this.__gen);
          }
          return this._primeCode;
        }
      });
      DH.prototype.generateKeys = function() {
        if (!this._priv) {
          this._priv = new BN(randomBytes2(this._primeLen));
        }
        this._pub = this._gen.toRed(this._prime).redPow(this._priv).fromRed();
        return this.getPublicKey();
      };
      DH.prototype.computeSecret = function(other) {
        other = new BN(other);
        other = other.toRed(this._prime);
        var secret = other.redPow(this._priv).fromRed();
        var out = new Buffer(secret.toArray());
        var prime = this.getPrime();
        if (out.length < prime.length) {
          var front = new Buffer(prime.length - out.length);
          front.fill(0);
          out = Buffer.concat([front, out]);
        }
        return out;
      };
      DH.prototype.getPublicKey = function getPublicKey(enc) {
        return formatReturnValue(this._pub, enc);
      };
      DH.prototype.getPrivateKey = function getPrivateKey(enc) {
        return formatReturnValue(this._priv, enc);
      };
      DH.prototype.getPrime = function(enc) {
        return formatReturnValue(this.__prime, enc);
      };
      DH.prototype.getGenerator = function(enc) {
        return formatReturnValue(this._gen, enc);
      };
      DH.prototype.setGenerator = function(gen, enc) {
        enc = enc || "utf8";
        if (!Buffer.isBuffer(gen)) {
          gen = new Buffer(gen, enc);
        }
        this.__gen = gen;
        this._gen = new BN(gen);
        return this;
      };
      function formatReturnValue(bn2, enc) {
        var buf2 = new Buffer(bn2.toArray());
        if (!enc) {
          return buf2;
        } else {
          return buf2.toString(enc);
        }
      }
      return dh;
    }
    var hasRequiredBrowser$4;
    function requireBrowser$4() {
      if (hasRequiredBrowser$4)
        return browser$5;
      hasRequiredBrowser$4 = 1;
      var generatePrime2 = requireGeneratePrime();
      var primes = require$$1$1;
      var DH = requireDh();
      function getDiffieHellman(mod) {
        var prime = new Buffer(primes[mod].prime, "hex");
        var gen = new Buffer(primes[mod].gen, "hex");
        return new DH(prime, gen);
      }
      var ENCODINGS = {
        binary: true,
        hex: true,
        base64: true
      };
      function createDiffieHellman(prime, enc, generator, genc) {
        if (Buffer.isBuffer(enc) || ENCODINGS[enc] === void 0) {
          return createDiffieHellman(prime, "binary", enc, generator);
        }
        enc = enc || "binary";
        genc = genc || "binary";
        generator = generator || new Buffer([2]);
        if (!Buffer.isBuffer(generator)) {
          generator = new Buffer(generator, genc);
        }
        if (typeof prime === "number") {
          return new DH(generatePrime2(prime, generator), generator, true);
        }
        if (!Buffer.isBuffer(prime)) {
          prime = new Buffer(prime, enc);
        }
        return new DH(prime, generator, true);
      }
      browser$5.DiffieHellmanGroup = browser$5.createDiffieHellmanGroup = browser$5.getDiffieHellman = getDiffieHellman;
      browser$5.createDiffieHellman = browser$5.DiffieHellman = createDiffieHellman;
      return browser$5;
    }
    var signExports = {};
    var sign = {
      get exports() {
        return signExports;
      },
      set exports(v2) {
        signExports = v2;
      }
    };
    var bnExports = {};
    var bn = {
      get exports() {
        return bnExports;
      },
      set exports(v2) {
        bnExports = v2;
      }
    };
    var hasRequiredBn;
    function requireBn() {
      if (hasRequiredBn)
        return bnExports;
      hasRequiredBn = 1;
      (function(module2) {
        (function(module3, exports2) {
          function assert2(val, msg) {
            if (!val)
              throw new Error(msg || "Assertion failed");
          }
          function inherits2(ctor, superCtor) {
            ctor.super_ = superCtor;
            var TempCtor = function() {
            };
            TempCtor.prototype = superCtor.prototype;
            ctor.prototype = new TempCtor();
            ctor.prototype.constructor = ctor;
          }
          function BN(number2, base2, endian) {
            if (BN.isBN(number2)) {
              return number2;
            }
            this.negative = 0;
            this.words = null;
            this.length = 0;
            this.red = null;
            if (number2 !== null) {
              if (base2 === "le" || base2 === "be") {
                endian = base2;
                base2 = 10;
              }
              this._init(number2 || 0, base2 || 10, endian || "be");
            }
          }
          if (typeof module3 === "object") {
            module3.exports = BN;
          } else {
            exports2.BN = BN;
          }
          BN.BN = BN;
          BN.wordSize = 26;
          var Buffer2;
          try {
            if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
              Buffer2 = window.Buffer;
            } else {
              Buffer2 = require$$6$1.Buffer;
            }
          } catch (e) {
          }
          BN.isBN = function isBN(num) {
            if (num instanceof BN) {
              return true;
            }
            return num !== null && typeof num === "object" && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
          };
          BN.max = function max(left, right) {
            if (left.cmp(right) > 0)
              return left;
            return right;
          };
          BN.min = function min(left, right) {
            if (left.cmp(right) < 0)
              return left;
            return right;
          };
          BN.prototype._init = function init2(number2, base2, endian) {
            if (typeof number2 === "number") {
              return this._initNumber(number2, base2, endian);
            }
            if (typeof number2 === "object") {
              return this._initArray(number2, base2, endian);
            }
            if (base2 === "hex") {
              base2 = 16;
            }
            assert2(base2 === (base2 | 0) && base2 >= 2 && base2 <= 36);
            number2 = number2.toString().replace(/\s+/g, "");
            var start = 0;
            if (number2[0] === "-") {
              start++;
              this.negative = 1;
            }
            if (start < number2.length) {
              if (base2 === 16) {
                this._parseHex(number2, start, endian);
              } else {
                this._parseBase(number2, base2, start);
                if (endian === "le") {
                  this._initArray(this.toArray(), base2, endian);
                }
              }
            }
          };
          BN.prototype._initNumber = function _initNumber(number2, base2, endian) {
            if (number2 < 0) {
              this.negative = 1;
              number2 = -number2;
            }
            if (number2 < 67108864) {
              this.words = [number2 & 67108863];
              this.length = 1;
            } else if (number2 < 4503599627370496) {
              this.words = [
                number2 & 67108863,
                number2 / 67108864 & 67108863
              ];
              this.length = 2;
            } else {
              assert2(number2 < 9007199254740992);
              this.words = [
                number2 & 67108863,
                number2 / 67108864 & 67108863,
                1
              ];
              this.length = 3;
            }
            if (endian !== "le")
              return;
            this._initArray(this.toArray(), base2, endian);
          };
          BN.prototype._initArray = function _initArray(number2, base2, endian) {
            assert2(typeof number2.length === "number");
            if (number2.length <= 0) {
              this.words = [0];
              this.length = 1;
              return this;
            }
            this.length = Math.ceil(number2.length / 3);
            this.words = new Array(this.length);
            for (var i = 0; i < this.length; i++) {
              this.words[i] = 0;
            }
            var j, w;
            var off2 = 0;
            if (endian === "be") {
              for (i = number2.length - 1, j = 0; i >= 0; i -= 3) {
                w = number2[i] | number2[i - 1] << 8 | number2[i - 2] << 16;
                this.words[j] |= w << off2 & 67108863;
                this.words[j + 1] = w >>> 26 - off2 & 67108863;
                off2 += 24;
                if (off2 >= 26) {
                  off2 -= 26;
                  j++;
                }
              }
            } else if (endian === "le") {
              for (i = 0, j = 0; i < number2.length; i += 3) {
                w = number2[i] | number2[i + 1] << 8 | number2[i + 2] << 16;
                this.words[j] |= w << off2 & 67108863;
                this.words[j + 1] = w >>> 26 - off2 & 67108863;
                off2 += 24;
                if (off2 >= 26) {
                  off2 -= 26;
                  j++;
                }
              }
            }
            return this._strip();
          };
          function parseHex4Bits(string, index2) {
            var c = string.charCodeAt(index2);
            if (c >= 48 && c <= 57) {
              return c - 48;
            } else if (c >= 65 && c <= 70) {
              return c - 55;
            } else if (c >= 97 && c <= 102) {
              return c - 87;
            } else {
              assert2(false, "Invalid character in " + string);
            }
          }
          function parseHexByte(string, lowerBound, index2) {
            var r = parseHex4Bits(string, index2);
            if (index2 - 1 >= lowerBound) {
              r |= parseHex4Bits(string, index2 - 1) << 4;
            }
            return r;
          }
          BN.prototype._parseHex = function _parseHex(number2, start, endian) {
            this.length = Math.ceil((number2.length - start) / 6);
            this.words = new Array(this.length);
            for (var i = 0; i < this.length; i++) {
              this.words[i] = 0;
            }
            var off2 = 0;
            var j = 0;
            var w;
            if (endian === "be") {
              for (i = number2.length - 1; i >= start; i -= 2) {
                w = parseHexByte(number2, start, i) << off2;
                this.words[j] |= w & 67108863;
                if (off2 >= 18) {
                  off2 -= 18;
                  j += 1;
                  this.words[j] |= w >>> 26;
                } else {
                  off2 += 8;
                }
              }
            } else {
              var parseLength = number2.length - start;
              for (i = parseLength % 2 === 0 ? start + 1 : start; i < number2.length; i += 2) {
                w = parseHexByte(number2, start, i) << off2;
                this.words[j] |= w & 67108863;
                if (off2 >= 18) {
                  off2 -= 18;
                  j += 1;
                  this.words[j] |= w >>> 26;
                } else {
                  off2 += 8;
                }
              }
            }
            this._strip();
          };
          function parseBase(str, start, end, mul) {
            var r = 0;
            var b = 0;
            var len = Math.min(str.length, end);
            for (var i = start; i < len; i++) {
              var c = str.charCodeAt(i) - 48;
              r *= mul;
              if (c >= 49) {
                b = c - 49 + 10;
              } else if (c >= 17) {
                b = c - 17 + 10;
              } else {
                b = c;
              }
              assert2(c >= 0 && b < mul, "Invalid character");
              r += b;
            }
            return r;
          }
          BN.prototype._parseBase = function _parseBase(number2, base2, start) {
            this.words = [0];
            this.length = 1;
            for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base2) {
              limbLen++;
            }
            limbLen--;
            limbPow = limbPow / base2 | 0;
            var total = number2.length - start;
            var mod = total % limbLen;
            var end = Math.min(total, total - mod) + start;
            var word = 0;
            for (var i = start; i < end; i += limbLen) {
              word = parseBase(number2, i, i + limbLen, base2);
              this.imuln(limbPow);
              if (this.words[0] + word < 67108864) {
                this.words[0] += word;
              } else {
                this._iaddn(word);
              }
            }
            if (mod !== 0) {
              var pow = 1;
              word = parseBase(number2, i, number2.length, base2);
              for (i = 0; i < mod; i++) {
                pow *= base2;
              }
              this.imuln(pow);
              if (this.words[0] + word < 67108864) {
                this.words[0] += word;
              } else {
                this._iaddn(word);
              }
            }
            this._strip();
          };
          BN.prototype.copy = function copy(dest) {
            dest.words = new Array(this.length);
            for (var i = 0; i < this.length; i++) {
              dest.words[i] = this.words[i];
            }
            dest.length = this.length;
            dest.negative = this.negative;
            dest.red = this.red;
          };
          function move(dest, src2) {
            dest.words = src2.words;
            dest.length = src2.length;
            dest.negative = src2.negative;
            dest.red = src2.red;
          }
          BN.prototype._move = function _move(dest) {
            move(dest, this);
          };
          BN.prototype.clone = function clone() {
            var r = new BN(null);
            this.copy(r);
            return r;
          };
          BN.prototype._expand = function _expand(size) {
            while (this.length < size) {
              this.words[this.length++] = 0;
            }
            return this;
          };
          BN.prototype._strip = function strip() {
            while (this.length > 1 && this.words[this.length - 1] === 0) {
              this.length--;
            }
            return this._normSign();
          };
          BN.prototype._normSign = function _normSign() {
            if (this.length === 1 && this.words[0] === 0) {
              this.negative = 0;
            }
            return this;
          };
          if (typeof Symbol !== "undefined" && typeof Symbol.for === "function") {
            try {
              BN.prototype[Symbol.for("nodejs.util.inspect.custom")] = inspect2;
            } catch (e) {
              BN.prototype.inspect = inspect2;
            }
          } else {
            BN.prototype.inspect = inspect2;
          }
          function inspect2() {
            return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
          }
          var zeros = [
            "",
            "0",
            "00",
            "000",
            "0000",
            "00000",
            "000000",
            "0000000",
            "00000000",
            "000000000",
            "0000000000",
            "00000000000",
            "000000000000",
            "0000000000000",
            "00000000000000",
            "000000000000000",
            "0000000000000000",
            "00000000000000000",
            "000000000000000000",
            "0000000000000000000",
            "00000000000000000000",
            "000000000000000000000",
            "0000000000000000000000",
            "00000000000000000000000",
            "000000000000000000000000",
            "0000000000000000000000000"
          ];
          var groupSizes = [
            0,
            0,
            25,
            16,
            12,
            11,
            10,
            9,
            8,
            8,
            7,
            7,
            7,
            7,
            6,
            6,
            6,
            6,
            6,
            6,
            6,
            5,
            5,
            5,
            5,
            5,
            5,
            5,
            5,
            5,
            5,
            5,
            5,
            5,
            5,
            5,
            5
          ];
          var groupBases = [
            0,
            0,
            33554432,
            43046721,
            16777216,
            48828125,
            60466176,
            40353607,
            16777216,
            43046721,
            1e7,
            19487171,
            35831808,
            62748517,
            7529536,
            11390625,
            16777216,
            24137569,
            34012224,
            47045881,
            64e6,
            4084101,
            5153632,
            6436343,
            7962624,
            9765625,
            11881376,
            14348907,
            17210368,
            20511149,
            243e5,
            28629151,
            33554432,
            39135393,
            45435424,
            52521875,
            60466176
          ];
          BN.prototype.toString = function toString2(base2, padding) {
            base2 = base2 || 10;
            padding = padding | 0 || 1;
            var out;
            if (base2 === 16 || base2 === "hex") {
              out = "";
              var off2 = 0;
              var carry = 0;
              for (var i = 0; i < this.length; i++) {
                var w = this.words[i];
                var word = ((w << off2 | carry) & 16777215).toString(16);
                carry = w >>> 24 - off2 & 16777215;
                off2 += 2;
                if (off2 >= 26) {
                  off2 -= 26;
                  i--;
                }
                if (carry !== 0 || i !== this.length - 1) {
                  out = zeros[6 - word.length] + word + out;
                } else {
                  out = word + out;
                }
              }
              if (carry !== 0) {
                out = carry.toString(16) + out;
              }
              while (out.length % padding !== 0) {
                out = "0" + out;
              }
              if (this.negative !== 0) {
                out = "-" + out;
              }
              return out;
            }
            if (base2 === (base2 | 0) && base2 >= 2 && base2 <= 36) {
              var groupSize = groupSizes[base2];
              var groupBase = groupBases[base2];
              out = "";
              var c = this.clone();
              c.negative = 0;
              while (!c.isZero()) {
                var r = c.modrn(groupBase).toString(base2);
                c = c.idivn(groupBase);
                if (!c.isZero()) {
                  out = zeros[groupSize - r.length] + r + out;
                } else {
                  out = r + out;
                }
              }
              if (this.isZero()) {
                out = "0" + out;
              }
              while (out.length % padding !== 0) {
                out = "0" + out;
              }
              if (this.negative !== 0) {
                out = "-" + out;
              }
              return out;
            }
            assert2(false, "Base should be between 2 and 36");
          };
          BN.prototype.toNumber = function toNumber() {
            var ret = this.words[0];
            if (this.length === 2) {
              ret += this.words[1] * 67108864;
            } else if (this.length === 3 && this.words[2] === 1) {
              ret += 4503599627370496 + this.words[1] * 67108864;
            } else if (this.length > 2) {
              assert2(false, "Number can only safely store up to 53 bits");
            }
            return this.negative !== 0 ? -ret : ret;
          };
          BN.prototype.toJSON = function toJSON() {
            return this.toString(16, 2);
          };
          if (Buffer2) {
            BN.prototype.toBuffer = function toBuffer2(endian, length2) {
              return this.toArrayLike(Buffer2, endian, length2);
            };
          }
          BN.prototype.toArray = function toArray(endian, length2) {
            return this.toArrayLike(Array, endian, length2);
          };
          var allocate = function allocate2(ArrayType, size) {
            if (ArrayType.allocUnsafe) {
              return ArrayType.allocUnsafe(size);
            }
            return new ArrayType(size);
          };
          BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length2) {
            this._strip();
            var byteLength2 = this.byteLength();
            var reqLength = length2 || Math.max(1, byteLength2);
            assert2(byteLength2 <= reqLength, "byte array longer than desired length");
            assert2(reqLength > 0, "Requested array length <= 0");
            var res = allocate(ArrayType, reqLength);
            var postfix = endian === "le" ? "LE" : "BE";
            this["_toArrayLike" + postfix](res, byteLength2);
            return res;
          };
          BN.prototype._toArrayLikeLE = function _toArrayLikeLE(res, byteLength2) {
            var position = 0;
            var carry = 0;
            for (var i = 0, shift = 0; i < this.length; i++) {
              var word = this.words[i] << shift | carry;
              res[position++] = word & 255;
              if (position < res.length) {
                res[position++] = word >> 8 & 255;
              }
              if (position < res.length) {
                res[position++] = word >> 16 & 255;
              }
              if (shift === 6) {
                if (position < res.length) {
                  res[position++] = word >> 24 & 255;
                }
                carry = 0;
                shift = 0;
              } else {
                carry = word >>> 24;
                shift += 2;
              }
            }
            if (position < res.length) {
              res[position++] = carry;
              while (position < res.length) {
                res[position++] = 0;
              }
            }
          };
          BN.prototype._toArrayLikeBE = function _toArrayLikeBE(res, byteLength2) {
            var position = res.length - 1;
            var carry = 0;
            for (var i = 0, shift = 0; i < this.length; i++) {
              var word = this.words[i] << shift | carry;
              res[position--] = word & 255;
              if (position >= 0) {
                res[position--] = word >> 8 & 255;
              }
              if (position >= 0) {
                res[position--] = word >> 16 & 255;
              }
              if (shift === 6) {
                if (position >= 0) {
                  res[position--] = word >> 24 & 255;
                }
                carry = 0;
                shift = 0;
              } else {
                carry = word >>> 24;
                shift += 2;
              }
            }
            if (position >= 0) {
              res[position--] = carry;
              while (position >= 0) {
                res[position--] = 0;
              }
            }
          };
          if (Math.clz32) {
            BN.prototype._countBits = function _countBits(w) {
              return 32 - Math.clz32(w);
            };
          } else {
            BN.prototype._countBits = function _countBits(w) {
              var t = w;
              var r = 0;
              if (t >= 4096) {
                r += 13;
                t >>>= 13;
              }
              if (t >= 64) {
                r += 7;
                t >>>= 7;
              }
              if (t >= 8) {
                r += 4;
                t >>>= 4;
              }
              if (t >= 2) {
                r += 2;
                t >>>= 2;
              }
              return r + t;
            };
          }
          BN.prototype._zeroBits = function _zeroBits(w) {
            if (w === 0)
              return 26;
            var t = w;
            var r = 0;
            if ((t & 8191) === 0) {
              r += 13;
              t >>>= 13;
            }
            if ((t & 127) === 0) {
              r += 7;
              t >>>= 7;
            }
            if ((t & 15) === 0) {
              r += 4;
              t >>>= 4;
            }
            if ((t & 3) === 0) {
              r += 2;
              t >>>= 2;
            }
            if ((t & 1) === 0) {
              r++;
            }
            return r;
          };
          BN.prototype.bitLength = function bitLength() {
            var w = this.words[this.length - 1];
            var hi = this._countBits(w);
            return (this.length - 1) * 26 + hi;
          };
          function toBitArray(num) {
            var w = new Array(num.bitLength());
            for (var bit = 0; bit < w.length; bit++) {
              var off2 = bit / 26 | 0;
              var wbit = bit % 26;
              w[bit] = num.words[off2] >>> wbit & 1;
            }
            return w;
          }
          BN.prototype.zeroBits = function zeroBits() {
            if (this.isZero())
              return 0;
            var r = 0;
            for (var i = 0; i < this.length; i++) {
              var b = this._zeroBits(this.words[i]);
              r += b;
              if (b !== 26)
                break;
            }
            return r;
          };
          BN.prototype.byteLength = function byteLength2() {
            return Math.ceil(this.bitLength() / 8);
          };
          BN.prototype.toTwos = function toTwos(width) {
            if (this.negative !== 0) {
              return this.abs().inotn(width).iaddn(1);
            }
            return this.clone();
          };
          BN.prototype.fromTwos = function fromTwos(width) {
            if (this.testn(width - 1)) {
              return this.notn(width).iaddn(1).ineg();
            }
            return this.clone();
          };
          BN.prototype.isNeg = function isNeg() {
            return this.negative !== 0;
          };
          BN.prototype.neg = function neg() {
            return this.clone().ineg();
          };
          BN.prototype.ineg = function ineg() {
            if (!this.isZero()) {
              this.negative ^= 1;
            }
            return this;
          };
          BN.prototype.iuor = function iuor(num) {
            while (this.length < num.length) {
              this.words[this.length++] = 0;
            }
            for (var i = 0; i < num.length; i++) {
              this.words[i] = this.words[i] | num.words[i];
            }
            return this._strip();
          };
          BN.prototype.ior = function ior(num) {
            assert2((this.negative | num.negative) === 0);
            return this.iuor(num);
          };
          BN.prototype.or = function or2(num) {
            if (this.length > num.length)
              return this.clone().ior(num);
            return num.clone().ior(this);
          };
          BN.prototype.uor = function uor(num) {
            if (this.length > num.length)
              return this.clone().iuor(num);
            return num.clone().iuor(this);
          };
          BN.prototype.iuand = function iuand(num) {
            var b;
            if (this.length > num.length) {
              b = num;
            } else {
              b = this;
            }
            for (var i = 0; i < b.length; i++) {
              this.words[i] = this.words[i] & num.words[i];
            }
            this.length = b.length;
            return this._strip();
          };
          BN.prototype.iand = function iand(num) {
            assert2((this.negative | num.negative) === 0);
            return this.iuand(num);
          };
          BN.prototype.and = function and(num) {
            if (this.length > num.length)
              return this.clone().iand(num);
            return num.clone().iand(this);
          };
          BN.prototype.uand = function uand(num) {
            if (this.length > num.length)
              return this.clone().iuand(num);
            return num.clone().iuand(this);
          };
          BN.prototype.iuxor = function iuxor(num) {
            var a;
            var b;
            if (this.length > num.length) {
              a = this;
              b = num;
            } else {
              a = num;
              b = this;
            }
            for (var i = 0; i < b.length; i++) {
              this.words[i] = a.words[i] ^ b.words[i];
            }
            if (this !== a) {
              for (; i < a.length; i++) {
                this.words[i] = a.words[i];
              }
            }
            this.length = a.length;
            return this._strip();
          };
          BN.prototype.ixor = function ixor(num) {
            assert2((this.negative | num.negative) === 0);
            return this.iuxor(num);
          };
          BN.prototype.xor = function xor2(num) {
            if (this.length > num.length)
              return this.clone().ixor(num);
            return num.clone().ixor(this);
          };
          BN.prototype.uxor = function uxor(num) {
            if (this.length > num.length)
              return this.clone().iuxor(num);
            return num.clone().iuxor(this);
          };
          BN.prototype.inotn = function inotn(width) {
            assert2(typeof width === "number" && width >= 0);
            var bytesNeeded = Math.ceil(width / 26) | 0;
            var bitsLeft = width % 26;
            this._expand(bytesNeeded);
            if (bitsLeft > 0) {
              bytesNeeded--;
            }
            for (var i = 0; i < bytesNeeded; i++) {
              this.words[i] = ~this.words[i] & 67108863;
            }
            if (bitsLeft > 0) {
              this.words[i] = ~this.words[i] & 67108863 >> 26 - bitsLeft;
            }
            return this._strip();
          };
          BN.prototype.notn = function notn(width) {
            return this.clone().inotn(width);
          };
          BN.prototype.setn = function setn(bit, val) {
            assert2(typeof bit === "number" && bit >= 0);
            var off2 = bit / 26 | 0;
            var wbit = bit % 26;
            this._expand(off2 + 1);
            if (val) {
              this.words[off2] = this.words[off2] | 1 << wbit;
            } else {
              this.words[off2] = this.words[off2] & ~(1 << wbit);
            }
            return this._strip();
          };
          BN.prototype.iadd = function iadd(num) {
            var r;
            if (this.negative !== 0 && num.negative === 0) {
              this.negative = 0;
              r = this.isub(num);
              this.negative ^= 1;
              return this._normSign();
            } else if (this.negative === 0 && num.negative !== 0) {
              num.negative = 0;
              r = this.isub(num);
              num.negative = 1;
              return r._normSign();
            }
            var a, b;
            if (this.length > num.length) {
              a = this;
              b = num;
            } else {
              a = num;
              b = this;
            }
            var carry = 0;
            for (var i = 0; i < b.length; i++) {
              r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
              this.words[i] = r & 67108863;
              carry = r >>> 26;
            }
            for (; carry !== 0 && i < a.length; i++) {
              r = (a.words[i] | 0) + carry;
              this.words[i] = r & 67108863;
              carry = r >>> 26;
            }
            this.length = a.length;
            if (carry !== 0) {
              this.words[this.length] = carry;
              this.length++;
            } else if (a !== this) {
              for (; i < a.length; i++) {
                this.words[i] = a.words[i];
              }
            }
            return this;
          };
          BN.prototype.add = function add(num) {
            var res;
            if (num.negative !== 0 && this.negative === 0) {
              num.negative = 0;
              res = this.sub(num);
              num.negative ^= 1;
              return res;
            } else if (num.negative === 0 && this.negative !== 0) {
              this.negative = 0;
              res = num.sub(this);
              this.negative = 1;
              return res;
            }
            if (this.length > num.length)
              return this.clone().iadd(num);
            return num.clone().iadd(this);
          };
          BN.prototype.isub = function isub(num) {
            if (num.negative !== 0) {
              num.negative = 0;
              var r = this.iadd(num);
              num.negative = 1;
              return r._normSign();
            } else if (this.negative !== 0) {
              this.negative = 0;
              this.iadd(num);
              this.negative = 1;
              return this._normSign();
            }
            var cmp = this.cmp(num);
            if (cmp === 0) {
              this.negative = 0;
              this.length = 1;
              this.words[0] = 0;
              return this;
            }
            var a, b;
            if (cmp > 0) {
              a = this;
              b = num;
            } else {
              a = num;
              b = this;
            }
            var carry = 0;
            for (var i = 0; i < b.length; i++) {
              r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
              carry = r >> 26;
              this.words[i] = r & 67108863;
            }
            for (; carry !== 0 && i < a.length; i++) {
              r = (a.words[i] | 0) + carry;
              carry = r >> 26;
              this.words[i] = r & 67108863;
            }
            if (carry === 0 && i < a.length && a !== this) {
              for (; i < a.length; i++) {
                this.words[i] = a.words[i];
              }
            }
            this.length = Math.max(this.length, i);
            if (a !== this) {
              this.negative = 1;
            }
            return this._strip();
          };
          BN.prototype.sub = function sub(num) {
            return this.clone().isub(num);
          };
          function smallMulTo(self2, num, out) {
            out.negative = num.negative ^ self2.negative;
            var len = self2.length + num.length | 0;
            out.length = len;
            len = len - 1 | 0;
            var a = self2.words[0] | 0;
            var b = num.words[0] | 0;
            var r = a * b;
            var lo = r & 67108863;
            var carry = r / 67108864 | 0;
            out.words[0] = lo;
            for (var k = 1; k < len; k++) {
              var ncarry = carry >>> 26;
              var rword = carry & 67108863;
              var maxJ = Math.min(k, num.length - 1);
              for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
                var i = k - j | 0;
                a = self2.words[i] | 0;
                b = num.words[j] | 0;
                r = a * b + rword;
                ncarry += r / 67108864 | 0;
                rword = r & 67108863;
              }
              out.words[k] = rword | 0;
              carry = ncarry | 0;
            }
            if (carry !== 0) {
              out.words[k] = carry | 0;
            } else {
              out.length--;
            }
            return out._strip();
          }
          var comb10MulTo = function comb10MulTo2(self2, num, out) {
            var a = self2.words;
            var b = num.words;
            var o = out.words;
            var c = 0;
            var lo;
            var mid;
            var hi;
            var a0 = a[0] | 0;
            var al0 = a0 & 8191;
            var ah0 = a0 >>> 13;
            var a1 = a[1] | 0;
            var al1 = a1 & 8191;
            var ah1 = a1 >>> 13;
            var a2 = a[2] | 0;
            var al2 = a2 & 8191;
            var ah2 = a2 >>> 13;
            var a3 = a[3] | 0;
            var al3 = a3 & 8191;
            var ah3 = a3 >>> 13;
            var a4 = a[4] | 0;
            var al4 = a4 & 8191;
            var ah4 = a4 >>> 13;
            var a5 = a[5] | 0;
            var al5 = a5 & 8191;
            var ah5 = a5 >>> 13;
            var a6 = a[6] | 0;
            var al6 = a6 & 8191;
            var ah6 = a6 >>> 13;
            var a7 = a[7] | 0;
            var al7 = a7 & 8191;
            var ah7 = a7 >>> 13;
            var a8 = a[8] | 0;
            var al8 = a8 & 8191;
            var ah8 = a8 >>> 13;
            var a9 = a[9] | 0;
            var al9 = a9 & 8191;
            var ah9 = a9 >>> 13;
            var b0 = b[0] | 0;
            var bl0 = b0 & 8191;
            var bh0 = b0 >>> 13;
            var b1 = b[1] | 0;
            var bl1 = b1 & 8191;
            var bh1 = b1 >>> 13;
            var b2 = b[2] | 0;
            var bl2 = b2 & 8191;
            var bh2 = b2 >>> 13;
            var b3 = b[3] | 0;
            var bl3 = b3 & 8191;
            var bh3 = b3 >>> 13;
            var b4 = b[4] | 0;
            var bl4 = b4 & 8191;
            var bh4 = b4 >>> 13;
            var b5 = b[5] | 0;
            var bl5 = b5 & 8191;
            var bh5 = b5 >>> 13;
            var b6 = b[6] | 0;
            var bl6 = b6 & 8191;
            var bh6 = b6 >>> 13;
            var b7 = b[7] | 0;
            var bl7 = b7 & 8191;
            var bh7 = b7 >>> 13;
            var b8 = b[8] | 0;
            var bl8 = b8 & 8191;
            var bh8 = b8 >>> 13;
            var b9 = b[9] | 0;
            var bl9 = b9 & 8191;
            var bh9 = b9 >>> 13;
            out.negative = self2.negative ^ num.negative;
            out.length = 19;
            lo = Math.imul(al0, bl0);
            mid = Math.imul(al0, bh0);
            mid = mid + Math.imul(ah0, bl0) | 0;
            hi = Math.imul(ah0, bh0);
            var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
            c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
            w0 &= 67108863;
            lo = Math.imul(al1, bl0);
            mid = Math.imul(al1, bh0);
            mid = mid + Math.imul(ah1, bl0) | 0;
            hi = Math.imul(ah1, bh0);
            lo = lo + Math.imul(al0, bl1) | 0;
            mid = mid + Math.imul(al0, bh1) | 0;
            mid = mid + Math.imul(ah0, bl1) | 0;
            hi = hi + Math.imul(ah0, bh1) | 0;
            var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
            c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
            w1 &= 67108863;
            lo = Math.imul(al2, bl0);
            mid = Math.imul(al2, bh0);
            mid = mid + Math.imul(ah2, bl0) | 0;
            hi = Math.imul(ah2, bh0);
            lo = lo + Math.imul(al1, bl1) | 0;
            mid = mid + Math.imul(al1, bh1) | 0;
            mid = mid + Math.imul(ah1, bl1) | 0;
            hi = hi + Math.imul(ah1, bh1) | 0;
            lo = lo + Math.imul(al0, bl2) | 0;
            mid = mid + Math.imul(al0, bh2) | 0;
            mid = mid + Math.imul(ah0, bl2) | 0;
            hi = hi + Math.imul(ah0, bh2) | 0;
            var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
            c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
            w2 &= 67108863;
            lo = Math.imul(al3, bl0);
            mid = Math.imul(al3, bh0);
            mid = mid + Math.imul(ah3, bl0) | 0;
            hi = Math.imul(ah3, bh0);
            lo = lo + Math.imul(al2, bl1) | 0;
            mid = mid + Math.imul(al2, bh1) | 0;
            mid = mid + Math.imul(ah2, bl1) | 0;
            hi = hi + Math.imul(ah2, bh1) | 0;
            lo = lo + Math.imul(al1, bl2) | 0;
            mid = mid + Math.imul(al1, bh2) | 0;
            mid = mid + Math.imul(ah1, bl2) | 0;
            hi = hi + Math.imul(ah1, bh2) | 0;
            lo = lo + Math.imul(al0, bl3) | 0;
            mid = mid + Math.imul(al0, bh3) | 0;
            mid = mid + Math.imul(ah0, bl3) | 0;
            hi = hi + Math.imul(ah0, bh3) | 0;
            var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
            c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
            w3 &= 67108863;
            lo = Math.imul(al4, bl0);
            mid = Math.imul(al4, bh0);
            mid = mid + Math.imul(ah4, bl0) | 0;
            hi = Math.imul(ah4, bh0);
            lo = lo + Math.imul(al3, bl1) | 0;
            mid = mid + Math.imul(al3, bh1) | 0;
            mid = mid + Math.imul(ah3, bl1) | 0;
            hi = hi + Math.imul(ah3, bh1) | 0;
            lo = lo + Math.imul(al2, bl2) | 0;
            mid = mid + Math.imul(al2, bh2) | 0;
            mid = mid + Math.imul(ah2, bl2) | 0;
            hi = hi + Math.imul(ah2, bh2) | 0;
            lo = lo + Math.imul(al1, bl3) | 0;
            mid = mid + Math.imul(al1, bh3) | 0;
            mid = mid + Math.imul(ah1, bl3) | 0;
            hi = hi + Math.imul(ah1, bh3) | 0;
            lo = lo + Math.imul(al0, bl4) | 0;
            mid = mid + Math.imul(al0, bh4) | 0;
            mid = mid + Math.imul(ah0, bl4) | 0;
            hi = hi + Math.imul(ah0, bh4) | 0;
            var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
            c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
            w4 &= 67108863;
            lo = Math.imul(al5, bl0);
            mid = Math.imul(al5, bh0);
            mid = mid + Math.imul(ah5, bl0) | 0;
            hi = Math.imul(ah5, bh0);
            lo = lo + Math.imul(al4, bl1) | 0;
            mid = mid + Math.imul(al4, bh1) | 0;
            mid = mid + Math.imul(ah4, bl1) | 0;
            hi = hi + Math.imul(ah4, bh1) | 0;
            lo = lo + Math.imul(al3, bl2) | 0;
            mid = mid + Math.imul(al3, bh2) | 0;
            mid = mid + Math.imul(ah3, bl2) | 0;
            hi = hi + Math.imul(ah3, bh2) | 0;
            lo = lo + Math.imul(al2, bl3) | 0;
            mid = mid + Math.imul(al2, bh3) | 0;
            mid = mid + Math.imul(ah2, bl3) | 0;
            hi = hi + Math.imul(ah2, bh3) | 0;
            lo = lo + Math.imul(al1, bl4) | 0;
            mid = mid + Math.imul(al1, bh4) | 0;
            mid = mid + Math.imul(ah1, bl4) | 0;
            hi = hi + Math.imul(ah1, bh4) | 0;
            lo = lo + Math.imul(al0, bl5) | 0;
            mid = mid + Math.imul(al0, bh5) | 0;
            mid = mid + Math.imul(ah0, bl5) | 0;
            hi = hi + Math.imul(ah0, bh5) | 0;
            var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
            c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
            w5 &= 67108863;
            lo = Math.imul(al6, bl0);
            mid = Math.imul(al6, bh0);
            mid = mid + Math.imul(ah6, bl0) | 0;
            hi = Math.imul(ah6, bh0);
            lo = lo + Math.imul(al5, bl1) | 0;
            mid = mid + Math.imul(al5, bh1) | 0;
            mid = mid + Math.imul(ah5, bl1) | 0;
            hi = hi + Math.imul(ah5, bh1) | 0;
            lo = lo + Math.imul(al4, bl2) | 0;
            mid = mid + Math.imul(al4, bh2) | 0;
            mid = mid + Math.imul(ah4, bl2) | 0;
            hi = hi + Math.imul(ah4, bh2) | 0;
            lo = lo + Math.imul(al3, bl3) | 0;
            mid = mid + Math.imul(al3, bh3) | 0;
            mid = mid + Math.imul(ah3, bl3) | 0;
            hi = hi + Math.imul(ah3, bh3) | 0;
            lo = lo + Math.imul(al2, bl4) | 0;
            mid = mid + Math.imul(al2, bh4) | 0;
            mid = mid + Math.imul(ah2, bl4) | 0;
            hi = hi + Math.imul(ah2, bh4) | 0;
            lo = lo + Math.imul(al1, bl5) | 0;
            mid = mid + Math.imul(al1, bh5) | 0;
            mid = mid + Math.imul(ah1, bl5) | 0;
            hi = hi + Math.imul(ah1, bh5) | 0;
            lo = lo + Math.imul(al0, bl6) | 0;
            mid = mid + Math.imul(al0, bh6) | 0;
            mid = mid + Math.imul(ah0, bl6) | 0;
            hi = hi + Math.imul(ah0, bh6) | 0;
            var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
            c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
            w6 &= 67108863;
            lo = Math.imul(al7, bl0);
            mid = Math.imul(al7, bh0);
            mid = mid + Math.imul(ah7, bl0) | 0;
            hi = Math.imul(ah7, bh0);
            lo = lo + Math.imul(al6, bl1) | 0;
            mid = mid + Math.imul(al6, bh1) | 0;
            mid = mid + Math.imul(ah6, bl1) | 0;
            hi = hi + Math.imul(ah6, bh1) | 0;
            lo = lo + Math.imul(al5, bl2) | 0;
            mid = mid + Math.imul(al5, bh2) | 0;
            mid = mid + Math.imul(ah5, bl2) | 0;
            hi = hi + Math.imul(ah5, bh2) | 0;
            lo = lo + Math.imul(al4, bl3) | 0;
            mid = mid + Math.imul(al4, bh3) | 0;
            mid = mid + Math.imul(ah4, bl3) | 0;
            hi = hi + Math.imul(ah4, bh3) | 0;
            lo = lo + Math.imul(al3, bl4) | 0;
            mid = mid + Math.imul(al3, bh4) | 0;
            mid = mid + Math.imul(ah3, bl4) | 0;
            hi = hi + Math.imul(ah3, bh4) | 0;
            lo = lo + Math.imul(al2, bl5) | 0;
            mid = mid + Math.imul(al2, bh5) | 0;
            mid = mid + Math.imul(ah2, bl5) | 0;
            hi = hi + Math.imul(ah2, bh5) | 0;
            lo = lo + Math.imul(al1, bl6) | 0;
            mid = mid + Math.imul(al1, bh6) | 0;
            mid = mid + Math.imul(ah1, bl6) | 0;
            hi = hi + Math.imul(ah1, bh6) | 0;
            lo = lo + Math.imul(al0, bl7) | 0;
            mid = mid + Math.imul(al0, bh7) | 0;
            mid = mid + Math.imul(ah0, bl7) | 0;
            hi = hi + Math.imul(ah0, bh7) | 0;
            var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
            c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
            w7 &= 67108863;
            lo = Math.imul(al8, bl0);
            mid = Math.imul(al8, bh0);
            mid = mid + Math.imul(ah8, bl0) | 0;
            hi = Math.imul(ah8, bh0);
            lo = lo + Math.imul(al7, bl1) | 0;
            mid = mid + Math.imul(al7, bh1) | 0;
            mid = mid + Math.imul(ah7, bl1) | 0;
            hi = hi + Math.imul(ah7, bh1) | 0;
            lo = lo + Math.imul(al6, bl2) | 0;
            mid = mid + Math.imul(al6, bh2) | 0;
            mid = mid + Math.imul(ah6, bl2) | 0;
            hi = hi + Math.imul(ah6, bh2) | 0;
            lo = lo + Math.imul(al5, bl3) | 0;
            mid = mid + Math.imul(al5, bh3) | 0;
            mid = mid + Math.imul(ah5, bl3) | 0;
            hi = hi + Math.imul(ah5, bh3) | 0;
            lo = lo + Math.imul(al4, bl4) | 0;
            mid = mid + Math.imul(al4, bh4) | 0;
            mid = mid + Math.imul(ah4, bl4) | 0;
            hi = hi + Math.imul(ah4, bh4) | 0;
            lo = lo + Math.imul(al3, bl5) | 0;
            mid = mid + Math.imul(al3, bh5) | 0;
            mid = mid + Math.imul(ah3, bl5) | 0;
            hi = hi + Math.imul(ah3, bh5) | 0;
            lo = lo + Math.imul(al2, bl6) | 0;
            mid = mid + Math.imul(al2, bh6) | 0;
            mid = mid + Math.imul(ah2, bl6) | 0;
            hi = hi + Math.imul(ah2, bh6) | 0;
            lo = lo + Math.imul(al1, bl7) | 0;
            mid = mid + Math.imul(al1, bh7) | 0;
            mid = mid + Math.imul(ah1, bl7) | 0;
            hi = hi + Math.imul(ah1, bh7) | 0;
            lo = lo + Math.imul(al0, bl8) | 0;
            mid = mid + Math.imul(al0, bh8) | 0;
            mid = mid + Math.imul(ah0, bl8) | 0;
            hi = hi + Math.imul(ah0, bh8) | 0;
            var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
            c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
            w8 &= 67108863;
            lo = Math.imul(al9, bl0);
            mid = Math.imul(al9, bh0);
            mid = mid + Math.imul(ah9, bl0) | 0;
            hi = Math.imul(ah9, bh0);
            lo = lo + Math.imul(al8, bl1) | 0;
            mid = mid + Math.imul(al8, bh1) | 0;
            mid = mid + Math.imul(ah8, bl1) | 0;
            hi = hi + Math.imul(ah8, bh1) | 0;
            lo = lo + Math.imul(al7, bl2) | 0;
            mid = mid + Math.imul(al7, bh2) | 0;
            mid = mid + Math.imul(ah7, bl2) | 0;
            hi = hi + Math.imul(ah7, bh2) | 0;
            lo = lo + Math.imul(al6, bl3) | 0;
            mid = mid + Math.imul(al6, bh3) | 0;
            mid = mid + Math.imul(ah6, bl3) | 0;
            hi = hi + Math.imul(ah6, bh3) | 0;
            lo = lo + Math.imul(al5, bl4) | 0;
            mid = mid + Math.imul(al5, bh4) | 0;
            mid = mid + Math.imul(ah5, bl4) | 0;
            hi = hi + Math.imul(ah5, bh4) | 0;
            lo = lo + Math.imul(al4, bl5) | 0;
            mid = mid + Math.imul(al4, bh5) | 0;
            mid = mid + Math.imul(ah4, bl5) | 0;
            hi = hi + Math.imul(ah4, bh5) | 0;
            lo = lo + Math.imul(al3, bl6) | 0;
            mid = mid + Math.imul(al3, bh6) | 0;
            mid = mid + Math.imul(ah3, bl6) | 0;
            hi = hi + Math.imul(ah3, bh6) | 0;
            lo = lo + Math.imul(al2, bl7) | 0;
            mid = mid + Math.imul(al2, bh7) | 0;
            mid = mid + Math.imul(ah2, bl7) | 0;
            hi = hi + Math.imul(ah2, bh7) | 0;
            lo = lo + Math.imul(al1, bl8) | 0;
            mid = mid + Math.imul(al1, bh8) | 0;
            mid = mid + Math.imul(ah1, bl8) | 0;
            hi = hi + Math.imul(ah1, bh8) | 0;
            lo = lo + Math.imul(al0, bl9) | 0;
            mid = mid + Math.imul(al0, bh9) | 0;
            mid = mid + Math.imul(ah0, bl9) | 0;
            hi = hi + Math.imul(ah0, bh9) | 0;
            var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
            c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
            w9 &= 67108863;
            lo = Math.imul(al9, bl1);
            mid = Math.imul(al9, bh1);
            mid = mid + Math.imul(ah9, bl1) | 0;
            hi = Math.imul(ah9, bh1);
            lo = lo + Math.imul(al8, bl2) | 0;
            mid = mid + Math.imul(al8, bh2) | 0;
            mid = mid + Math.imul(ah8, bl2) | 0;
            hi = hi + Math.imul(ah8, bh2) | 0;
            lo = lo + Math.imul(al7, bl3) | 0;
            mid = mid + Math.imul(al7, bh3) | 0;
            mid = mid + Math.imul(ah7, bl3) | 0;
            hi = hi + Math.imul(ah7, bh3) | 0;
            lo = lo + Math.imul(al6, bl4) | 0;
            mid = mid + Math.imul(al6, bh4) | 0;
            mid = mid + Math.imul(ah6, bl4) | 0;
            hi = hi + Math.imul(ah6, bh4) | 0;
            lo = lo + Math.imul(al5, bl5) | 0;
            mid = mid + Math.imul(al5, bh5) | 0;
            mid = mid + Math.imul(ah5, bl5) | 0;
            hi = hi + Math.imul(ah5, bh5) | 0;
            lo = lo + Math.imul(al4, bl6) | 0;
            mid = mid + Math.imul(al4, bh6) | 0;
            mid = mid + Math.imul(ah4, bl6) | 0;
            hi = hi + Math.imul(ah4, bh6) | 0;
            lo = lo + Math.imul(al3, bl7) | 0;
            mid = mid + Math.imul(al3, bh7) | 0;
            mid = mid + Math.imul(ah3, bl7) | 0;
            hi = hi + Math.imul(ah3, bh7) | 0;
            lo = lo + Math.imul(al2, bl8) | 0;
            mid = mid + Math.imul(al2, bh8) | 0;
            mid = mid + Math.imul(ah2, bl8) | 0;
            hi = hi + Math.imul(ah2, bh8) | 0;
            lo = lo + Math.imul(al1, bl9) | 0;
            mid = mid + Math.imul(al1, bh9) | 0;
            mid = mid + Math.imul(ah1, bl9) | 0;
            hi = hi + Math.imul(ah1, bh9) | 0;
            var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
            c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
            w10 &= 67108863;
            lo = Math.imul(al9, bl2);
            mid = Math.imul(al9, bh2);
            mid = mid + Math.imul(ah9, bl2) | 0;
            hi = Math.imul(ah9, bh2);
            lo = lo + Math.imul(al8, bl3) | 0;
            mid = mid + Math.imul(al8, bh3) | 0;
            mid = mid + Math.imul(ah8, bl3) | 0;
            hi = hi + Math.imul(ah8, bh3) | 0;
            lo = lo + Math.imul(al7, bl4) | 0;
            mid = mid + Math.imul(al7, bh4) | 0;
            mid = mid + Math.imul(ah7, bl4) | 0;
            hi = hi + Math.imul(ah7, bh4) | 0;
            lo = lo + Math.imul(al6, bl5) | 0;
            mid = mid + Math.imul(al6, bh5) | 0;
            mid = mid + Math.imul(ah6, bl5) | 0;
            hi = hi + Math.imul(ah6, bh5) | 0;
            lo = lo + Math.imul(al5, bl6) | 0;
            mid = mid + Math.imul(al5, bh6) | 0;
            mid = mid + Math.imul(ah5, bl6) | 0;
            hi = hi + Math.imul(ah5, bh6) | 0;
            lo = lo + Math.imul(al4, bl7) | 0;
            mid = mid + Math.imul(al4, bh7) | 0;
            mid = mid + Math.imul(ah4, bl7) | 0;
            hi = hi + Math.imul(ah4, bh7) | 0;
            lo = lo + Math.imul(al3, bl8) | 0;
            mid = mid + Math.imul(al3, bh8) | 0;
            mid = mid + Math.imul(ah3, bl8) | 0;
            hi = hi + Math.imul(ah3, bh8) | 0;
            lo = lo + Math.imul(al2, bl9) | 0;
            mid = mid + Math.imul(al2, bh9) | 0;
            mid = mid + Math.imul(ah2, bl9) | 0;
            hi = hi + Math.imul(ah2, bh9) | 0;
            var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
            c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
            w11 &= 67108863;
            lo = Math.imul(al9, bl3);
            mid = Math.imul(al9, bh3);
            mid = mid + Math.imul(ah9, bl3) | 0;
            hi = Math.imul(ah9, bh3);
            lo = lo + Math.imul(al8, bl4) | 0;
            mid = mid + Math.imul(al8, bh4) | 0;
            mid = mid + Math.imul(ah8, bl4) | 0;
            hi = hi + Math.imul(ah8, bh4) | 0;
            lo = lo + Math.imul(al7, bl5) | 0;
            mid = mid + Math.imul(al7, bh5) | 0;
            mid = mid + Math.imul(ah7, bl5) | 0;
            hi = hi + Math.imul(ah7, bh5) | 0;
            lo = lo + Math.imul(al6, bl6) | 0;
            mid = mid + Math.imul(al6, bh6) | 0;
            mid = mid + Math.imul(ah6, bl6) | 0;
            hi = hi + Math.imul(ah6, bh6) | 0;
            lo = lo + Math.imul(al5, bl7) | 0;
            mid = mid + Math.imul(al5, bh7) | 0;
            mid = mid + Math.imul(ah5, bl7) | 0;
            hi = hi + Math.imul(ah5, bh7) | 0;
            lo = lo + Math.imul(al4, bl8) | 0;
            mid = mid + Math.imul(al4, bh8) | 0;
            mid = mid + Math.imul(ah4, bl8) | 0;
            hi = hi + Math.imul(ah4, bh8) | 0;
            lo = lo + Math.imul(al3, bl9) | 0;
            mid = mid + Math.imul(al3, bh9) | 0;
            mid = mid + Math.imul(ah3, bl9) | 0;
            hi = hi + Math.imul(ah3, bh9) | 0;
            var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
            c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
            w12 &= 67108863;
            lo = Math.imul(al9, bl4);
            mid = Math.imul(al9, bh4);
            mid = mid + Math.imul(ah9, bl4) | 0;
            hi = Math.imul(ah9, bh4);
            lo = lo + Math.imul(al8, bl5) | 0;
            mid = mid + Math.imul(al8, bh5) | 0;
            mid = mid + Math.imul(ah8, bl5) | 0;
            hi = hi + Math.imul(ah8, bh5) | 0;
            lo = lo + Math.imul(al7, bl6) | 0;
            mid = mid + Math.imul(al7, bh6) | 0;
            mid = mid + Math.imul(ah7, bl6) | 0;
            hi = hi + Math.imul(ah7, bh6) | 0;
            lo = lo + Math.imul(al6, bl7) | 0;
            mid = mid + Math.imul(al6, bh7) | 0;
            mid = mid + Math.imul(ah6, bl7) | 0;
            hi = hi + Math.imul(ah6, bh7) | 0;
            lo = lo + Math.imul(al5, bl8) | 0;
            mid = mid + Math.imul(al5, bh8) | 0;
            mid = mid + Math.imul(ah5, bl8) | 0;
            hi = hi + Math.imul(ah5, bh8) | 0;
            lo = lo + Math.imul(al4, bl9) | 0;
            mid = mid + Math.imul(al4, bh9) | 0;
            mid = mid + Math.imul(ah4, bl9) | 0;
            hi = hi + Math.imul(ah4, bh9) | 0;
            var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
            c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
            w13 &= 67108863;
            lo = Math.imul(al9, bl5);
            mid = Math.imul(al9, bh5);
            mid = mid + Math.imul(ah9, bl5) | 0;
            hi = Math.imul(ah9, bh5);
            lo = lo + Math.imul(al8, bl6) | 0;
            mid = mid + Math.imul(al8, bh6) | 0;
            mid = mid + Math.imul(ah8, bl6) | 0;
            hi = hi + Math.imul(ah8, bh6) | 0;
            lo = lo + Math.imul(al7, bl7) | 0;
            mid = mid + Math.imul(al7, bh7) | 0;
            mid = mid + Math.imul(ah7, bl7) | 0;
            hi = hi + Math.imul(ah7, bh7) | 0;
            lo = lo + Math.imul(al6, bl8) | 0;
            mid = mid + Math.imul(al6, bh8) | 0;
            mid = mid + Math.imul(ah6, bl8) | 0;
            hi = hi + Math.imul(ah6, bh8) | 0;
            lo = lo + Math.imul(al5, bl9) | 0;
            mid = mid + Math.imul(al5, bh9) | 0;
            mid = mid + Math.imul(ah5, bl9) | 0;
            hi = hi + Math.imul(ah5, bh9) | 0;
            var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
            c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
            w14 &= 67108863;
            lo = Math.imul(al9, bl6);
            mid = Math.imul(al9, bh6);
            mid = mid + Math.imul(ah9, bl6) | 0;
            hi = Math.imul(ah9, bh6);
            lo = lo + Math.imul(al8, bl7) | 0;
            mid = mid + Math.imul(al8, bh7) | 0;
            mid = mid + Math.imul(ah8, bl7) | 0;
            hi = hi + Math.imul(ah8, bh7) | 0;
            lo = lo + Math.imul(al7, bl8) | 0;
            mid = mid + Math.imul(al7, bh8) | 0;
            mid = mid + Math.imul(ah7, bl8) | 0;
            hi = hi + Math.imul(ah7, bh8) | 0;
            lo = lo + Math.imul(al6, bl9) | 0;
            mid = mid + Math.imul(al6, bh9) | 0;
            mid = mid + Math.imul(ah6, bl9) | 0;
            hi = hi + Math.imul(ah6, bh9) | 0;
            var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
            c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
            w15 &= 67108863;
            lo = Math.imul(al9, bl7);
            mid = Math.imul(al9, bh7);
            mid = mid + Math.imul(ah9, bl7) | 0;
            hi = Math.imul(ah9, bh7);
            lo = lo + Math.imul(al8, bl8) | 0;
            mid = mid + Math.imul(al8, bh8) | 0;
            mid = mid + Math.imul(ah8, bl8) | 0;
            hi = hi + Math.imul(ah8, bh8) | 0;
            lo = lo + Math.imul(al7, bl9) | 0;
            mid = mid + Math.imul(al7, bh9) | 0;
            mid = mid + Math.imul(ah7, bl9) | 0;
            hi = hi + Math.imul(ah7, bh9) | 0;
            var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
            c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
            w16 &= 67108863;
            lo = Math.imul(al9, bl8);
            mid = Math.imul(al9, bh8);
            mid = mid + Math.imul(ah9, bl8) | 0;
            hi = Math.imul(ah9, bh8);
            lo = lo + Math.imul(al8, bl9) | 0;
            mid = mid + Math.imul(al8, bh9) | 0;
            mid = mid + Math.imul(ah8, bl9) | 0;
            hi = hi + Math.imul(ah8, bh9) | 0;
            var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
            c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
            w17 &= 67108863;
            lo = Math.imul(al9, bl9);
            mid = Math.imul(al9, bh9);
            mid = mid + Math.imul(ah9, bl9) | 0;
            hi = Math.imul(ah9, bh9);
            var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
            c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
            w18 &= 67108863;
            o[0] = w0;
            o[1] = w1;
            o[2] = w2;
            o[3] = w3;
            o[4] = w4;
            o[5] = w5;
            o[6] = w6;
            o[7] = w7;
            o[8] = w8;
            o[9] = w9;
            o[10] = w10;
            o[11] = w11;
            o[12] = w12;
            o[13] = w13;
            o[14] = w14;
            o[15] = w15;
            o[16] = w16;
            o[17] = w17;
            o[18] = w18;
            if (c !== 0) {
              o[19] = c;
              out.length++;
            }
            return out;
          };
          if (!Math.imul) {
            comb10MulTo = smallMulTo;
          }
          function bigMulTo(self2, num, out) {
            out.negative = num.negative ^ self2.negative;
            out.length = self2.length + num.length;
            var carry = 0;
            var hncarry = 0;
            for (var k = 0; k < out.length - 1; k++) {
              var ncarry = hncarry;
              hncarry = 0;
              var rword = carry & 67108863;
              var maxJ = Math.min(k, num.length - 1);
              for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
                var i = k - j;
                var a = self2.words[i] | 0;
                var b = num.words[j] | 0;
                var r = a * b;
                var lo = r & 67108863;
                ncarry = ncarry + (r / 67108864 | 0) | 0;
                lo = lo + rword | 0;
                rword = lo & 67108863;
                ncarry = ncarry + (lo >>> 26) | 0;
                hncarry += ncarry >>> 26;
                ncarry &= 67108863;
              }
              out.words[k] = rword;
              carry = ncarry;
              ncarry = hncarry;
            }
            if (carry !== 0) {
              out.words[k] = carry;
            } else {
              out.length--;
            }
            return out._strip();
          }
          function jumboMulTo(self2, num, out) {
            return bigMulTo(self2, num, out);
          }
          BN.prototype.mulTo = function mulTo(num, out) {
            var res;
            var len = this.length + num.length;
            if (this.length === 10 && num.length === 10) {
              res = comb10MulTo(this, num, out);
            } else if (len < 63) {
              res = smallMulTo(this, num, out);
            } else if (len < 1024) {
              res = bigMulTo(this, num, out);
            } else {
              res = jumboMulTo(this, num, out);
            }
            return res;
          };
          BN.prototype.mul = function mul(num) {
            var out = new BN(null);
            out.words = new Array(this.length + num.length);
            return this.mulTo(num, out);
          };
          BN.prototype.mulf = function mulf(num) {
            var out = new BN(null);
            out.words = new Array(this.length + num.length);
            return jumboMulTo(this, num, out);
          };
          BN.prototype.imul = function imul(num) {
            return this.clone().mulTo(num, this);
          };
          BN.prototype.imuln = function imuln(num) {
            var isNegNum = num < 0;
            if (isNegNum)
              num = -num;
            assert2(typeof num === "number");
            assert2(num < 67108864);
            var carry = 0;
            for (var i = 0; i < this.length; i++) {
              var w = (this.words[i] | 0) * num;
              var lo = (w & 67108863) + (carry & 67108863);
              carry >>= 26;
              carry += w / 67108864 | 0;
              carry += lo >>> 26;
              this.words[i] = lo & 67108863;
            }
            if (carry !== 0) {
              this.words[i] = carry;
              this.length++;
            }
            return isNegNum ? this.ineg() : this;
          };
          BN.prototype.muln = function muln(num) {
            return this.clone().imuln(num);
          };
          BN.prototype.sqr = function sqr() {
            return this.mul(this);
          };
          BN.prototype.isqr = function isqr() {
            return this.imul(this.clone());
          };
          BN.prototype.pow = function pow(num) {
            var w = toBitArray(num);
            if (w.length === 0)
              return new BN(1);
            var res = this;
            for (var i = 0; i < w.length; i++, res = res.sqr()) {
              if (w[i] !== 0)
                break;
            }
            if (++i < w.length) {
              for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
                if (w[i] === 0)
                  continue;
                res = res.mul(q);
              }
            }
            return res;
          };
          BN.prototype.iushln = function iushln(bits) {
            assert2(typeof bits === "number" && bits >= 0);
            var r = bits % 26;
            var s = (bits - r) / 26;
            var carryMask = 67108863 >>> 26 - r << 26 - r;
            var i;
            if (r !== 0) {
              var carry = 0;
              for (i = 0; i < this.length; i++) {
                var newCarry = this.words[i] & carryMask;
                var c = (this.words[i] | 0) - newCarry << r;
                this.words[i] = c | carry;
                carry = newCarry >>> 26 - r;
              }
              if (carry) {
                this.words[i] = carry;
                this.length++;
              }
            }
            if (s !== 0) {
              for (i = this.length - 1; i >= 0; i--) {
                this.words[i + s] = this.words[i];
              }
              for (i = 0; i < s; i++) {
                this.words[i] = 0;
              }
              this.length += s;
            }
            return this._strip();
          };
          BN.prototype.ishln = function ishln(bits) {
            assert2(this.negative === 0);
            return this.iushln(bits);
          };
          BN.prototype.iushrn = function iushrn(bits, hint, extended) {
            assert2(typeof bits === "number" && bits >= 0);
            var h;
            if (hint) {
              h = (hint - hint % 26) / 26;
            } else {
              h = 0;
            }
            var r = bits % 26;
            var s = Math.min((bits - r) / 26, this.length);
            var mask2 = 67108863 ^ 67108863 >>> r << r;
            var maskedWords = extended;
            h -= s;
            h = Math.max(0, h);
            if (maskedWords) {
              for (var i = 0; i < s; i++) {
                maskedWords.words[i] = this.words[i];
              }
              maskedWords.length = s;
            }
            if (s === 0)
              ;
            else if (this.length > s) {
              this.length -= s;
              for (i = 0; i < this.length; i++) {
                this.words[i] = this.words[i + s];
              }
            } else {
              this.words[0] = 0;
              this.length = 1;
            }
            var carry = 0;
            for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
              var word = this.words[i] | 0;
              this.words[i] = carry << 26 - r | word >>> r;
              carry = word & mask2;
            }
            if (maskedWords && carry !== 0) {
              maskedWords.words[maskedWords.length++] = carry;
            }
            if (this.length === 0) {
              this.words[0] = 0;
              this.length = 1;
            }
            return this._strip();
          };
          BN.prototype.ishrn = function ishrn(bits, hint, extended) {
            assert2(this.negative === 0);
            return this.iushrn(bits, hint, extended);
          };
          BN.prototype.shln = function shln(bits) {
            return this.clone().ishln(bits);
          };
          BN.prototype.ushln = function ushln(bits) {
            return this.clone().iushln(bits);
          };
          BN.prototype.shrn = function shrn(bits) {
            return this.clone().ishrn(bits);
          };
          BN.prototype.ushrn = function ushrn(bits) {
            return this.clone().iushrn(bits);
          };
          BN.prototype.testn = function testn(bit) {
            assert2(typeof bit === "number" && bit >= 0);
            var r = bit % 26;
            var s = (bit - r) / 26;
            var q = 1 << r;
            if (this.length <= s)
              return false;
            var w = this.words[s];
            return !!(w & q);
          };
          BN.prototype.imaskn = function imaskn(bits) {
            assert2(typeof bits === "number" && bits >= 0);
            var r = bits % 26;
            var s = (bits - r) / 26;
            assert2(this.negative === 0, "imaskn works only with positive numbers");
            if (this.length <= s) {
              return this;
            }
            if (r !== 0) {
              s++;
            }
            this.length = Math.min(s, this.length);
            if (r !== 0) {
              var mask2 = 67108863 ^ 67108863 >>> r << r;
              this.words[this.length - 1] &= mask2;
            }
            return this._strip();
          };
          BN.prototype.maskn = function maskn(bits) {
            return this.clone().imaskn(bits);
          };
          BN.prototype.iaddn = function iaddn(num) {
            assert2(typeof num === "number");
            assert2(num < 67108864);
            if (num < 0)
              return this.isubn(-num);
            if (this.negative !== 0) {
              if (this.length === 1 && (this.words[0] | 0) <= num) {
                this.words[0] = num - (this.words[0] | 0);
                this.negative = 0;
                return this;
              }
              this.negative = 0;
              this.isubn(num);
              this.negative = 1;
              return this;
            }
            return this._iaddn(num);
          };
          BN.prototype._iaddn = function _iaddn(num) {
            this.words[0] += num;
            for (var i = 0; i < this.length && this.words[i] >= 67108864; i++) {
              this.words[i] -= 67108864;
              if (i === this.length - 1) {
                this.words[i + 1] = 1;
              } else {
                this.words[i + 1]++;
              }
            }
            this.length = Math.max(this.length, i + 1);
            return this;
          };
          BN.prototype.isubn = function isubn(num) {
            assert2(typeof num === "number");
            assert2(num < 67108864);
            if (num < 0)
              return this.iaddn(-num);
            if (this.negative !== 0) {
              this.negative = 0;
              this.iaddn(num);
              this.negative = 1;
              return this;
            }
            this.words[0] -= num;
            if (this.length === 1 && this.words[0] < 0) {
              this.words[0] = -this.words[0];
              this.negative = 1;
            } else {
              for (var i = 0; i < this.length && this.words[i] < 0; i++) {
                this.words[i] += 67108864;
                this.words[i + 1] -= 1;
              }
            }
            return this._strip();
          };
          BN.prototype.addn = function addn(num) {
            return this.clone().iaddn(num);
          };
          BN.prototype.subn = function subn(num) {
            return this.clone().isubn(num);
          };
          BN.prototype.iabs = function iabs() {
            this.negative = 0;
            return this;
          };
          BN.prototype.abs = function abs() {
            return this.clone().iabs();
          };
          BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
            var len = num.length + shift;
            var i;
            this._expand(len);
            var w;
            var carry = 0;
            for (i = 0; i < num.length; i++) {
              w = (this.words[i + shift] | 0) + carry;
              var right = (num.words[i] | 0) * mul;
              w -= right & 67108863;
              carry = (w >> 26) - (right / 67108864 | 0);
              this.words[i + shift] = w & 67108863;
            }
            for (; i < this.length - shift; i++) {
              w = (this.words[i + shift] | 0) + carry;
              carry = w >> 26;
              this.words[i + shift] = w & 67108863;
            }
            if (carry === 0)
              return this._strip();
            assert2(carry === -1);
            carry = 0;
            for (i = 0; i < this.length; i++) {
              w = -(this.words[i] | 0) + carry;
              carry = w >> 26;
              this.words[i] = w & 67108863;
            }
            this.negative = 1;
            return this._strip();
          };
          BN.prototype._wordDiv = function _wordDiv(num, mode) {
            var shift = this.length - num.length;
            var a = this.clone();
            var b = num;
            var bhi = b.words[b.length - 1] | 0;
            var bhiBits = this._countBits(bhi);
            shift = 26 - bhiBits;
            if (shift !== 0) {
              b = b.ushln(shift);
              a.iushln(shift);
              bhi = b.words[b.length - 1] | 0;
            }
            var m = a.length - b.length;
            var q;
            if (mode !== "mod") {
              q = new BN(null);
              q.length = m + 1;
              q.words = new Array(q.length);
              for (var i = 0; i < q.length; i++) {
                q.words[i] = 0;
              }
            }
            var diff = a.clone()._ishlnsubmul(b, 1, m);
            if (diff.negative === 0) {
              a = diff;
              if (q) {
                q.words[m] = 1;
              }
            }
            for (var j = m - 1; j >= 0; j--) {
              var qj = (a.words[b.length + j] | 0) * 67108864 + (a.words[b.length + j - 1] | 0);
              qj = Math.min(qj / bhi | 0, 67108863);
              a._ishlnsubmul(b, qj, j);
              while (a.negative !== 0) {
                qj--;
                a.negative = 0;
                a._ishlnsubmul(b, 1, j);
                if (!a.isZero()) {
                  a.negative ^= 1;
                }
              }
              if (q) {
                q.words[j] = qj;
              }
            }
            if (q) {
              q._strip();
            }
            a._strip();
            if (mode !== "div" && shift !== 0) {
              a.iushrn(shift);
            }
            return {
              div: q || null,
              mod: a
            };
          };
          BN.prototype.divmod = function divmod(num, mode, positive) {
            assert2(!num.isZero());
            if (this.isZero()) {
              return {
                div: new BN(0),
                mod: new BN(0)
              };
            }
            var div, mod, res;
            if (this.negative !== 0 && num.negative === 0) {
              res = this.neg().divmod(num, mode);
              if (mode !== "mod") {
                div = res.div.neg();
              }
              if (mode !== "div") {
                mod = res.mod.neg();
                if (positive && mod.negative !== 0) {
                  mod.iadd(num);
                }
              }
              return {
                div,
                mod
              };
            }
            if (this.negative === 0 && num.negative !== 0) {
              res = this.divmod(num.neg(), mode);
              if (mode !== "mod") {
                div = res.div.neg();
              }
              return {
                div,
                mod: res.mod
              };
            }
            if ((this.negative & num.negative) !== 0) {
              res = this.neg().divmod(num.neg(), mode);
              if (mode !== "div") {
                mod = res.mod.neg();
                if (positive && mod.negative !== 0) {
                  mod.isub(num);
                }
              }
              return {
                div: res.div,
                mod
              };
            }
            if (num.length > this.length || this.cmp(num) < 0) {
              return {
                div: new BN(0),
                mod: this
              };
            }
            if (num.length === 1) {
              if (mode === "div") {
                return {
                  div: this.divn(num.words[0]),
                  mod: null
                };
              }
              if (mode === "mod") {
                return {
                  div: null,
                  mod: new BN(this.modrn(num.words[0]))
                };
              }
              return {
                div: this.divn(num.words[0]),
                mod: new BN(this.modrn(num.words[0]))
              };
            }
            return this._wordDiv(num, mode);
          };
          BN.prototype.div = function div(num) {
            return this.divmod(num, "div", false).div;
          };
          BN.prototype.mod = function mod(num) {
            return this.divmod(num, "mod", false).mod;
          };
          BN.prototype.umod = function umod(num) {
            return this.divmod(num, "mod", true).mod;
          };
          BN.prototype.divRound = function divRound(num) {
            var dm = this.divmod(num);
            if (dm.mod.isZero())
              return dm.div;
            var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
            var half = num.ushrn(1);
            var r2 = num.andln(1);
            var cmp = mod.cmp(half);
            if (cmp < 0 || r2 === 1 && cmp === 0)
              return dm.div;
            return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
          };
          BN.prototype.modrn = function modrn(num) {
            var isNegNum = num < 0;
            if (isNegNum)
              num = -num;
            assert2(num <= 67108863);
            var p = (1 << 26) % num;
            var acc = 0;
            for (var i = this.length - 1; i >= 0; i--) {
              acc = (p * acc + (this.words[i] | 0)) % num;
            }
            return isNegNum ? -acc : acc;
          };
          BN.prototype.modn = function modn(num) {
            return this.modrn(num);
          };
          BN.prototype.idivn = function idivn(num) {
            var isNegNum = num < 0;
            if (isNegNum)
              num = -num;
            assert2(num <= 67108863);
            var carry = 0;
            for (var i = this.length - 1; i >= 0; i--) {
              var w = (this.words[i] | 0) + carry * 67108864;
              this.words[i] = w / num | 0;
              carry = w % num;
            }
            this._strip();
            return isNegNum ? this.ineg() : this;
          };
          BN.prototype.divn = function divn(num) {
            return this.clone().idivn(num);
          };
          BN.prototype.egcd = function egcd(p) {
            assert2(p.negative === 0);
            assert2(!p.isZero());
            var x = this;
            var y = p.clone();
            if (x.negative !== 0) {
              x = x.umod(p);
            } else {
              x = x.clone();
            }
            var A = new BN(1);
            var B = new BN(0);
            var C = new BN(0);
            var D = new BN(1);
            var g = 0;
            while (x.isEven() && y.isEven()) {
              x.iushrn(1);
              y.iushrn(1);
              ++g;
            }
            var yp = y.clone();
            var xp = x.clone();
            while (!x.isZero()) {
              for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
                ;
              if (i > 0) {
                x.iushrn(i);
                while (i-- > 0) {
                  if (A.isOdd() || B.isOdd()) {
                    A.iadd(yp);
                    B.isub(xp);
                  }
                  A.iushrn(1);
                  B.iushrn(1);
                }
              }
              for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
                ;
              if (j > 0) {
                y.iushrn(j);
                while (j-- > 0) {
                  if (C.isOdd() || D.isOdd()) {
                    C.iadd(yp);
                    D.isub(xp);
                  }
                  C.iushrn(1);
                  D.iushrn(1);
                }
              }
              if (x.cmp(y) >= 0) {
                x.isub(y);
                A.isub(C);
                B.isub(D);
              } else {
                y.isub(x);
                C.isub(A);
                D.isub(B);
              }
            }
            return {
              a: C,
              b: D,
              gcd: y.iushln(g)
            };
          };
          BN.prototype._invmp = function _invmp(p) {
            assert2(p.negative === 0);
            assert2(!p.isZero());
            var a = this;
            var b = p.clone();
            if (a.negative !== 0) {
              a = a.umod(p);
            } else {
              a = a.clone();
            }
            var x1 = new BN(1);
            var x2 = new BN(0);
            var delta = b.clone();
            while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
              for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
                ;
              if (i > 0) {
                a.iushrn(i);
                while (i-- > 0) {
                  if (x1.isOdd()) {
                    x1.iadd(delta);
                  }
                  x1.iushrn(1);
                }
              }
              for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
                ;
              if (j > 0) {
                b.iushrn(j);
                while (j-- > 0) {
                  if (x2.isOdd()) {
                    x2.iadd(delta);
                  }
                  x2.iushrn(1);
                }
              }
              if (a.cmp(b) >= 0) {
                a.isub(b);
                x1.isub(x2);
              } else {
                b.isub(a);
                x2.isub(x1);
              }
            }
            var res;
            if (a.cmpn(1) === 0) {
              res = x1;
            } else {
              res = x2;
            }
            if (res.cmpn(0) < 0) {
              res.iadd(p);
            }
            return res;
          };
          BN.prototype.gcd = function gcd(num) {
            if (this.isZero())
              return num.abs();
            if (num.isZero())
              return this.abs();
            var a = this.clone();
            var b = num.clone();
            a.negative = 0;
            b.negative = 0;
            for (var shift = 0; a.isEven() && b.isEven(); shift++) {
              a.iushrn(1);
              b.iushrn(1);
            }
            do {
              while (a.isEven()) {
                a.iushrn(1);
              }
              while (b.isEven()) {
                b.iushrn(1);
              }
              var r = a.cmp(b);
              if (r < 0) {
                var t = a;
                a = b;
                b = t;
              } else if (r === 0 || b.cmpn(1) === 0) {
                break;
              }
              a.isub(b);
            } while (true);
            return b.iushln(shift);
          };
          BN.prototype.invm = function invm(num) {
            return this.egcd(num).a.umod(num);
          };
          BN.prototype.isEven = function isEven() {
            return (this.words[0] & 1) === 0;
          };
          BN.prototype.isOdd = function isOdd() {
            return (this.words[0] & 1) === 1;
          };
          BN.prototype.andln = function andln(num) {
            return this.words[0] & num;
          };
          BN.prototype.bincn = function bincn(bit) {
            assert2(typeof bit === "number");
            var r = bit % 26;
            var s = (bit - r) / 26;
            var q = 1 << r;
            if (this.length <= s) {
              this._expand(s + 1);
              this.words[s] |= q;
              return this;
            }
            var carry = q;
            for (var i = s; carry !== 0 && i < this.length; i++) {
              var w = this.words[i] | 0;
              w += carry;
              carry = w >>> 26;
              w &= 67108863;
              this.words[i] = w;
            }
            if (carry !== 0) {
              this.words[i] = carry;
              this.length++;
            }
            return this;
          };
          BN.prototype.isZero = function isZero() {
            return this.length === 1 && this.words[0] === 0;
          };
          BN.prototype.cmpn = function cmpn(num) {
            var negative = num < 0;
            if (this.negative !== 0 && !negative)
              return -1;
            if (this.negative === 0 && negative)
              return 1;
            this._strip();
            var res;
            if (this.length > 1) {
              res = 1;
            } else {
              if (negative) {
                num = -num;
              }
              assert2(num <= 67108863, "Number is too big");
              var w = this.words[0] | 0;
              res = w === num ? 0 : w < num ? -1 : 1;
            }
            if (this.negative !== 0)
              return -res | 0;
            return res;
          };
          BN.prototype.cmp = function cmp(num) {
            if (this.negative !== 0 && num.negative === 0)
              return -1;
            if (this.negative === 0 && num.negative !== 0)
              return 1;
            var res = this.ucmp(num);
            if (this.negative !== 0)
              return -res | 0;
            return res;
          };
          BN.prototype.ucmp = function ucmp(num) {
            if (this.length > num.length)
              return 1;
            if (this.length < num.length)
              return -1;
            var res = 0;
            for (var i = this.length - 1; i >= 0; i--) {
              var a = this.words[i] | 0;
              var b = num.words[i] | 0;
              if (a === b)
                continue;
              if (a < b) {
                res = -1;
              } else if (a > b) {
                res = 1;
              }
              break;
            }
            return res;
          };
          BN.prototype.gtn = function gtn(num) {
            return this.cmpn(num) === 1;
          };
          BN.prototype.gt = function gt(num) {
            return this.cmp(num) === 1;
          };
          BN.prototype.gten = function gten(num) {
            return this.cmpn(num) >= 0;
          };
          BN.prototype.gte = function gte(num) {
            return this.cmp(num) >= 0;
          };
          BN.prototype.ltn = function ltn(num) {
            return this.cmpn(num) === -1;
          };
          BN.prototype.lt = function lt(num) {
            return this.cmp(num) === -1;
          };
          BN.prototype.lten = function lten(num) {
            return this.cmpn(num) <= 0;
          };
          BN.prototype.lte = function lte(num) {
            return this.cmp(num) <= 0;
          };
          BN.prototype.eqn = function eqn(num) {
            return this.cmpn(num) === 0;
          };
          BN.prototype.eq = function eq(num) {
            return this.cmp(num) === 0;
          };
          BN.red = function red(num) {
            return new Red(num);
          };
          BN.prototype.toRed = function toRed(ctx) {
            assert2(!this.red, "Already a number in reduction context");
            assert2(this.negative === 0, "red works only with positives");
            return ctx.convertTo(this)._forceRed(ctx);
          };
          BN.prototype.fromRed = function fromRed() {
            assert2(this.red, "fromRed works only with numbers in reduction context");
            return this.red.convertFrom(this);
          };
          BN.prototype._forceRed = function _forceRed(ctx) {
            this.red = ctx;
            return this;
          };
          BN.prototype.forceRed = function forceRed(ctx) {
            assert2(!this.red, "Already a number in reduction context");
            return this._forceRed(ctx);
          };
          BN.prototype.redAdd = function redAdd(num) {
            assert2(this.red, "redAdd works only with red numbers");
            return this.red.add(this, num);
          };
          BN.prototype.redIAdd = function redIAdd(num) {
            assert2(this.red, "redIAdd works only with red numbers");
            return this.red.iadd(this, num);
          };
          BN.prototype.redSub = function redSub(num) {
            assert2(this.red, "redSub works only with red numbers");
            return this.red.sub(this, num);
          };
          BN.prototype.redISub = function redISub(num) {
            assert2(this.red, "redISub works only with red numbers");
            return this.red.isub(this, num);
          };
          BN.prototype.redShl = function redShl(num) {
            assert2(this.red, "redShl works only with red numbers");
            return this.red.shl(this, num);
          };
          BN.prototype.redMul = function redMul(num) {
            assert2(this.red, "redMul works only with red numbers");
            this.red._verify2(this, num);
            return this.red.mul(this, num);
          };
          BN.prototype.redIMul = function redIMul(num) {
            assert2(this.red, "redMul works only with red numbers");
            this.red._verify2(this, num);
            return this.red.imul(this, num);
          };
          BN.prototype.redSqr = function redSqr() {
            assert2(this.red, "redSqr works only with red numbers");
            this.red._verify1(this);
            return this.red.sqr(this);
          };
          BN.prototype.redISqr = function redISqr() {
            assert2(this.red, "redISqr works only with red numbers");
            this.red._verify1(this);
            return this.red.isqr(this);
          };
          BN.prototype.redSqrt = function redSqrt() {
            assert2(this.red, "redSqrt works only with red numbers");
            this.red._verify1(this);
            return this.red.sqrt(this);
          };
          BN.prototype.redInvm = function redInvm() {
            assert2(this.red, "redInvm works only with red numbers");
            this.red._verify1(this);
            return this.red.invm(this);
          };
          BN.prototype.redNeg = function redNeg() {
            assert2(this.red, "redNeg works only with red numbers");
            this.red._verify1(this);
            return this.red.neg(this);
          };
          BN.prototype.redPow = function redPow(num) {
            assert2(this.red && !num.red, "redPow(normalNum)");
            this.red._verify1(this);
            return this.red.pow(this, num);
          };
          var primes = {
            k256: null,
            p224: null,
            p192: null,
            p25519: null
          };
          function MPrime(name2, p) {
            this.name = name2;
            this.p = new BN(p, 16);
            this.n = this.p.bitLength();
            this.k = new BN(1).iushln(this.n).isub(this.p);
            this.tmp = this._tmp();
          }
          MPrime.prototype._tmp = function _tmp() {
            var tmp = new BN(null);
            tmp.words = new Array(Math.ceil(this.n / 13));
            return tmp;
          };
          MPrime.prototype.ireduce = function ireduce(num) {
            var r = num;
            var rlen;
            do {
              this.split(r, this.tmp);
              r = this.imulK(r);
              r = r.iadd(this.tmp);
              rlen = r.bitLength();
            } while (rlen > this.n);
            var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
            if (cmp === 0) {
              r.words[0] = 0;
              r.length = 1;
            } else if (cmp > 0) {
              r.isub(this.p);
            } else {
              if (r.strip !== void 0) {
                r.strip();
              } else {
                r._strip();
              }
            }
            return r;
          };
          MPrime.prototype.split = function split(input, out) {
            input.iushrn(this.n, 0, out);
          };
          MPrime.prototype.imulK = function imulK(num) {
            return num.imul(this.k);
          };
          function K256() {
            MPrime.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
          }
          inherits2(K256, MPrime);
          K256.prototype.split = function split(input, output) {
            var mask2 = 4194303;
            var outLen = Math.min(input.length, 9);
            for (var i = 0; i < outLen; i++) {
              output.words[i] = input.words[i];
            }
            output.length = outLen;
            if (input.length <= 9) {
              input.words[0] = 0;
              input.length = 1;
              return;
            }
            var prev = input.words[9];
            output.words[output.length++] = prev & mask2;
            for (i = 10; i < input.length; i++) {
              var next = input.words[i] | 0;
              input.words[i - 10] = (next & mask2) << 4 | prev >>> 22;
              prev = next;
            }
            prev >>>= 22;
            input.words[i - 10] = prev;
            if (prev === 0 && input.length > 10) {
              input.length -= 10;
            } else {
              input.length -= 9;
            }
          };
          K256.prototype.imulK = function imulK(num) {
            num.words[num.length] = 0;
            num.words[num.length + 1] = 0;
            num.length += 2;
            var lo = 0;
            for (var i = 0; i < num.length; i++) {
              var w = num.words[i] | 0;
              lo += w * 977;
              num.words[i] = lo & 67108863;
              lo = w * 64 + (lo / 67108864 | 0);
            }
            if (num.words[num.length - 1] === 0) {
              num.length--;
              if (num.words[num.length - 1] === 0) {
                num.length--;
              }
            }
            return num;
          };
          function P224() {
            MPrime.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
          }
          inherits2(P224, MPrime);
          function P192() {
            MPrime.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
          }
          inherits2(P192, MPrime);
          function P25519() {
            MPrime.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
          }
          inherits2(P25519, MPrime);
          P25519.prototype.imulK = function imulK(num) {
            var carry = 0;
            for (var i = 0; i < num.length; i++) {
              var hi = (num.words[i] | 0) * 19 + carry;
              var lo = hi & 67108863;
              hi >>>= 26;
              num.words[i] = lo;
              carry = hi;
            }
            if (carry !== 0) {
              num.words[num.length++] = carry;
            }
            return num;
          };
          BN._prime = function prime(name2) {
            if (primes[name2])
              return primes[name2];
            var prime2;
            if (name2 === "k256") {
              prime2 = new K256();
            } else if (name2 === "p224") {
              prime2 = new P224();
            } else if (name2 === "p192") {
              prime2 = new P192();
            } else if (name2 === "p25519") {
              prime2 = new P25519();
            } else {
              throw new Error("Unknown prime " + name2);
            }
            primes[name2] = prime2;
            return prime2;
          };
          function Red(m) {
            if (typeof m === "string") {
              var prime = BN._prime(m);
              this.m = prime.p;
              this.prime = prime;
            } else {
              assert2(m.gtn(1), "modulus must be greater than 1");
              this.m = m;
              this.prime = null;
            }
          }
          Red.prototype._verify1 = function _verify1(a) {
            assert2(a.negative === 0, "red works only with positives");
            assert2(a.red, "red works only with red numbers");
          };
          Red.prototype._verify2 = function _verify2(a, b) {
            assert2((a.negative | b.negative) === 0, "red works only with positives");
            assert2(a.red && a.red === b.red, "red works only with red numbers");
          };
          Red.prototype.imod = function imod(a) {
            if (this.prime)
              return this.prime.ireduce(a)._forceRed(this);
            move(a, a.umod(this.m)._forceRed(this));
            return a;
          };
          Red.prototype.neg = function neg(a) {
            if (a.isZero()) {
              return a.clone();
            }
            return this.m.sub(a)._forceRed(this);
          };
          Red.prototype.add = function add(a, b) {
            this._verify2(a, b);
            var res = a.add(b);
            if (res.cmp(this.m) >= 0) {
              res.isub(this.m);
            }
            return res._forceRed(this);
          };
          Red.prototype.iadd = function iadd(a, b) {
            this._verify2(a, b);
            var res = a.iadd(b);
            if (res.cmp(this.m) >= 0) {
              res.isub(this.m);
            }
            return res;
          };
          Red.prototype.sub = function sub(a, b) {
            this._verify2(a, b);
            var res = a.sub(b);
            if (res.cmpn(0) < 0) {
              res.iadd(this.m);
            }
            return res._forceRed(this);
          };
          Red.prototype.isub = function isub(a, b) {
            this._verify2(a, b);
            var res = a.isub(b);
            if (res.cmpn(0) < 0) {
              res.iadd(this.m);
            }
            return res;
          };
          Red.prototype.shl = function shl(a, num) {
            this._verify1(a);
            return this.imod(a.ushln(num));
          };
          Red.prototype.imul = function imul(a, b) {
            this._verify2(a, b);
            return this.imod(a.imul(b));
          };
          Red.prototype.mul = function mul(a, b) {
            this._verify2(a, b);
            return this.imod(a.mul(b));
          };
          Red.prototype.isqr = function isqr(a) {
            return this.imul(a, a.clone());
          };
          Red.prototype.sqr = function sqr(a) {
            return this.mul(a, a);
          };
          Red.prototype.sqrt = function sqrt(a) {
            if (a.isZero())
              return a.clone();
            var mod3 = this.m.andln(3);
            assert2(mod3 % 2 === 1);
            if (mod3 === 3) {
              var pow = this.m.add(new BN(1)).iushrn(2);
              return this.pow(a, pow);
            }
            var q = this.m.subn(1);
            var s = 0;
            while (!q.isZero() && q.andln(1) === 0) {
              s++;
              q.iushrn(1);
            }
            assert2(!q.isZero());
            var one = new BN(1).toRed(this);
            var nOne = one.redNeg();
            var lpow = this.m.subn(1).iushrn(1);
            var z = this.m.bitLength();
            z = new BN(2 * z * z).toRed(this);
            while (this.pow(z, lpow).cmp(nOne) !== 0) {
              z.redIAdd(nOne);
            }
            var c = this.pow(z, q);
            var r = this.pow(a, q.addn(1).iushrn(1));
            var t = this.pow(a, q);
            var m = s;
            while (t.cmp(one) !== 0) {
              var tmp = t;
              for (var i = 0; tmp.cmp(one) !== 0; i++) {
                tmp = tmp.redSqr();
              }
              assert2(i < m);
              var b = this.pow(c, new BN(1).iushln(m - i - 1));
              r = r.redMul(b);
              c = b.redSqr();
              t = t.redMul(c);
              m = i;
            }
            return r;
          };
          Red.prototype.invm = function invm(a) {
            var inv = a._invmp(this.m);
            if (inv.negative !== 0) {
              inv.negative = 0;
              return this.imod(inv).redNeg();
            } else {
              return this.imod(inv);
            }
          };
          Red.prototype.pow = function pow(a, num) {
            if (num.isZero())
              return new BN(1).toRed(this);
            if (num.cmpn(1) === 0)
              return a.clone();
            var windowSize = 4;
            var wnd = new Array(1 << windowSize);
            wnd[0] = new BN(1).toRed(this);
            wnd[1] = a;
            for (var i = 2; i < wnd.length; i++) {
              wnd[i] = this.mul(wnd[i - 1], a);
            }
            var res = wnd[0];
            var current = 0;
            var currentLen = 0;
            var start = num.bitLength() % 26;
            if (start === 0) {
              start = 26;
            }
            for (i = num.length - 1; i >= 0; i--) {
              var word = num.words[i];
              for (var j = start - 1; j >= 0; j--) {
                var bit = word >> j & 1;
                if (res !== wnd[0]) {
                  res = this.sqr(res);
                }
                if (bit === 0 && current === 0) {
                  currentLen = 0;
                  continue;
                }
                current <<= 1;
                current |= bit;
                currentLen++;
                if (currentLen !== windowSize && (i !== 0 || j !== 0))
                  continue;
                res = this.mul(res, wnd[current]);
                currentLen = 0;
                current = 0;
              }
              start = 26;
            }
            return res;
          };
          Red.prototype.convertTo = function convertTo(num) {
            var r = num.umod(this.m);
            return r === num ? r.clone() : r;
          };
          Red.prototype.convertFrom = function convertFrom(num) {
            var res = num.clone();
            res.red = null;
            return res;
          };
          BN.mont = function mont2(num) {
            return new Mont(num);
          };
          function Mont(m) {
            Red.call(this, m);
            this.shift = this.m.bitLength();
            if (this.shift % 26 !== 0) {
              this.shift += 26 - this.shift % 26;
            }
            this.r = new BN(1).iushln(this.shift);
            this.r2 = this.imod(this.r.sqr());
            this.rinv = this.r._invmp(this.m);
            this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
            this.minv = this.minv.umod(this.r);
            this.minv = this.r.sub(this.minv);
          }
          inherits2(Mont, Red);
          Mont.prototype.convertTo = function convertTo(num) {
            return this.imod(num.ushln(this.shift));
          };
          Mont.prototype.convertFrom = function convertFrom(num) {
            var r = this.imod(num.mul(this.rinv));
            r.red = null;
            return r;
          };
          Mont.prototype.imul = function imul(a, b) {
            if (a.isZero() || b.isZero()) {
              a.words[0] = 0;
              a.length = 1;
              return a;
            }
            var t = a.imul(b);
            var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
            var u = t.isub(c).iushrn(this.shift);
            var res = u;
            if (u.cmp(this.m) >= 0) {
              res = u.isub(this.m);
            } else if (u.cmpn(0) < 0) {
              res = u.iadd(this.m);
            }
            return res._forceRed(this);
          };
          Mont.prototype.mul = function mul(a, b) {
            if (a.isZero() || b.isZero())
              return new BN(0)._forceRed(this);
            var t = a.mul(b);
            var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
            var u = t.isub(c).iushrn(this.shift);
            var res = u;
            if (u.cmp(this.m) >= 0) {
              res = u.isub(this.m);
            } else if (u.cmpn(0) < 0) {
              res = u.iadd(this.m);
            }
            return res._forceRed(this);
          };
          Mont.prototype.invm = function invm(a) {
            var res = this.imod(a._invmp(this.m).mul(this.r2));
            return res._forceRed(this);
          };
        })(module2, commonjsGlobal);
      })(bn);
      return bnExports;
    }
    var browserifyRsa;
    var hasRequiredBrowserifyRsa;
    function requireBrowserifyRsa() {
      if (hasRequiredBrowserifyRsa)
        return browserifyRsa;
      hasRequiredBrowserifyRsa = 1;
      var BN = requireBn();
      var randomBytes2 = browserExports$1;
      function blind(priv) {
        var r = getr(priv);
        var blinder = r.toRed(BN.mont(priv.modulus)).redPow(new BN(priv.publicExponent)).fromRed();
        return {blinder, unblinder: r.invm(priv.modulus)};
      }
      function getr(priv) {
        var len = priv.modulus.byteLength();
        var r;
        do {
          r = new BN(randomBytes2(len));
        } while (r.cmp(priv.modulus) >= 0 || !r.umod(priv.prime1) || !r.umod(priv.prime2));
        return r;
      }
      function crt(msg, priv) {
        var blinds = blind(priv);
        var len = priv.modulus.byteLength();
        var blinded = new BN(msg).mul(blinds.blinder).umod(priv.modulus);
        var c1 = blinded.toRed(BN.mont(priv.prime1));
        var c2 = blinded.toRed(BN.mont(priv.prime2));
        var qinv = priv.coefficient;
        var p = priv.prime1;
        var q = priv.prime2;
        var m1 = c1.redPow(priv.exponent1).fromRed();
        var m2 = c2.redPow(priv.exponent2).fromRed();
        var h = m1.isub(m2).imul(qinv).umod(p).imul(q);
        return m2.iadd(h).imul(blinds.unblinder).umod(priv.modulus).toArrayLike(Buffer, "be", len);
      }
      crt.getr = getr;
      browserifyRsa = crt;
      return browserifyRsa;
    }
    var elliptic = {};
    var name$1 = "elliptic";
    var version = "6.5.4";
    var description = "EC cryptography";
    var main = "lib/elliptic.js";
    var files = [
      "lib"
    ];
    var scripts = {
      lint: "eslint lib test",
      "lint:fix": "npm run lint -- --fix",
      unit: "istanbul test _mocha --reporter=spec test/index.js",
      test: "npm run lint && npm run unit",
      version: "grunt dist && git add dist/"
    };
    var repository = {
      type: "git",
      url: "git@github.com:indutny/elliptic"
    };
    var keywords = [
      "EC",
      "Elliptic",
      "curve",
      "Cryptography"
    ];
    var author = "Fedor Indutny <fedor@indutny.com>";
    var license = "MIT";
    var bugs = {
      url: "https://github.com/indutny/elliptic/issues"
    };
    var homepage = "https://github.com/indutny/elliptic";
    var devDependencies = {
      brfs: "^2.0.2",
      coveralls: "^3.1.0",
      eslint: "^7.6.0",
      grunt: "^1.2.1",
      "grunt-browserify": "^5.3.0",
      "grunt-cli": "^1.3.2",
      "grunt-contrib-connect": "^3.0.0",
      "grunt-contrib-copy": "^1.0.0",
      "grunt-contrib-uglify": "^5.0.0",
      "grunt-mocha-istanbul": "^5.0.2",
      "grunt-saucelabs": "^9.0.1",
      istanbul: "^0.4.5",
      mocha: "^8.0.1"
    };
    var dependencies = {
      "bn.js": "^4.11.9",
      brorand: "^1.1.0",
      "hash.js": "^1.0.0",
      "hmac-drbg": "^1.0.1",
      inherits: "^2.0.4",
      "minimalistic-assert": "^1.0.1",
      "minimalistic-crypto-utils": "^1.0.1"
    };
    var require$$0 = {
      name: name$1,
      version,
      description,
      main,
      files,
      scripts,
      repository,
      keywords,
      author,
      license,
      bugs,
      homepage,
      devDependencies,
      dependencies
    };
    var utils$2 = {};
    var utils$1 = {};
    var hasRequiredUtils$2;
    function requireUtils$2() {
      if (hasRequiredUtils$2)
        return utils$1;
      hasRequiredUtils$2 = 1;
      (function(exports2) {
        var utils2 = exports2;
        function toArray(msg, enc) {
          if (Array.isArray(msg))
            return msg.slice();
          if (!msg)
            return [];
          var res = [];
          if (typeof msg !== "string") {
            for (var i = 0; i < msg.length; i++)
              res[i] = msg[i] | 0;
            return res;
          }
          if (enc === "hex") {
            msg = msg.replace(/[^a-z0-9]+/ig, "");
            if (msg.length % 2 !== 0)
              msg = "0" + msg;
            for (var i = 0; i < msg.length; i += 2)
              res.push(parseInt(msg[i] + msg[i + 1], 16));
          } else {
            for (var i = 0; i < msg.length; i++) {
              var c = msg.charCodeAt(i);
              var hi = c >> 8;
              var lo = c & 255;
              if (hi)
                res.push(hi, lo);
              else
                res.push(lo);
            }
          }
          return res;
        }
        utils2.toArray = toArray;
        function zero2(word) {
          if (word.length === 1)
            return "0" + word;
          else
            return word;
        }
        utils2.zero2 = zero2;
        function toHex2(msg) {
          var res = "";
          for (var i = 0; i < msg.length; i++)
            res += zero2(msg[i].toString(16));
          return res;
        }
        utils2.toHex = toHex2;
        utils2.encode = function encode2(arr, enc) {
          if (enc === "hex")
            return toHex2(arr);
          else
            return arr;
        };
      })(utils$1);
      return utils$1;
    }
    var hasRequiredUtils$1;
    function requireUtils$1() {
      if (hasRequiredUtils$1)
        return utils$2;
      hasRequiredUtils$1 = 1;
      (function(exports2) {
        var utils2 = exports2;
        var BN = requireBn$1();
        var minAssert = requireMinimalisticAssert();
        var minUtils = requireUtils$2();
        utils2.assert = minAssert;
        utils2.toArray = minUtils.toArray;
        utils2.zero2 = minUtils.zero2;
        utils2.toHex = minUtils.toHex;
        utils2.encode = minUtils.encode;
        function getNAF(num, w, bits) {
          var naf = new Array(Math.max(num.bitLength(), bits) + 1);
          naf.fill(0);
          var ws = 1 << w + 1;
          var k = num.clone();
          for (var i = 0; i < naf.length; i++) {
            var z;
            var mod = k.andln(ws - 1);
            if (k.isOdd()) {
              if (mod > (ws >> 1) - 1)
                z = (ws >> 1) - mod;
              else
                z = mod;
              k.isubn(z);
            } else {
              z = 0;
            }
            naf[i] = z;
            k.iushrn(1);
          }
          return naf;
        }
        utils2.getNAF = getNAF;
        function getJSF(k1, k2) {
          var jsf = [
            [],
            []
          ];
          k1 = k1.clone();
          k2 = k2.clone();
          var d1 = 0;
          var d2 = 0;
          var m8;
          while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {
            var m14 = k1.andln(3) + d1 & 3;
            var m24 = k2.andln(3) + d2 & 3;
            if (m14 === 3)
              m14 = -1;
            if (m24 === 3)
              m24 = -1;
            var u1;
            if ((m14 & 1) === 0) {
              u1 = 0;
            } else {
              m8 = k1.andln(7) + d1 & 7;
              if ((m8 === 3 || m8 === 5) && m24 === 2)
                u1 = -m14;
              else
                u1 = m14;
            }
            jsf[0].push(u1);
            var u2;
            if ((m24 & 1) === 0) {
              u2 = 0;
            } else {
              m8 = k2.andln(7) + d2 & 7;
              if ((m8 === 3 || m8 === 5) && m14 === 2)
                u2 = -m24;
              else
                u2 = m24;
            }
            jsf[1].push(u2);
            if (2 * d1 === u1 + 1)
              d1 = 1 - d1;
            if (2 * d2 === u2 + 1)
              d2 = 1 - d2;
            k1.iushrn(1);
            k2.iushrn(1);
          }
          return jsf;
        }
        utils2.getJSF = getJSF;
        function cachedProperty(obj, name2, computer) {
          var key2 = "_" + name2;
          obj.prototype[name2] = function cachedProperty2() {
            return this[key2] !== void 0 ? this[key2] : this[key2] = computer.call(this);
          };
        }
        utils2.cachedProperty = cachedProperty;
        function parseBytes(bytes) {
          return typeof bytes === "string" ? utils2.toArray(bytes, "hex") : bytes;
        }
        utils2.parseBytes = parseBytes;
        function intFromLE(bytes) {
          return new BN(bytes, "hex", "le");
        }
        utils2.intFromLE = intFromLE;
      })(utils$2);
      return utils$2;
    }
    var curve = {};
    var base$1;
    var hasRequiredBase$1;
    function requireBase$1() {
      if (hasRequiredBase$1)
        return base$1;
      hasRequiredBase$1 = 1;
      var BN = requireBn$1();
      var utils2 = requireUtils$1();
      var getNAF = utils2.getNAF;
      var getJSF = utils2.getJSF;
      var assert2 = utils2.assert;
      function BaseCurve(type, conf) {
        this.type = type;
        this.p = new BN(conf.p, 16);
        this.red = conf.prime ? BN.red(conf.prime) : BN.mont(this.p);
        this.zero = new BN(0).toRed(this.red);
        this.one = new BN(1).toRed(this.red);
        this.two = new BN(2).toRed(this.red);
        this.n = conf.n && new BN(conf.n, 16);
        this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);
        this._wnafT1 = new Array(4);
        this._wnafT2 = new Array(4);
        this._wnafT3 = new Array(4);
        this._wnafT4 = new Array(4);
        this._bitLength = this.n ? this.n.bitLength() : 0;
        var adjustCount = this.n && this.p.div(this.n);
        if (!adjustCount || adjustCount.cmpn(100) > 0) {
          this.redN = null;
        } else {
          this._maxwellTrick = true;
          this.redN = this.n.toRed(this.red);
        }
      }
      base$1 = BaseCurve;
      BaseCurve.prototype.point = function point() {
        throw new Error("Not implemented");
      };
      BaseCurve.prototype.validate = function validate() {
        throw new Error("Not implemented");
      };
      BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {
        assert2(p.precomputed);
        var doubles = p._getDoubles();
        var naf = getNAF(k, 1, this._bitLength);
        var I = (1 << doubles.step + 1) - (doubles.step % 2 === 0 ? 2 : 1);
        I /= 3;
        var repr = [];
        var j;
        var nafW;
        for (j = 0; j < naf.length; j += doubles.step) {
          nafW = 0;
          for (var l = j + doubles.step - 1; l >= j; l--)
            nafW = (nafW << 1) + naf[l];
          repr.push(nafW);
        }
        var a = this.jpoint(null, null, null);
        var b = this.jpoint(null, null, null);
        for (var i = I; i > 0; i--) {
          for (j = 0; j < repr.length; j++) {
            nafW = repr[j];
            if (nafW === i)
              b = b.mixedAdd(doubles.points[j]);
            else if (nafW === -i)
              b = b.mixedAdd(doubles.points[j].neg());
          }
          a = a.add(b);
        }
        return a.toP();
      };
      BaseCurve.prototype._wnafMul = function _wnafMul(p, k) {
        var w = 4;
        var nafPoints = p._getNAFPoints(w);
        w = nafPoints.wnd;
        var wnd = nafPoints.points;
        var naf = getNAF(k, w, this._bitLength);
        var acc = this.jpoint(null, null, null);
        for (var i = naf.length - 1; i >= 0; i--) {
          for (var l = 0; i >= 0 && naf[i] === 0; i--)
            l++;
          if (i >= 0)
            l++;
          acc = acc.dblp(l);
          if (i < 0)
            break;
          var z = naf[i];
          assert2(z !== 0);
          if (p.type === "affine") {
            if (z > 0)
              acc = acc.mixedAdd(wnd[z - 1 >> 1]);
            else
              acc = acc.mixedAdd(wnd[-z - 1 >> 1].neg());
          } else {
            if (z > 0)
              acc = acc.add(wnd[z - 1 >> 1]);
            else
              acc = acc.add(wnd[-z - 1 >> 1].neg());
          }
        }
        return p.type === "affine" ? acc.toP() : acc;
      };
      BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW, points, coeffs, len, jacobianResult) {
        var wndWidth = this._wnafT1;
        var wnd = this._wnafT2;
        var naf = this._wnafT3;
        var max = 0;
        var i;
        var j;
        var p;
        for (i = 0; i < len; i++) {
          p = points[i];
          var nafPoints = p._getNAFPoints(defW);
          wndWidth[i] = nafPoints.wnd;
          wnd[i] = nafPoints.points;
        }
        for (i = len - 1; i >= 1; i -= 2) {
          var a = i - 1;
          var b = i;
          if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {
            naf[a] = getNAF(coeffs[a], wndWidth[a], this._bitLength);
            naf[b] = getNAF(coeffs[b], wndWidth[b], this._bitLength);
            max = Math.max(naf[a].length, max);
            max = Math.max(naf[b].length, max);
            continue;
          }
          var comb = [
            points[a],
            null,
            null,
            points[b]
          ];
          if (points[a].y.cmp(points[b].y) === 0) {
            comb[1] = points[a].add(points[b]);
            comb[2] = points[a].toJ().mixedAdd(points[b].neg());
          } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {
            comb[1] = points[a].toJ().mixedAdd(points[b]);
            comb[2] = points[a].add(points[b].neg());
          } else {
            comb[1] = points[a].toJ().mixedAdd(points[b]);
            comb[2] = points[a].toJ().mixedAdd(points[b].neg());
          }
          var index2 = [
            -3,
            -1,
            -5,
            -7,
            0,
            7,
            5,
            1,
            3
          ];
          var jsf = getJSF(coeffs[a], coeffs[b]);
          max = Math.max(jsf[0].length, max);
          naf[a] = new Array(max);
          naf[b] = new Array(max);
          for (j = 0; j < max; j++) {
            var ja = jsf[0][j] | 0;
            var jb = jsf[1][j] | 0;
            naf[a][j] = index2[(ja + 1) * 3 + (jb + 1)];
            naf[b][j] = 0;
            wnd[a] = comb;
          }
        }
        var acc = this.jpoint(null, null, null);
        var tmp = this._wnafT4;
        for (i = max; i >= 0; i--) {
          var k = 0;
          while (i >= 0) {
            var zero = true;
            for (j = 0; j < len; j++) {
              tmp[j] = naf[j][i] | 0;
              if (tmp[j] !== 0)
                zero = false;
            }
            if (!zero)
              break;
            k++;
            i--;
          }
          if (i >= 0)
            k++;
          acc = acc.dblp(k);
          if (i < 0)
            break;
          for (j = 0; j < len; j++) {
            var z = tmp[j];
            if (z === 0)
              continue;
            else if (z > 0)
              p = wnd[j][z - 1 >> 1];
            else if (z < 0)
              p = wnd[j][-z - 1 >> 1].neg();
            if (p.type === "affine")
              acc = acc.mixedAdd(p);
            else
              acc = acc.add(p);
          }
        }
        for (i = 0; i < len; i++)
          wnd[i] = null;
        if (jacobianResult)
          return acc;
        else
          return acc.toP();
      };
      function BasePoint(curve2, type) {
        this.curve = curve2;
        this.type = type;
        this.precomputed = null;
      }
      BaseCurve.BasePoint = BasePoint;
      BasePoint.prototype.eq = function eq() {
        throw new Error("Not implemented");
      };
      BasePoint.prototype.validate = function validate() {
        return this.curve.validate(this);
      };
      BaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
        bytes = utils2.toArray(bytes, enc);
        var len = this.p.byteLength();
        if ((bytes[0] === 4 || bytes[0] === 6 || bytes[0] === 7) && bytes.length - 1 === 2 * len) {
          if (bytes[0] === 6)
            assert2(bytes[bytes.length - 1] % 2 === 0);
          else if (bytes[0] === 7)
            assert2(bytes[bytes.length - 1] % 2 === 1);
          var res = this.point(bytes.slice(1, 1 + len), bytes.slice(1 + len, 1 + 2 * len));
          return res;
        } else if ((bytes[0] === 2 || bytes[0] === 3) && bytes.length - 1 === len) {
          return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 3);
        }
        throw new Error("Unknown point format");
      };
      BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {
        return this.encode(enc, true);
      };
      BasePoint.prototype._encode = function _encode(compact) {
        var len = this.curve.p.byteLength();
        var x = this.getX().toArray("be", len);
        if (compact)
          return [this.getY().isEven() ? 2 : 3].concat(x);
        return [4].concat(x, this.getY().toArray("be", len));
      };
      BasePoint.prototype.encode = function encode2(enc, compact) {
        return utils2.encode(this._encode(compact), enc);
      };
      BasePoint.prototype.precompute = function precompute(power) {
        if (this.precomputed)
          return this;
        var precomputed = {
          doubles: null,
          naf: null,
          beta: null
        };
        precomputed.naf = this._getNAFPoints(8);
        precomputed.doubles = this._getDoubles(4, power);
        precomputed.beta = this._getBeta();
        this.precomputed = precomputed;
        return this;
      };
      BasePoint.prototype._hasDoubles = function _hasDoubles(k) {
        if (!this.precomputed)
          return false;
        var doubles = this.precomputed.doubles;
        if (!doubles)
          return false;
        return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);
      };
      BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
        if (this.precomputed && this.precomputed.doubles)
          return this.precomputed.doubles;
        var doubles = [this];
        var acc = this;
        for (var i = 0; i < power; i += step) {
          for (var j = 0; j < step; j++)
            acc = acc.dbl();
          doubles.push(acc);
        }
        return {
          step,
          points: doubles
        };
      };
      BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
        if (this.precomputed && this.precomputed.naf)
          return this.precomputed.naf;
        var res = [this];
        var max = (1 << wnd) - 1;
        var dbl = max === 1 ? null : this.dbl();
        for (var i = 1; i < max; i++)
          res[i] = res[i - 1].add(dbl);
        return {
          wnd,
          points: res
        };
      };
      BasePoint.prototype._getBeta = function _getBeta() {
        return null;
      };
      BasePoint.prototype.dblp = function dblp(k) {
        var r = this;
        for (var i = 0; i < k; i++)
          r = r.dbl();
        return r;
      };
      return base$1;
    }
    var short;
    var hasRequiredShort;
    function requireShort() {
      if (hasRequiredShort)
        return short;
      hasRequiredShort = 1;
      var utils2 = requireUtils$1();
      var BN = requireBn$1();
      var inherits2 = require$$3$1;
      var Base2 = requireBase$1();
      var assert2 = utils2.assert;
      function ShortCurve(conf) {
        Base2.call(this, "short", conf);
        this.a = new BN(conf.a, 16).toRed(this.red);
        this.b = new BN(conf.b, 16).toRed(this.red);
        this.tinv = this.two.redInvm();
        this.zeroA = this.a.fromRed().cmpn(0) === 0;
        this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;
        this.endo = this._getEndomorphism(conf);
        this._endoWnafT1 = new Array(4);
        this._endoWnafT2 = new Array(4);
      }
      inherits2(ShortCurve, Base2);
      short = ShortCurve;
      ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
        if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
          return;
        var beta;
        var lambda;
        if (conf.beta) {
          beta = new BN(conf.beta, 16).toRed(this.red);
        } else {
          var betas = this._getEndoRoots(this.p);
          beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
          beta = beta.toRed(this.red);
        }
        if (conf.lambda) {
          lambda = new BN(conf.lambda, 16);
        } else {
          var lambdas = this._getEndoRoots(this.n);
          if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
            lambda = lambdas[0];
          } else {
            lambda = lambdas[1];
            assert2(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
          }
        }
        var basis;
        if (conf.basis) {
          basis = conf.basis.map(function(vec) {
            return {
              a: new BN(vec.a, 16),
              b: new BN(vec.b, 16)
            };
          });
        } else {
          basis = this._getEndoBasis(lambda);
        }
        return {
          beta,
          lambda,
          basis
        };
      };
      ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
        var red = num === this.p ? this.red : BN.mont(num);
        var tinv = new BN(2).toRed(red).redInvm();
        var ntinv = tinv.redNeg();
        var s = new BN(3).toRed(red).redNeg().redSqrt().redMul(tinv);
        var l1 = ntinv.redAdd(s).fromRed();
        var l2 = ntinv.redSub(s).fromRed();
        return [l1, l2];
      };
      ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
        var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));
        var u = lambda;
        var v2 = this.n.clone();
        var x1 = new BN(1);
        var y1 = new BN(0);
        var x2 = new BN(0);
        var y2 = new BN(1);
        var a0;
        var b0;
        var a1;
        var b1;
        var a2;
        var b2;
        var prevR;
        var i = 0;
        var r;
        var x;
        while (u.cmpn(0) !== 0) {
          var q = v2.div(u);
          r = v2.sub(q.mul(u));
          x = x2.sub(q.mul(x1));
          var y = y2.sub(q.mul(y1));
          if (!a1 && r.cmp(aprxSqrt) < 0) {
            a0 = prevR.neg();
            b0 = x1;
            a1 = r.neg();
            b1 = x;
          } else if (a1 && ++i === 2) {
            break;
          }
          prevR = r;
          v2 = u;
          u = r;
          x2 = x1;
          x1 = x;
          y2 = y1;
          y1 = y;
        }
        a2 = r.neg();
        b2 = x;
        var len1 = a1.sqr().add(b1.sqr());
        var len2 = a2.sqr().add(b2.sqr());
        if (len2.cmp(len1) >= 0) {
          a2 = a0;
          b2 = b0;
        }
        if (a1.negative) {
          a1 = a1.neg();
          b1 = b1.neg();
        }
        if (a2.negative) {
          a2 = a2.neg();
          b2 = b2.neg();
        }
        return [
          {a: a1, b: b1},
          {a: a2, b: b2}
        ];
      };
      ShortCurve.prototype._endoSplit = function _endoSplit(k) {
        var basis = this.endo.basis;
        var v1 = basis[0];
        var v2 = basis[1];
        var c1 = v2.b.mul(k).divRound(this.n);
        var c2 = v1.b.neg().mul(k).divRound(this.n);
        var p1 = c1.mul(v1.a);
        var p2 = c2.mul(v2.a);
        var q1 = c1.mul(v1.b);
        var q2 = c2.mul(v2.b);
        var k1 = k.sub(p1).sub(p2);
        var k2 = q1.add(q2).neg();
        return {k1, k2};
      };
      ShortCurve.prototype.pointFromX = function pointFromX(x, odd) {
        x = new BN(x, 16);
        if (!x.red)
          x = x.toRed(this.red);
        var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);
        var y = y2.redSqrt();
        if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
          throw new Error("invalid point");
        var isOdd = y.fromRed().isOdd();
        if (odd && !isOdd || !odd && isOdd)
          y = y.redNeg();
        return this.point(x, y);
      };
      ShortCurve.prototype.validate = function validate(point) {
        if (point.inf)
          return true;
        var x = point.x;
        var y = point.y;
        var ax = this.a.redMul(x);
        var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);
        return y.redSqr().redISub(rhs).cmpn(0) === 0;
      };
      ShortCurve.prototype._endoWnafMulAdd = function _endoWnafMulAdd(points, coeffs, jacobianResult) {
        var npoints = this._endoWnafT1;
        var ncoeffs = this._endoWnafT2;
        for (var i = 0; i < points.length; i++) {
          var split = this._endoSplit(coeffs[i]);
          var p = points[i];
          var beta = p._getBeta();
          if (split.k1.negative) {
            split.k1.ineg();
            p = p.neg(true);
          }
          if (split.k2.negative) {
            split.k2.ineg();
            beta = beta.neg(true);
          }
          npoints[i * 2] = p;
          npoints[i * 2 + 1] = beta;
          ncoeffs[i * 2] = split.k1;
          ncoeffs[i * 2 + 1] = split.k2;
        }
        var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult);
        for (var j = 0; j < i * 2; j++) {
          npoints[j] = null;
          ncoeffs[j] = null;
        }
        return res;
      };
      function Point(curve2, x, y, isRed) {
        Base2.BasePoint.call(this, curve2, "affine");
        if (x === null && y === null) {
          this.x = null;
          this.y = null;
          this.inf = true;
        } else {
          this.x = new BN(x, 16);
          this.y = new BN(y, 16);
          if (isRed) {
            this.x.forceRed(this.curve.red);
            this.y.forceRed(this.curve.red);
          }
          if (!this.x.red)
            this.x = this.x.toRed(this.curve.red);
          if (!this.y.red)
            this.y = this.y.toRed(this.curve.red);
          this.inf = false;
        }
      }
      inherits2(Point, Base2.BasePoint);
      ShortCurve.prototype.point = function point(x, y, isRed) {
        return new Point(this, x, y, isRed);
      };
      ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
        return Point.fromJSON(this, obj, red);
      };
      Point.prototype._getBeta = function _getBeta() {
        if (!this.curve.endo)
          return;
        var pre = this.precomputed;
        if (pre && pre.beta)
          return pre.beta;
        var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
        if (pre) {
          var curve2 = this.curve;
          var endoMul = function(p) {
            return curve2.point(p.x.redMul(curve2.endo.beta), p.y);
          };
          pre.beta = beta;
          beta.precomputed = {
            beta: null,
            naf: pre.naf && {
              wnd: pre.naf.wnd,
              points: pre.naf.points.map(endoMul)
            },
            doubles: pre.doubles && {
              step: pre.doubles.step,
              points: pre.doubles.points.map(endoMul)
            }
          };
        }
        return beta;
      };
      Point.prototype.toJSON = function toJSON() {
        if (!this.precomputed)
          return [this.x, this.y];
        return [this.x, this.y, this.precomputed && {
          doubles: this.precomputed.doubles && {
            step: this.precomputed.doubles.step,
            points: this.precomputed.doubles.points.slice(1)
          },
          naf: this.precomputed.naf && {
            wnd: this.precomputed.naf.wnd,
            points: this.precomputed.naf.points.slice(1)
          }
        }];
      };
      Point.fromJSON = function fromJSON(curve2, obj, red) {
        if (typeof obj === "string")
          obj = JSON.parse(obj);
        var res = curve2.point(obj[0], obj[1], red);
        if (!obj[2])
          return res;
        function obj2point(obj2) {
          return curve2.point(obj2[0], obj2[1], red);
        }
        var pre = obj[2];
        res.precomputed = {
          beta: null,
          doubles: pre.doubles && {
            step: pre.doubles.step,
            points: [res].concat(pre.doubles.points.map(obj2point))
          },
          naf: pre.naf && {
            wnd: pre.naf.wnd,
            points: [res].concat(pre.naf.points.map(obj2point))
          }
        };
        return res;
      };
      Point.prototype.inspect = function inspect2() {
        if (this.isInfinity())
          return "<EC Point Infinity>";
        return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
      };
      Point.prototype.isInfinity = function isInfinity() {
        return this.inf;
      };
      Point.prototype.add = function add(p) {
        if (this.inf)
          return p;
        if (p.inf)
          return this;
        if (this.eq(p))
          return this.dbl();
        if (this.neg().eq(p))
          return this.curve.point(null, null);
        if (this.x.cmp(p.x) === 0)
          return this.curve.point(null, null);
        var c = this.y.redSub(p.y);
        if (c.cmpn(0) !== 0)
          c = c.redMul(this.x.redSub(p.x).redInvm());
        var nx = c.redSqr().redISub(this.x).redISub(p.x);
        var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
        return this.curve.point(nx, ny);
      };
      Point.prototype.dbl = function dbl() {
        if (this.inf)
          return this;
        var ys1 = this.y.redAdd(this.y);
        if (ys1.cmpn(0) === 0)
          return this.curve.point(null, null);
        var a = this.curve.a;
        var x2 = this.x.redSqr();
        var dyinv = ys1.redInvm();
        var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);
        var nx = c.redSqr().redISub(this.x.redAdd(this.x));
        var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
        return this.curve.point(nx, ny);
      };
      Point.prototype.getX = function getX() {
        return this.x.fromRed();
      };
      Point.prototype.getY = function getY() {
        return this.y.fromRed();
      };
      Point.prototype.mul = function mul(k) {
        k = new BN(k, 16);
        if (this.isInfinity())
          return this;
        else if (this._hasDoubles(k))
          return this.curve._fixedNafMul(this, k);
        else if (this.curve.endo)
          return this.curve._endoWnafMulAdd([this], [k]);
        else
          return this.curve._wnafMul(this, k);
      };
      Point.prototype.mulAdd = function mulAdd(k1, p2, k2) {
        var points = [this, p2];
        var coeffs = [k1, k2];
        if (this.curve.endo)
          return this.curve._endoWnafMulAdd(points, coeffs);
        else
          return this.curve._wnafMulAdd(1, points, coeffs, 2);
      };
      Point.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {
        var points = [this, p2];
        var coeffs = [k1, k2];
        if (this.curve.endo)
          return this.curve._endoWnafMulAdd(points, coeffs, true);
        else
          return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
      };
      Point.prototype.eq = function eq(p) {
        return this === p || this.inf === p.inf && (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);
      };
      Point.prototype.neg = function neg(_precompute) {
        if (this.inf)
          return this;
        var res = this.curve.point(this.x, this.y.redNeg());
        if (_precompute && this.precomputed) {
          var pre = this.precomputed;
          var negate = function(p) {
            return p.neg();
          };
          res.precomputed = {
            naf: pre.naf && {
              wnd: pre.naf.wnd,
              points: pre.naf.points.map(negate)
            },
            doubles: pre.doubles && {
              step: pre.doubles.step,
              points: pre.doubles.points.map(negate)
            }
          };
        }
        return res;
      };
      Point.prototype.toJ = function toJ() {
        if (this.inf)
          return this.curve.jpoint(null, null, null);
        var res = this.curve.jpoint(this.x, this.y, this.curve.one);
        return res;
      };
      function JPoint(curve2, x, y, z) {
        Base2.BasePoint.call(this, curve2, "jacobian");
        if (x === null && y === null && z === null) {
          this.x = this.curve.one;
          this.y = this.curve.one;
          this.z = new BN(0);
        } else {
          this.x = new BN(x, 16);
          this.y = new BN(y, 16);
          this.z = new BN(z, 16);
        }
        if (!this.x.red)
          this.x = this.x.toRed(this.curve.red);
        if (!this.y.red)
          this.y = this.y.toRed(this.curve.red);
        if (!this.z.red)
          this.z = this.z.toRed(this.curve.red);
        this.zOne = this.z === this.curve.one;
      }
      inherits2(JPoint, Base2.BasePoint);
      ShortCurve.prototype.jpoint = function jpoint(x, y, z) {
        return new JPoint(this, x, y, z);
      };
      JPoint.prototype.toP = function toP() {
        if (this.isInfinity())
          return this.curve.point(null, null);
        var zinv = this.z.redInvm();
        var zinv2 = zinv.redSqr();
        var ax = this.x.redMul(zinv2);
        var ay = this.y.redMul(zinv2).redMul(zinv);
        return this.curve.point(ax, ay);
      };
      JPoint.prototype.neg = function neg() {
        return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
      };
      JPoint.prototype.add = function add(p) {
        if (this.isInfinity())
          return p;
        if (p.isInfinity())
          return this;
        var pz2 = p.z.redSqr();
        var z2 = this.z.redSqr();
        var u1 = this.x.redMul(pz2);
        var u2 = p.x.redMul(z2);
        var s1 = this.y.redMul(pz2.redMul(p.z));
        var s2 = p.y.redMul(z2.redMul(this.z));
        var h = u1.redSub(u2);
        var r = s1.redSub(s2);
        if (h.cmpn(0) === 0) {
          if (r.cmpn(0) !== 0)
            return this.curve.jpoint(null, null, null);
          else
            return this.dbl();
        }
        var h2 = h.redSqr();
        var h3 = h2.redMul(h);
        var v2 = u1.redMul(h2);
        var nx = r.redSqr().redIAdd(h3).redISub(v2).redISub(v2);
        var ny = r.redMul(v2.redISub(nx)).redISub(s1.redMul(h3));
        var nz = this.z.redMul(p.z).redMul(h);
        return this.curve.jpoint(nx, ny, nz);
      };
      JPoint.prototype.mixedAdd = function mixedAdd(p) {
        if (this.isInfinity())
          return p.toJ();
        if (p.isInfinity())
          return this;
        var z2 = this.z.redSqr();
        var u1 = this.x;
        var u2 = p.x.redMul(z2);
        var s1 = this.y;
        var s2 = p.y.redMul(z2).redMul(this.z);
        var h = u1.redSub(u2);
        var r = s1.redSub(s2);
        if (h.cmpn(0) === 0) {
          if (r.cmpn(0) !== 0)
            return this.curve.jpoint(null, null, null);
          else
            return this.dbl();
        }
        var h2 = h.redSqr();
        var h3 = h2.redMul(h);
        var v2 = u1.redMul(h2);
        var nx = r.redSqr().redIAdd(h3).redISub(v2).redISub(v2);
        var ny = r.redMul(v2.redISub(nx)).redISub(s1.redMul(h3));
        var nz = this.z.redMul(h);
        return this.curve.jpoint(nx, ny, nz);
      };
      JPoint.prototype.dblp = function dblp(pow) {
        if (pow === 0)
          return this;
        if (this.isInfinity())
          return this;
        if (!pow)
          return this.dbl();
        var i;
        if (this.curve.zeroA || this.curve.threeA) {
          var r = this;
          for (i = 0; i < pow; i++)
            r = r.dbl();
          return r;
        }
        var a = this.curve.a;
        var tinv = this.curve.tinv;
        var jx = this.x;
        var jy = this.y;
        var jz = this.z;
        var jz4 = jz.redSqr().redSqr();
        var jyd = jy.redAdd(jy);
        for (i = 0; i < pow; i++) {
          var jx2 = jx.redSqr();
          var jyd2 = jyd.redSqr();
          var jyd4 = jyd2.redSqr();
          var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));
          var t1 = jx.redMul(jyd2);
          var nx = c.redSqr().redISub(t1.redAdd(t1));
          var t2 = t1.redISub(nx);
          var dny = c.redMul(t2);
          dny = dny.redIAdd(dny).redISub(jyd4);
          var nz = jyd.redMul(jz);
          if (i + 1 < pow)
            jz4 = jz4.redMul(jyd4);
          jx = nx;
          jz = nz;
          jyd = dny;
        }
        return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
      };
      JPoint.prototype.dbl = function dbl() {
        if (this.isInfinity())
          return this;
        if (this.curve.zeroA)
          return this._zeroDbl();
        else if (this.curve.threeA)
          return this._threeDbl();
        else
          return this._dbl();
      };
      JPoint.prototype._zeroDbl = function _zeroDbl() {
        var nx;
        var ny;
        var nz;
        if (this.zOne) {
          var xx = this.x.redSqr();
          var yy = this.y.redSqr();
          var yyyy = yy.redSqr();
          var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
          s = s.redIAdd(s);
          var m = xx.redAdd(xx).redIAdd(xx);
          var t = m.redSqr().redISub(s).redISub(s);
          var yyyy8 = yyyy.redIAdd(yyyy);
          yyyy8 = yyyy8.redIAdd(yyyy8);
          yyyy8 = yyyy8.redIAdd(yyyy8);
          nx = t;
          ny = m.redMul(s.redISub(t)).redISub(yyyy8);
          nz = this.y.redAdd(this.y);
        } else {
          var a = this.x.redSqr();
          var b = this.y.redSqr();
          var c = b.redSqr();
          var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);
          d = d.redIAdd(d);
          var e = a.redAdd(a).redIAdd(a);
          var f = e.redSqr();
          var c8 = c.redIAdd(c);
          c8 = c8.redIAdd(c8);
          c8 = c8.redIAdd(c8);
          nx = f.redISub(d).redISub(d);
          ny = e.redMul(d.redISub(nx)).redISub(c8);
          nz = this.y.redMul(this.z);
          nz = nz.redIAdd(nz);
        }
        return this.curve.jpoint(nx, ny, nz);
      };
      JPoint.prototype._threeDbl = function _threeDbl() {
        var nx;
        var ny;
        var nz;
        if (this.zOne) {
          var xx = this.x.redSqr();
          var yy = this.y.redSqr();
          var yyyy = yy.redSqr();
          var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
          s = s.redIAdd(s);
          var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
          var t = m.redSqr().redISub(s).redISub(s);
          nx = t;
          var yyyy8 = yyyy.redIAdd(yyyy);
          yyyy8 = yyyy8.redIAdd(yyyy8);
          yyyy8 = yyyy8.redIAdd(yyyy8);
          ny = m.redMul(s.redISub(t)).redISub(yyyy8);
          nz = this.y.redAdd(this.y);
        } else {
          var delta = this.z.redSqr();
          var gamma = this.y.redSqr();
          var beta = this.x.redMul(gamma);
          var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
          alpha = alpha.redAdd(alpha).redIAdd(alpha);
          var beta4 = beta.redIAdd(beta);
          beta4 = beta4.redIAdd(beta4);
          var beta8 = beta4.redAdd(beta4);
          nx = alpha.redSqr().redISub(beta8);
          nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
          var ggamma8 = gamma.redSqr();
          ggamma8 = ggamma8.redIAdd(ggamma8);
          ggamma8 = ggamma8.redIAdd(ggamma8);
          ggamma8 = ggamma8.redIAdd(ggamma8);
          ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
        }
        return this.curve.jpoint(nx, ny, nz);
      };
      JPoint.prototype._dbl = function _dbl() {
        var a = this.curve.a;
        var jx = this.x;
        var jy = this.y;
        var jz = this.z;
        var jz4 = jz.redSqr().redSqr();
        var jx2 = jx.redSqr();
        var jy2 = jy.redSqr();
        var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));
        var jxd4 = jx.redAdd(jx);
        jxd4 = jxd4.redIAdd(jxd4);
        var t1 = jxd4.redMul(jy2);
        var nx = c.redSqr().redISub(t1.redAdd(t1));
        var t2 = t1.redISub(nx);
        var jyd8 = jy2.redSqr();
        jyd8 = jyd8.redIAdd(jyd8);
        jyd8 = jyd8.redIAdd(jyd8);
        jyd8 = jyd8.redIAdd(jyd8);
        var ny = c.redMul(t2).redISub(jyd8);
        var nz = jy.redAdd(jy).redMul(jz);
        return this.curve.jpoint(nx, ny, nz);
      };
      JPoint.prototype.trpl = function trpl() {
        if (!this.curve.zeroA)
          return this.dbl().add(this);
        var xx = this.x.redSqr();
        var yy = this.y.redSqr();
        var zz = this.z.redSqr();
        var yyyy = yy.redSqr();
        var m = xx.redAdd(xx).redIAdd(xx);
        var mm = m.redSqr();
        var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
        e = e.redIAdd(e);
        e = e.redAdd(e).redIAdd(e);
        e = e.redISub(mm);
        var ee = e.redSqr();
        var t = yyyy.redIAdd(yyyy);
        t = t.redIAdd(t);
        t = t.redIAdd(t);
        t = t.redIAdd(t);
        var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);
        var yyu4 = yy.redMul(u);
        yyu4 = yyu4.redIAdd(yyu4);
        yyu4 = yyu4.redIAdd(yyu4);
        var nx = this.x.redMul(ee).redISub(yyu4);
        nx = nx.redIAdd(nx);
        nx = nx.redIAdd(nx);
        var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));
        ny = ny.redIAdd(ny);
        ny = ny.redIAdd(ny);
        ny = ny.redIAdd(ny);
        var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);
        return this.curve.jpoint(nx, ny, nz);
      };
      JPoint.prototype.mul = function mul(k, kbase) {
        k = new BN(k, kbase);
        return this.curve._wnafMul(this, k);
      };
      JPoint.prototype.eq = function eq(p) {
        if (p.type === "affine")
          return this.eq(p.toJ());
        if (this === p)
          return true;
        var z2 = this.z.redSqr();
        var pz2 = p.z.redSqr();
        if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0)
          return false;
        var z3 = z2.redMul(this.z);
        var pz3 = pz2.redMul(p.z);
        return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;
      };
      JPoint.prototype.eqXToP = function eqXToP(x) {
        var zs = this.z.redSqr();
        var rx = x.toRed(this.curve.red).redMul(zs);
        if (this.x.cmp(rx) === 0)
          return true;
        var xc = x.clone();
        var t = this.curve.redN.redMul(zs);
        for (; ; ) {
          xc.iadd(this.curve.n);
          if (xc.cmp(this.curve.p) >= 0)
            return false;
          rx.redIAdd(t);
          if (this.x.cmp(rx) === 0)
            return true;
        }
      };
      JPoint.prototype.inspect = function inspect2() {
        if (this.isInfinity())
          return "<EC JPoint Infinity>";
        return "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
      };
      JPoint.prototype.isInfinity = function isInfinity() {
        return this.z.cmpn(0) === 0;
      };
      return short;
    }
    var mont;
    var hasRequiredMont;
    function requireMont() {
      if (hasRequiredMont)
        return mont;
      hasRequiredMont = 1;
      var BN = requireBn$1();
      var inherits2 = require$$3$1;
      var Base2 = requireBase$1();
      var utils2 = requireUtils$1();
      function MontCurve(conf) {
        Base2.call(this, "mont", conf);
        this.a = new BN(conf.a, 16).toRed(this.red);
        this.b = new BN(conf.b, 16).toRed(this.red);
        this.i4 = new BN(4).toRed(this.red).redInvm();
        this.two = new BN(2).toRed(this.red);
        this.a24 = this.i4.redMul(this.a.redAdd(this.two));
      }
      inherits2(MontCurve, Base2);
      mont = MontCurve;
      MontCurve.prototype.validate = function validate(point) {
        var x = point.normalize().x;
        var x2 = x.redSqr();
        var rhs = x2.redMul(x).redAdd(x2.redMul(this.a)).redAdd(x);
        var y = rhs.redSqrt();
        return y.redSqr().cmp(rhs) === 0;
      };
      function Point(curve2, x, z) {
        Base2.BasePoint.call(this, curve2, "projective");
        if (x === null && z === null) {
          this.x = this.curve.one;
          this.z = this.curve.zero;
        } else {
          this.x = new BN(x, 16);
          this.z = new BN(z, 16);
          if (!this.x.red)
            this.x = this.x.toRed(this.curve.red);
          if (!this.z.red)
            this.z = this.z.toRed(this.curve.red);
        }
      }
      inherits2(Point, Base2.BasePoint);
      MontCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
        return this.point(utils2.toArray(bytes, enc), 1);
      };
      MontCurve.prototype.point = function point(x, z) {
        return new Point(this, x, z);
      };
      MontCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
        return Point.fromJSON(this, obj);
      };
      Point.prototype.precompute = function precompute() {
      };
      Point.prototype._encode = function _encode() {
        return this.getX().toArray("be", this.curve.p.byteLength());
      };
      Point.fromJSON = function fromJSON(curve2, obj) {
        return new Point(curve2, obj[0], obj[1] || curve2.one);
      };
      Point.prototype.inspect = function inspect2() {
        if (this.isInfinity())
          return "<EC Point Infinity>";
        return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
      };
      Point.prototype.isInfinity = function isInfinity() {
        return this.z.cmpn(0) === 0;
      };
      Point.prototype.dbl = function dbl() {
        var a = this.x.redAdd(this.z);
        var aa = a.redSqr();
        var b = this.x.redSub(this.z);
        var bb = b.redSqr();
        var c = aa.redSub(bb);
        var nx = aa.redMul(bb);
        var nz = c.redMul(bb.redAdd(this.curve.a24.redMul(c)));
        return this.curve.point(nx, nz);
      };
      Point.prototype.add = function add() {
        throw new Error("Not supported on Montgomery curve");
      };
      Point.prototype.diffAdd = function diffAdd(p, diff) {
        var a = this.x.redAdd(this.z);
        var b = this.x.redSub(this.z);
        var c = p.x.redAdd(p.z);
        var d = p.x.redSub(p.z);
        var da = d.redMul(a);
        var cb = c.redMul(b);
        var nx = diff.z.redMul(da.redAdd(cb).redSqr());
        var nz = diff.x.redMul(da.redISub(cb).redSqr());
        return this.curve.point(nx, nz);
      };
      Point.prototype.mul = function mul(k) {
        var t = k.clone();
        var a = this;
        var b = this.curve.point(null, null);
        var c = this;
        for (var bits = []; t.cmpn(0) !== 0; t.iushrn(1))
          bits.push(t.andln(1));
        for (var i = bits.length - 1; i >= 0; i--) {
          if (bits[i] === 0) {
            a = a.diffAdd(b, c);
            b = b.dbl();
          } else {
            b = a.diffAdd(b, c);
            a = a.dbl();
          }
        }
        return b;
      };
      Point.prototype.mulAdd = function mulAdd() {
        throw new Error("Not supported on Montgomery curve");
      };
      Point.prototype.jumlAdd = function jumlAdd() {
        throw new Error("Not supported on Montgomery curve");
      };
      Point.prototype.eq = function eq(other) {
        return this.getX().cmp(other.getX()) === 0;
      };
      Point.prototype.normalize = function normalize() {
        this.x = this.x.redMul(this.z.redInvm());
        this.z = this.curve.one;
        return this;
      };
      Point.prototype.getX = function getX() {
        this.normalize();
        return this.x.fromRed();
      };
      return mont;
    }
    var edwards;
    var hasRequiredEdwards;
    function requireEdwards() {
      if (hasRequiredEdwards)
        return edwards;
      hasRequiredEdwards = 1;
      var utils2 = requireUtils$1();
      var BN = requireBn$1();
      var inherits2 = require$$3$1;
      var Base2 = requireBase$1();
      var assert2 = utils2.assert;
      function EdwardsCurve(conf) {
        this.twisted = (conf.a | 0) !== 1;
        this.mOneA = this.twisted && (conf.a | 0) === -1;
        this.extended = this.mOneA;
        Base2.call(this, "edwards", conf);
        this.a = new BN(conf.a, 16).umod(this.red.m);
        this.a = this.a.toRed(this.red);
        this.c = new BN(conf.c, 16).toRed(this.red);
        this.c2 = this.c.redSqr();
        this.d = new BN(conf.d, 16).toRed(this.red);
        this.dd = this.d.redAdd(this.d);
        assert2(!this.twisted || this.c.fromRed().cmpn(1) === 0);
        this.oneC = (conf.c | 0) === 1;
      }
      inherits2(EdwardsCurve, Base2);
      edwards = EdwardsCurve;
      EdwardsCurve.prototype._mulA = function _mulA(num) {
        if (this.mOneA)
          return num.redNeg();
        else
          return this.a.redMul(num);
      };
      EdwardsCurve.prototype._mulC = function _mulC(num) {
        if (this.oneC)
          return num;
        else
          return this.c.redMul(num);
      };
      EdwardsCurve.prototype.jpoint = function jpoint(x, y, z, t) {
        return this.point(x, y, z, t);
      };
      EdwardsCurve.prototype.pointFromX = function pointFromX(x, odd) {
        x = new BN(x, 16);
        if (!x.red)
          x = x.toRed(this.red);
        var x2 = x.redSqr();
        var rhs = this.c2.redSub(this.a.redMul(x2));
        var lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x2));
        var y2 = rhs.redMul(lhs.redInvm());
        var y = y2.redSqrt();
        if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
          throw new Error("invalid point");
        var isOdd = y.fromRed().isOdd();
        if (odd && !isOdd || !odd && isOdd)
          y = y.redNeg();
        return this.point(x, y);
      };
      EdwardsCurve.prototype.pointFromY = function pointFromY(y, odd) {
        y = new BN(y, 16);
        if (!y.red)
          y = y.toRed(this.red);
        var y2 = y.redSqr();
        var lhs = y2.redSub(this.c2);
        var rhs = y2.redMul(this.d).redMul(this.c2).redSub(this.a);
        var x2 = lhs.redMul(rhs.redInvm());
        if (x2.cmp(this.zero) === 0) {
          if (odd)
            throw new Error("invalid point");
          else
            return this.point(this.zero, y);
        }
        var x = x2.redSqrt();
        if (x.redSqr().redSub(x2).cmp(this.zero) !== 0)
          throw new Error("invalid point");
        if (x.fromRed().isOdd() !== odd)
          x = x.redNeg();
        return this.point(x, y);
      };
      EdwardsCurve.prototype.validate = function validate(point) {
        if (point.isInfinity())
          return true;
        point.normalize();
        var x2 = point.x.redSqr();
        var y2 = point.y.redSqr();
        var lhs = x2.redMul(this.a).redAdd(y2);
        var rhs = this.c2.redMul(this.one.redAdd(this.d.redMul(x2).redMul(y2)));
        return lhs.cmp(rhs) === 0;
      };
      function Point(curve2, x, y, z, t) {
        Base2.BasePoint.call(this, curve2, "projective");
        if (x === null && y === null && z === null) {
          this.x = this.curve.zero;
          this.y = this.curve.one;
          this.z = this.curve.one;
          this.t = this.curve.zero;
          this.zOne = true;
        } else {
          this.x = new BN(x, 16);
          this.y = new BN(y, 16);
          this.z = z ? new BN(z, 16) : this.curve.one;
          this.t = t && new BN(t, 16);
          if (!this.x.red)
            this.x = this.x.toRed(this.curve.red);
          if (!this.y.red)
            this.y = this.y.toRed(this.curve.red);
          if (!this.z.red)
            this.z = this.z.toRed(this.curve.red);
          if (this.t && !this.t.red)
            this.t = this.t.toRed(this.curve.red);
          this.zOne = this.z === this.curve.one;
          if (this.curve.extended && !this.t) {
            this.t = this.x.redMul(this.y);
            if (!this.zOne)
              this.t = this.t.redMul(this.z.redInvm());
          }
        }
      }
      inherits2(Point, Base2.BasePoint);
      EdwardsCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
        return Point.fromJSON(this, obj);
      };
      EdwardsCurve.prototype.point = function point(x, y, z, t) {
        return new Point(this, x, y, z, t);
      };
      Point.fromJSON = function fromJSON(curve2, obj) {
        return new Point(curve2, obj[0], obj[1], obj[2]);
      };
      Point.prototype.inspect = function inspect2() {
        if (this.isInfinity())
          return "<EC Point Infinity>";
        return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
      };
      Point.prototype.isInfinity = function isInfinity() {
        return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
      };
      Point.prototype._extDbl = function _extDbl() {
        var a = this.x.redSqr();
        var b = this.y.redSqr();
        var c = this.z.redSqr();
        c = c.redIAdd(c);
        var d = this.curve._mulA(a);
        var e = this.x.redAdd(this.y).redSqr().redISub(a).redISub(b);
        var g = d.redAdd(b);
        var f = g.redSub(c);
        var h = d.redSub(b);
        var nx = e.redMul(f);
        var ny = g.redMul(h);
        var nt = e.redMul(h);
        var nz = f.redMul(g);
        return this.curve.point(nx, ny, nz, nt);
      };
      Point.prototype._projDbl = function _projDbl() {
        var b = this.x.redAdd(this.y).redSqr();
        var c = this.x.redSqr();
        var d = this.y.redSqr();
        var nx;
        var ny;
        var nz;
        var e;
        var h;
        var j;
        if (this.curve.twisted) {
          e = this.curve._mulA(c);
          var f = e.redAdd(d);
          if (this.zOne) {
            nx = b.redSub(c).redSub(d).redMul(f.redSub(this.curve.two));
            ny = f.redMul(e.redSub(d));
            nz = f.redSqr().redSub(f).redSub(f);
          } else {
            h = this.z.redSqr();
            j = f.redSub(h).redISub(h);
            nx = b.redSub(c).redISub(d).redMul(j);
            ny = f.redMul(e.redSub(d));
            nz = f.redMul(j);
          }
        } else {
          e = c.redAdd(d);
          h = this.curve._mulC(this.z).redSqr();
          j = e.redSub(h).redSub(h);
          nx = this.curve._mulC(b.redISub(e)).redMul(j);
          ny = this.curve._mulC(e).redMul(c.redISub(d));
          nz = e.redMul(j);
        }
        return this.curve.point(nx, ny, nz);
      };
      Point.prototype.dbl = function dbl() {
        if (this.isInfinity())
          return this;
        if (this.curve.extended)
          return this._extDbl();
        else
          return this._projDbl();
      };
      Point.prototype._extAdd = function _extAdd(p) {
        var a = this.y.redSub(this.x).redMul(p.y.redSub(p.x));
        var b = this.y.redAdd(this.x).redMul(p.y.redAdd(p.x));
        var c = this.t.redMul(this.curve.dd).redMul(p.t);
        var d = this.z.redMul(p.z.redAdd(p.z));
        var e = b.redSub(a);
        var f = d.redSub(c);
        var g = d.redAdd(c);
        var h = b.redAdd(a);
        var nx = e.redMul(f);
        var ny = g.redMul(h);
        var nt = e.redMul(h);
        var nz = f.redMul(g);
        return this.curve.point(nx, ny, nz, nt);
      };
      Point.prototype._projAdd = function _projAdd(p) {
        var a = this.z.redMul(p.z);
        var b = a.redSqr();
        var c = this.x.redMul(p.x);
        var d = this.y.redMul(p.y);
        var e = this.curve.d.redMul(c).redMul(d);
        var f = b.redSub(e);
        var g = b.redAdd(e);
        var tmp = this.x.redAdd(this.y).redMul(p.x.redAdd(p.y)).redISub(c).redISub(d);
        var nx = a.redMul(f).redMul(tmp);
        var ny;
        var nz;
        if (this.curve.twisted) {
          ny = a.redMul(g).redMul(d.redSub(this.curve._mulA(c)));
          nz = f.redMul(g);
        } else {
          ny = a.redMul(g).redMul(d.redSub(c));
          nz = this.curve._mulC(f).redMul(g);
        }
        return this.curve.point(nx, ny, nz);
      };
      Point.prototype.add = function add(p) {
        if (this.isInfinity())
          return p;
        if (p.isInfinity())
          return this;
        if (this.curve.extended)
          return this._extAdd(p);
        else
          return this._projAdd(p);
      };
      Point.prototype.mul = function mul(k) {
        if (this._hasDoubles(k))
          return this.curve._fixedNafMul(this, k);
        else
          return this.curve._wnafMul(this, k);
      };
      Point.prototype.mulAdd = function mulAdd(k1, p, k2) {
        return this.curve._wnafMulAdd(1, [this, p], [k1, k2], 2, false);
      };
      Point.prototype.jmulAdd = function jmulAdd(k1, p, k2) {
        return this.curve._wnafMulAdd(1, [this, p], [k1, k2], 2, true);
      };
      Point.prototype.normalize = function normalize() {
        if (this.zOne)
          return this;
        var zi = this.z.redInvm();
        this.x = this.x.redMul(zi);
        this.y = this.y.redMul(zi);
        if (this.t)
          this.t = this.t.redMul(zi);
        this.z = this.curve.one;
        this.zOne = true;
        return this;
      };
      Point.prototype.neg = function neg() {
        return this.curve.point(this.x.redNeg(), this.y, this.z, this.t && this.t.redNeg());
      };
      Point.prototype.getX = function getX() {
        this.normalize();
        return this.x.fromRed();
      };
      Point.prototype.getY = function getY() {
        this.normalize();
        return this.y.fromRed();
      };
      Point.prototype.eq = function eq(other) {
        return this === other || this.getX().cmp(other.getX()) === 0 && this.getY().cmp(other.getY()) === 0;
      };
      Point.prototype.eqXToP = function eqXToP(x) {
        var rx = x.toRed(this.curve.red).redMul(this.z);
        if (this.x.cmp(rx) === 0)
          return true;
        var xc = x.clone();
        var t = this.curve.redN.redMul(this.z);
        for (; ; ) {
          xc.iadd(this.curve.n);
          if (xc.cmp(this.curve.p) >= 0)
            return false;
          rx.redIAdd(t);
          if (this.x.cmp(rx) === 0)
            return true;
        }
      };
      Point.prototype.toP = Point.prototype.normalize;
      Point.prototype.mixedAdd = Point.prototype.add;
      return edwards;
    }
    var hasRequiredCurve;
    function requireCurve() {
      if (hasRequiredCurve)
        return curve;
      hasRequiredCurve = 1;
      (function(exports2) {
        var curve2 = exports2;
        curve2.base = requireBase$1();
        curve2.short = requireShort();
        curve2.mont = requireMont();
        curve2.edwards = requireEdwards();
      })(curve);
      return curve;
    }
    var curves = {};
    var hash = {};
    var utils = {};
    var hasRequiredUtils;
    function requireUtils() {
      if (hasRequiredUtils)
        return utils;
      hasRequiredUtils = 1;
      var assert2 = requireMinimalisticAssert();
      var inherits2 = require$$3$1;
      utils.inherits = inherits2;
      function isSurrogatePair(msg, i) {
        if ((msg.charCodeAt(i) & 64512) !== 55296) {
          return false;
        }
        if (i < 0 || i + 1 >= msg.length) {
          return false;
        }
        return (msg.charCodeAt(i + 1) & 64512) === 56320;
      }
      function toArray(msg, enc) {
        if (Array.isArray(msg))
          return msg.slice();
        if (!msg)
          return [];
        var res = [];
        if (typeof msg === "string") {
          if (!enc) {
            var p = 0;
            for (var i = 0; i < msg.length; i++) {
              var c = msg.charCodeAt(i);
              if (c < 128) {
                res[p++] = c;
              } else if (c < 2048) {
                res[p++] = c >> 6 | 192;
                res[p++] = c & 63 | 128;
              } else if (isSurrogatePair(msg, i)) {
                c = 65536 + ((c & 1023) << 10) + (msg.charCodeAt(++i) & 1023);
                res[p++] = c >> 18 | 240;
                res[p++] = c >> 12 & 63 | 128;
                res[p++] = c >> 6 & 63 | 128;
                res[p++] = c & 63 | 128;
              } else {
                res[p++] = c >> 12 | 224;
                res[p++] = c >> 6 & 63 | 128;
                res[p++] = c & 63 | 128;
              }
            }
          } else if (enc === "hex") {
            msg = msg.replace(/[^a-z0-9]+/ig, "");
            if (msg.length % 2 !== 0)
              msg = "0" + msg;
            for (i = 0; i < msg.length; i += 2)
              res.push(parseInt(msg[i] + msg[i + 1], 16));
          }
        } else {
          for (i = 0; i < msg.length; i++)
            res[i] = msg[i] | 0;
        }
        return res;
      }
      utils.toArray = toArray;
      function toHex2(msg) {
        var res = "";
        for (var i = 0; i < msg.length; i++)
          res += zero2(msg[i].toString(16));
        return res;
      }
      utils.toHex = toHex2;
      function htonl(w) {
        var res = w >>> 24 | w >>> 8 & 65280 | w << 8 & 16711680 | (w & 255) << 24;
        return res >>> 0;
      }
      utils.htonl = htonl;
      function toHex32(msg, endian) {
        var res = "";
        for (var i = 0; i < msg.length; i++) {
          var w = msg[i];
          if (endian === "little")
            w = htonl(w);
          res += zero8(w.toString(16));
        }
        return res;
      }
      utils.toHex32 = toHex32;
      function zero2(word) {
        if (word.length === 1)
          return "0" + word;
        else
          return word;
      }
      utils.zero2 = zero2;
      function zero8(word) {
        if (word.length === 7)
          return "0" + word;
        else if (word.length === 6)
          return "00" + word;
        else if (word.length === 5)
          return "000" + word;
        else if (word.length === 4)
          return "0000" + word;
        else if (word.length === 3)
          return "00000" + word;
        else if (word.length === 2)
          return "000000" + word;
        else if (word.length === 1)
          return "0000000" + word;
        else
          return word;
      }
      utils.zero8 = zero8;
      function join32(msg, start, end, endian) {
        var len = end - start;
        assert2(len % 4 === 0);
        var res = new Array(len / 4);
        for (var i = 0, k = start; i < res.length; i++, k += 4) {
          var w;
          if (endian === "big")
            w = msg[k] << 24 | msg[k + 1] << 16 | msg[k + 2] << 8 | msg[k + 3];
          else
            w = msg[k + 3] << 24 | msg[k + 2] << 16 | msg[k + 1] << 8 | msg[k];
          res[i] = w >>> 0;
        }
        return res;
      }
      utils.join32 = join32;
      function split32(msg, endian) {
        var res = new Array(msg.length * 4);
        for (var i = 0, k = 0; i < msg.length; i++, k += 4) {
          var m = msg[i];
          if (endian === "big") {
            res[k] = m >>> 24;
            res[k + 1] = m >>> 16 & 255;
            res[k + 2] = m >>> 8 & 255;
            res[k + 3] = m & 255;
          } else {
            res[k + 3] = m >>> 24;
            res[k + 2] = m >>> 16 & 255;
            res[k + 1] = m >>> 8 & 255;
            res[k] = m & 255;
          }
        }
        return res;
      }
      utils.split32 = split32;
      function rotr32(w, b) {
        return w >>> b | w << 32 - b;
      }
      utils.rotr32 = rotr32;
      function rotl32(w, b) {
        return w << b | w >>> 32 - b;
      }
      utils.rotl32 = rotl32;
      function sum32(a, b) {
        return a + b >>> 0;
      }
      utils.sum32 = sum32;
      function sum32_3(a, b, c) {
        return a + b + c >>> 0;
      }
      utils.sum32_3 = sum32_3;
      function sum32_4(a, b, c, d) {
        return a + b + c + d >>> 0;
      }
      utils.sum32_4 = sum32_4;
      function sum32_5(a, b, c, d, e) {
        return a + b + c + d + e >>> 0;
      }
      utils.sum32_5 = sum32_5;
      function sum64(buf2, pos, ah, al) {
        var bh = buf2[pos];
        var bl = buf2[pos + 1];
        var lo = al + bl >>> 0;
        var hi = (lo < al ? 1 : 0) + ah + bh;
        buf2[pos] = hi >>> 0;
        buf2[pos + 1] = lo;
      }
      utils.sum64 = sum64;
      function sum64_hi(ah, al, bh, bl) {
        var lo = al + bl >>> 0;
        var hi = (lo < al ? 1 : 0) + ah + bh;
        return hi >>> 0;
      }
      utils.sum64_hi = sum64_hi;
      function sum64_lo(ah, al, bh, bl) {
        var lo = al + bl;
        return lo >>> 0;
      }
      utils.sum64_lo = sum64_lo;
      function sum64_4_hi(ah, al, bh, bl, ch, cl, dh2, dl) {
        var carry = 0;
        var lo = al;
        lo = lo + bl >>> 0;
        carry += lo < al ? 1 : 0;
        lo = lo + cl >>> 0;
        carry += lo < cl ? 1 : 0;
        lo = lo + dl >>> 0;
        carry += lo < dl ? 1 : 0;
        var hi = ah + bh + ch + dh2 + carry;
        return hi >>> 0;
      }
      utils.sum64_4_hi = sum64_4_hi;
      function sum64_4_lo(ah, al, bh, bl, ch, cl, dh2, dl) {
        var lo = al + bl + cl + dl;
        return lo >>> 0;
      }
      utils.sum64_4_lo = sum64_4_lo;
      function sum64_5_hi(ah, al, bh, bl, ch, cl, dh2, dl, eh, el) {
        var carry = 0;
        var lo = al;
        lo = lo + bl >>> 0;
        carry += lo < al ? 1 : 0;
        lo = lo + cl >>> 0;
        carry += lo < cl ? 1 : 0;
        lo = lo + dl >>> 0;
        carry += lo < dl ? 1 : 0;
        lo = lo + el >>> 0;
        carry += lo < el ? 1 : 0;
        var hi = ah + bh + ch + dh2 + eh + carry;
        return hi >>> 0;
      }
      utils.sum64_5_hi = sum64_5_hi;
      function sum64_5_lo(ah, al, bh, bl, ch, cl, dh2, dl, eh, el) {
        var lo = al + bl + cl + dl + el;
        return lo >>> 0;
      }
      utils.sum64_5_lo = sum64_5_lo;
      function rotr64_hi(ah, al, num) {
        var r = al << 32 - num | ah >>> num;
        return r >>> 0;
      }
      utils.rotr64_hi = rotr64_hi;
      function rotr64_lo(ah, al, num) {
        var r = ah << 32 - num | al >>> num;
        return r >>> 0;
      }
      utils.rotr64_lo = rotr64_lo;
      function shr64_hi(ah, al, num) {
        return ah >>> num;
      }
      utils.shr64_hi = shr64_hi;
      function shr64_lo(ah, al, num) {
        var r = ah << 32 - num | al >>> num;
        return r >>> 0;
      }
      utils.shr64_lo = shr64_lo;
      return utils;
    }
    var common$2 = {};
    var hasRequiredCommon$1;
    function requireCommon$1() {
      if (hasRequiredCommon$1)
        return common$2;
      hasRequiredCommon$1 = 1;
      var utils2 = requireUtils();
      var assert2 = requireMinimalisticAssert();
      function BlockHash() {
        this.pending = null;
        this.pendingTotal = 0;
        this.blockSize = this.constructor.blockSize;
        this.outSize = this.constructor.outSize;
        this.hmacStrength = this.constructor.hmacStrength;
        this.padLength = this.constructor.padLength / 8;
        this.endian = "big";
        this._delta8 = this.blockSize / 8;
        this._delta32 = this.blockSize / 32;
      }
      common$2.BlockHash = BlockHash;
      BlockHash.prototype.update = function update(msg, enc) {
        msg = utils2.toArray(msg, enc);
        if (!this.pending)
          this.pending = msg;
        else
          this.pending = this.pending.concat(msg);
        this.pendingTotal += msg.length;
        if (this.pending.length >= this._delta8) {
          msg = this.pending;
          var r = msg.length % this._delta8;
          this.pending = msg.slice(msg.length - r, msg.length);
          if (this.pending.length === 0)
            this.pending = null;
          msg = utils2.join32(msg, 0, msg.length - r, this.endian);
          for (var i = 0; i < msg.length; i += this._delta32)
            this._update(msg, i, i + this._delta32);
        }
        return this;
      };
      BlockHash.prototype.digest = function digest(enc) {
        this.update(this._pad());
        assert2(this.pending === null);
        return this._digest(enc);
      };
      BlockHash.prototype._pad = function pad2() {
        var len = this.pendingTotal;
        var bytes = this._delta8;
        var k = bytes - (len + this.padLength) % bytes;
        var res = new Array(k + this.padLength);
        res[0] = 128;
        for (var i = 1; i < k; i++)
          res[i] = 0;
        len <<= 3;
        if (this.endian === "big") {
          for (var t = 8; t < this.padLength; t++)
            res[i++] = 0;
          res[i++] = 0;
          res[i++] = 0;
          res[i++] = 0;
          res[i++] = 0;
          res[i++] = len >>> 24 & 255;
          res[i++] = len >>> 16 & 255;
          res[i++] = len >>> 8 & 255;
          res[i++] = len & 255;
        } else {
          res[i++] = len & 255;
          res[i++] = len >>> 8 & 255;
          res[i++] = len >>> 16 & 255;
          res[i++] = len >>> 24 & 255;
          res[i++] = 0;
          res[i++] = 0;
          res[i++] = 0;
          res[i++] = 0;
          for (t = 8; t < this.padLength; t++)
            res[i++] = 0;
        }
        return res;
      };
      return common$2;
    }
    var sha = {};
    var common$1 = {};
    var hasRequiredCommon;
    function requireCommon() {
      if (hasRequiredCommon)
        return common$1;
      hasRequiredCommon = 1;
      var utils2 = requireUtils();
      var rotr32 = utils2.rotr32;
      function ft_1(s, x, y, z) {
        if (s === 0)
          return ch32(x, y, z);
        if (s === 1 || s === 3)
          return p32(x, y, z);
        if (s === 2)
          return maj32(x, y, z);
      }
      common$1.ft_1 = ft_1;
      function ch32(x, y, z) {
        return x & y ^ ~x & z;
      }
      common$1.ch32 = ch32;
      function maj32(x, y, z) {
        return x & y ^ x & z ^ y & z;
      }
      common$1.maj32 = maj32;
      function p32(x, y, z) {
        return x ^ y ^ z;
      }
      common$1.p32 = p32;
      function s0_256(x) {
        return rotr32(x, 2) ^ rotr32(x, 13) ^ rotr32(x, 22);
      }
      common$1.s0_256 = s0_256;
      function s1_256(x) {
        return rotr32(x, 6) ^ rotr32(x, 11) ^ rotr32(x, 25);
      }
      common$1.s1_256 = s1_256;
      function g0_256(x) {
        return rotr32(x, 7) ^ rotr32(x, 18) ^ x >>> 3;
      }
      common$1.g0_256 = g0_256;
      function g1_256(x) {
        return rotr32(x, 17) ^ rotr32(x, 19) ^ x >>> 10;
      }
      common$1.g1_256 = g1_256;
      return common$1;
    }
    var _1;
    var hasRequired_1;
    function require_1() {
      if (hasRequired_1)
        return _1;
      hasRequired_1 = 1;
      var utils2 = requireUtils();
      var common2 = requireCommon$1();
      var shaCommon = requireCommon();
      var rotl32 = utils2.rotl32;
      var sum32 = utils2.sum32;
      var sum32_5 = utils2.sum32_5;
      var ft_1 = shaCommon.ft_1;
      var BlockHash = common2.BlockHash;
      var sha1_K = [
        1518500249,
        1859775393,
        2400959708,
        3395469782
      ];
      function SHA1() {
        if (!(this instanceof SHA1))
          return new SHA1();
        BlockHash.call(this);
        this.h = [
          1732584193,
          4023233417,
          2562383102,
          271733878,
          3285377520
        ];
        this.W = new Array(80);
      }
      utils2.inherits(SHA1, BlockHash);
      _1 = SHA1;
      SHA1.blockSize = 512;
      SHA1.outSize = 160;
      SHA1.hmacStrength = 80;
      SHA1.padLength = 64;
      SHA1.prototype._update = function _update(msg, start) {
        var W = this.W;
        for (var i = 0; i < 16; i++)
          W[i] = msg[start + i];
        for (; i < W.length; i++)
          W[i] = rotl32(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);
        var a = this.h[0];
        var b = this.h[1];
        var c = this.h[2];
        var d = this.h[3];
        var e = this.h[4];
        for (i = 0; i < W.length; i++) {
          var s = ~~(i / 20);
          var t = sum32_5(rotl32(a, 5), ft_1(s, b, c, d), e, W[i], sha1_K[s]);
          e = d;
          d = c;
          c = rotl32(b, 30);
          b = a;
          a = t;
        }
        this.h[0] = sum32(this.h[0], a);
        this.h[1] = sum32(this.h[1], b);
        this.h[2] = sum32(this.h[2], c);
        this.h[3] = sum32(this.h[3], d);
        this.h[4] = sum32(this.h[4], e);
      };
      SHA1.prototype._digest = function digest(enc) {
        if (enc === "hex")
          return utils2.toHex32(this.h, "big");
        else
          return utils2.split32(this.h, "big");
      };
      return _1;
    }
    var _256;
    var hasRequired_256;
    function require_256() {
      if (hasRequired_256)
        return _256;
      hasRequired_256 = 1;
      var utils2 = requireUtils();
      var common2 = requireCommon$1();
      var shaCommon = requireCommon();
      var assert2 = requireMinimalisticAssert();
      var sum32 = utils2.sum32;
      var sum32_4 = utils2.sum32_4;
      var sum32_5 = utils2.sum32_5;
      var ch32 = shaCommon.ch32;
      var maj32 = shaCommon.maj32;
      var s0_256 = shaCommon.s0_256;
      var s1_256 = shaCommon.s1_256;
      var g0_256 = shaCommon.g0_256;
      var g1_256 = shaCommon.g1_256;
      var BlockHash = common2.BlockHash;
      var sha256_K = [
        1116352408,
        1899447441,
        3049323471,
        3921009573,
        961987163,
        1508970993,
        2453635748,
        2870763221,
        3624381080,
        310598401,
        607225278,
        1426881987,
        1925078388,
        2162078206,
        2614888103,
        3248222580,
        3835390401,
        4022224774,
        264347078,
        604807628,
        770255983,
        1249150122,
        1555081692,
        1996064986,
        2554220882,
        2821834349,
        2952996808,
        3210313671,
        3336571891,
        3584528711,
        113926993,
        338241895,
        666307205,
        773529912,
        1294757372,
        1396182291,
        1695183700,
        1986661051,
        2177026350,
        2456956037,
        2730485921,
        2820302411,
        3259730800,
        3345764771,
        3516065817,
        3600352804,
        4094571909,
        275423344,
        430227734,
        506948616,
        659060556,
        883997877,
        958139571,
        1322822218,
        1537002063,
        1747873779,
        1955562222,
        2024104815,
        2227730452,
        2361852424,
        2428436474,
        2756734187,
        3204031479,
        3329325298
      ];
      function SHA256() {
        if (!(this instanceof SHA256))
          return new SHA256();
        BlockHash.call(this);
        this.h = [
          1779033703,
          3144134277,
          1013904242,
          2773480762,
          1359893119,
          2600822924,
          528734635,
          1541459225
        ];
        this.k = sha256_K;
        this.W = new Array(64);
      }
      utils2.inherits(SHA256, BlockHash);
      _256 = SHA256;
      SHA256.blockSize = 512;
      SHA256.outSize = 256;
      SHA256.hmacStrength = 192;
      SHA256.padLength = 64;
      SHA256.prototype._update = function _update(msg, start) {
        var W = this.W;
        for (var i = 0; i < 16; i++)
          W[i] = msg[start + i];
        for (; i < W.length; i++)
          W[i] = sum32_4(g1_256(W[i - 2]), W[i - 7], g0_256(W[i - 15]), W[i - 16]);
        var a = this.h[0];
        var b = this.h[1];
        var c = this.h[2];
        var d = this.h[3];
        var e = this.h[4];
        var f = this.h[5];
        var g = this.h[6];
        var h = this.h[7];
        assert2(this.k.length === W.length);
        for (i = 0; i < W.length; i++) {
          var T1 = sum32_5(h, s1_256(e), ch32(e, f, g), this.k[i], W[i]);
          var T2 = sum32(s0_256(a), maj32(a, b, c));
          h = g;
          g = f;
          f = e;
          e = sum32(d, T1);
          d = c;
          c = b;
          b = a;
          a = sum32(T1, T2);
        }
        this.h[0] = sum32(this.h[0], a);
        this.h[1] = sum32(this.h[1], b);
        this.h[2] = sum32(this.h[2], c);
        this.h[3] = sum32(this.h[3], d);
        this.h[4] = sum32(this.h[4], e);
        this.h[5] = sum32(this.h[5], f);
        this.h[6] = sum32(this.h[6], g);
        this.h[7] = sum32(this.h[7], h);
      };
      SHA256.prototype._digest = function digest(enc) {
        if (enc === "hex")
          return utils2.toHex32(this.h, "big");
        else
          return utils2.split32(this.h, "big");
      };
      return _256;
    }
    var _224;
    var hasRequired_224;
    function require_224() {
      if (hasRequired_224)
        return _224;
      hasRequired_224 = 1;
      var utils2 = requireUtils();
      var SHA256 = require_256();
      function SHA224() {
        if (!(this instanceof SHA224))
          return new SHA224();
        SHA256.call(this);
        this.h = [
          3238371032,
          914150663,
          812702999,
          4144912697,
          4290775857,
          1750603025,
          1694076839,
          3204075428
        ];
      }
      utils2.inherits(SHA224, SHA256);
      _224 = SHA224;
      SHA224.blockSize = 512;
      SHA224.outSize = 224;
      SHA224.hmacStrength = 192;
      SHA224.padLength = 64;
      SHA224.prototype._digest = function digest(enc) {
        if (enc === "hex")
          return utils2.toHex32(this.h.slice(0, 7), "big");
        else
          return utils2.split32(this.h.slice(0, 7), "big");
      };
      return _224;
    }
    var _512;
    var hasRequired_512;
    function require_512() {
      if (hasRequired_512)
        return _512;
      hasRequired_512 = 1;
      var utils2 = requireUtils();
      var common2 = requireCommon$1();
      var assert2 = requireMinimalisticAssert();
      var rotr64_hi = utils2.rotr64_hi;
      var rotr64_lo = utils2.rotr64_lo;
      var shr64_hi = utils2.shr64_hi;
      var shr64_lo = utils2.shr64_lo;
      var sum64 = utils2.sum64;
      var sum64_hi = utils2.sum64_hi;
      var sum64_lo = utils2.sum64_lo;
      var sum64_4_hi = utils2.sum64_4_hi;
      var sum64_4_lo = utils2.sum64_4_lo;
      var sum64_5_hi = utils2.sum64_5_hi;
      var sum64_5_lo = utils2.sum64_5_lo;
      var BlockHash = common2.BlockHash;
      var sha512_K = [
        1116352408,
        3609767458,
        1899447441,
        602891725,
        3049323471,
        3964484399,
        3921009573,
        2173295548,
        961987163,
        4081628472,
        1508970993,
        3053834265,
        2453635748,
        2937671579,
        2870763221,
        3664609560,
        3624381080,
        2734883394,
        310598401,
        1164996542,
        607225278,
        1323610764,
        1426881987,
        3590304994,
        1925078388,
        4068182383,
        2162078206,
        991336113,
        2614888103,
        633803317,
        3248222580,
        3479774868,
        3835390401,
        2666613458,
        4022224774,
        944711139,
        264347078,
        2341262773,
        604807628,
        2007800933,
        770255983,
        1495990901,
        1249150122,
        1856431235,
        1555081692,
        3175218132,
        1996064986,
        2198950837,
        2554220882,
        3999719339,
        2821834349,
        766784016,
        2952996808,
        2566594879,
        3210313671,
        3203337956,
        3336571891,
        1034457026,
        3584528711,
        2466948901,
        113926993,
        3758326383,
        338241895,
        168717936,
        666307205,
        1188179964,
        773529912,
        1546045734,
        1294757372,
        1522805485,
        1396182291,
        2643833823,
        1695183700,
        2343527390,
        1986661051,
        1014477480,
        2177026350,
        1206759142,
        2456956037,
        344077627,
        2730485921,
        1290863460,
        2820302411,
        3158454273,
        3259730800,
        3505952657,
        3345764771,
        106217008,
        3516065817,
        3606008344,
        3600352804,
        1432725776,
        4094571909,
        1467031594,
        275423344,
        851169720,
        430227734,
        3100823752,
        506948616,
        1363258195,
        659060556,
        3750685593,
        883997877,
        3785050280,
        958139571,
        3318307427,
        1322822218,
        3812723403,
        1537002063,
        2003034995,
        1747873779,
        3602036899,
        1955562222,
        1575990012,
        2024104815,
        1125592928,
        2227730452,
        2716904306,
        2361852424,
        442776044,
        2428436474,
        593698344,
        2756734187,
        3733110249,
        3204031479,
        2999351573,
        3329325298,
        3815920427,
        3391569614,
        3928383900,
        3515267271,
        566280711,
        3940187606,
        3454069534,
        4118630271,
        4000239992,
        116418474,
        1914138554,
        174292421,
        2731055270,
        289380356,
        3203993006,
        460393269,
        320620315,
        685471733,
        587496836,
        852142971,
        1086792851,
        1017036298,
        365543100,
        1126000580,
        2618297676,
        1288033470,
        3409855158,
        1501505948,
        4234509866,
        1607167915,
        987167468,
        1816402316,
        1246189591
      ];
      function SHA512() {
        if (!(this instanceof SHA512))
          return new SHA512();
        BlockHash.call(this);
        this.h = [
          1779033703,
          4089235720,
          3144134277,
          2227873595,
          1013904242,
          4271175723,
          2773480762,
          1595750129,
          1359893119,
          2917565137,
          2600822924,
          725511199,
          528734635,
          4215389547,
          1541459225,
          327033209
        ];
        this.k = sha512_K;
        this.W = new Array(160);
      }
      utils2.inherits(SHA512, BlockHash);
      _512 = SHA512;
      SHA512.blockSize = 1024;
      SHA512.outSize = 512;
      SHA512.hmacStrength = 192;
      SHA512.padLength = 128;
      SHA512.prototype._prepareBlock = function _prepareBlock(msg, start) {
        var W = this.W;
        for (var i = 0; i < 32; i++)
          W[i] = msg[start + i];
        for (; i < W.length; i += 2) {
          var c0_hi = g1_512_hi(W[i - 4], W[i - 3]);
          var c0_lo = g1_512_lo(W[i - 4], W[i - 3]);
          var c1_hi = W[i - 14];
          var c1_lo = W[i - 13];
          var c2_hi = g0_512_hi(W[i - 30], W[i - 29]);
          var c2_lo = g0_512_lo(W[i - 30], W[i - 29]);
          var c3_hi = W[i - 32];
          var c3_lo = W[i - 31];
          W[i] = sum64_4_hi(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo);
          W[i + 1] = sum64_4_lo(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo);
        }
      };
      SHA512.prototype._update = function _update(msg, start) {
        this._prepareBlock(msg, start);
        var W = this.W;
        var ah = this.h[0];
        var al = this.h[1];
        var bh = this.h[2];
        var bl = this.h[3];
        var ch = this.h[4];
        var cl = this.h[5];
        var dh2 = this.h[6];
        var dl = this.h[7];
        var eh = this.h[8];
        var el = this.h[9];
        var fh = this.h[10];
        var fl = this.h[11];
        var gh = this.h[12];
        var gl = this.h[13];
        var hh = this.h[14];
        var hl = this.h[15];
        assert2(this.k.length === W.length);
        for (var i = 0; i < W.length; i += 2) {
          var c0_hi = hh;
          var c0_lo = hl;
          var c1_hi = s1_512_hi(eh, el);
          var c1_lo = s1_512_lo(eh, el);
          var c2_hi = ch64_hi(eh, el, fh, fl, gh);
          var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);
          var c3_hi = this.k[i];
          var c3_lo = this.k[i + 1];
          var c4_hi = W[i];
          var c4_lo = W[i + 1];
          var T1_hi = sum64_5_hi(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo, c4_hi, c4_lo);
          var T1_lo = sum64_5_lo(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo, c4_hi, c4_lo);
          c0_hi = s0_512_hi(ah, al);
          c0_lo = s0_512_lo(ah, al);
          c1_hi = maj64_hi(ah, al, bh, bl, ch);
          c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);
          var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
          var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);
          hh = gh;
          hl = gl;
          gh = fh;
          gl = fl;
          fh = eh;
          fl = el;
          eh = sum64_hi(dh2, dl, T1_hi, T1_lo);
          el = sum64_lo(dl, dl, T1_hi, T1_lo);
          dh2 = ch;
          dl = cl;
          ch = bh;
          cl = bl;
          bh = ah;
          bl = al;
          ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
          al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
        }
        sum64(this.h, 0, ah, al);
        sum64(this.h, 2, bh, bl);
        sum64(this.h, 4, ch, cl);
        sum64(this.h, 6, dh2, dl);
        sum64(this.h, 8, eh, el);
        sum64(this.h, 10, fh, fl);
        sum64(this.h, 12, gh, gl);
        sum64(this.h, 14, hh, hl);
      };
      SHA512.prototype._digest = function digest(enc) {
        if (enc === "hex")
          return utils2.toHex32(this.h, "big");
        else
          return utils2.split32(this.h, "big");
      };
      function ch64_hi(xh, xl, yh, yl, zh) {
        var r = xh & yh ^ ~xh & zh;
        if (r < 0)
          r += 4294967296;
        return r;
      }
      function ch64_lo(xh, xl, yh, yl, zh, zl) {
        var r = xl & yl ^ ~xl & zl;
        if (r < 0)
          r += 4294967296;
        return r;
      }
      function maj64_hi(xh, xl, yh, yl, zh) {
        var r = xh & yh ^ xh & zh ^ yh & zh;
        if (r < 0)
          r += 4294967296;
        return r;
      }
      function maj64_lo(xh, xl, yh, yl, zh, zl) {
        var r = xl & yl ^ xl & zl ^ yl & zl;
        if (r < 0)
          r += 4294967296;
        return r;
      }
      function s0_512_hi(xh, xl) {
        var c0_hi = rotr64_hi(xh, xl, 28);
        var c1_hi = rotr64_hi(xl, xh, 2);
        var c2_hi = rotr64_hi(xl, xh, 7);
        var r = c0_hi ^ c1_hi ^ c2_hi;
        if (r < 0)
          r += 4294967296;
        return r;
      }
      function s0_512_lo(xh, xl) {
        var c0_lo = rotr64_lo(xh, xl, 28);
        var c1_lo = rotr64_lo(xl, xh, 2);
        var c2_lo = rotr64_lo(xl, xh, 7);
        var r = c0_lo ^ c1_lo ^ c2_lo;
        if (r < 0)
          r += 4294967296;
        return r;
      }
      function s1_512_hi(xh, xl) {
        var c0_hi = rotr64_hi(xh, xl, 14);
        var c1_hi = rotr64_hi(xh, xl, 18);
        var c2_hi = rotr64_hi(xl, xh, 9);
        var r = c0_hi ^ c1_hi ^ c2_hi;
        if (r < 0)
          r += 4294967296;
        return r;
      }
      function s1_512_lo(xh, xl) {
        var c0_lo = rotr64_lo(xh, xl, 14);
        var c1_lo = rotr64_lo(xh, xl, 18);
        var c2_lo = rotr64_lo(xl, xh, 9);
        var r = c0_lo ^ c1_lo ^ c2_lo;
        if (r < 0)
          r += 4294967296;
        return r;
      }
      function g0_512_hi(xh, xl) {
        var c0_hi = rotr64_hi(xh, xl, 1);
        var c1_hi = rotr64_hi(xh, xl, 8);
        var c2_hi = shr64_hi(xh, xl, 7);
        var r = c0_hi ^ c1_hi ^ c2_hi;
        if (r < 0)
          r += 4294967296;
        return r;
      }
      function g0_512_lo(xh, xl) {
        var c0_lo = rotr64_lo(xh, xl, 1);
        var c1_lo = rotr64_lo(xh, xl, 8);
        var c2_lo = shr64_lo(xh, xl, 7);
        var r = c0_lo ^ c1_lo ^ c2_lo;
        if (r < 0)
          r += 4294967296;
        return r;
      }
      function g1_512_hi(xh, xl) {
        var c0_hi = rotr64_hi(xh, xl, 19);
        var c1_hi = rotr64_hi(xl, xh, 29);
        var c2_hi = shr64_hi(xh, xl, 6);
        var r = c0_hi ^ c1_hi ^ c2_hi;
        if (r < 0)
          r += 4294967296;
        return r;
      }
      function g1_512_lo(xh, xl) {
        var c0_lo = rotr64_lo(xh, xl, 19);
        var c1_lo = rotr64_lo(xl, xh, 29);
        var c2_lo = shr64_lo(xh, xl, 6);
        var r = c0_lo ^ c1_lo ^ c2_lo;
        if (r < 0)
          r += 4294967296;
        return r;
      }
      return _512;
    }
    var _384;
    var hasRequired_384;
    function require_384() {
      if (hasRequired_384)
        return _384;
      hasRequired_384 = 1;
      var utils2 = requireUtils();
      var SHA512 = require_512();
      function SHA384() {
        if (!(this instanceof SHA384))
          return new SHA384();
        SHA512.call(this);
        this.h = [
          3418070365,
          3238371032,
          1654270250,
          914150663,
          2438529370,
          812702999,
          355462360,
          4144912697,
          1731405415,
          4290775857,
          2394180231,
          1750603025,
          3675008525,
          1694076839,
          1203062813,
          3204075428
        ];
      }
      utils2.inherits(SHA384, SHA512);
      _384 = SHA384;
      SHA384.blockSize = 1024;
      SHA384.outSize = 384;
      SHA384.hmacStrength = 192;
      SHA384.padLength = 128;
      SHA384.prototype._digest = function digest(enc) {
        if (enc === "hex")
          return utils2.toHex32(this.h.slice(0, 12), "big");
        else
          return utils2.split32(this.h.slice(0, 12), "big");
      };
      return _384;
    }
    var hasRequiredSha;
    function requireSha() {
      if (hasRequiredSha)
        return sha;
      hasRequiredSha = 1;
      sha.sha1 = require_1();
      sha.sha224 = require_224();
      sha.sha256 = require_256();
      sha.sha384 = require_384();
      sha.sha512 = require_512();
      return sha;
    }
    var ripemd = {};
    var hasRequiredRipemd;
    function requireRipemd() {
      if (hasRequiredRipemd)
        return ripemd;
      hasRequiredRipemd = 1;
      var utils2 = requireUtils();
      var common2 = requireCommon$1();
      var rotl32 = utils2.rotl32;
      var sum32 = utils2.sum32;
      var sum32_3 = utils2.sum32_3;
      var sum32_4 = utils2.sum32_4;
      var BlockHash = common2.BlockHash;
      function RIPEMD160() {
        if (!(this instanceof RIPEMD160))
          return new RIPEMD160();
        BlockHash.call(this);
        this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
        this.endian = "little";
      }
      utils2.inherits(RIPEMD160, BlockHash);
      ripemd.ripemd160 = RIPEMD160;
      RIPEMD160.blockSize = 512;
      RIPEMD160.outSize = 160;
      RIPEMD160.hmacStrength = 192;
      RIPEMD160.padLength = 64;
      RIPEMD160.prototype._update = function update(msg, start) {
        var A = this.h[0];
        var B = this.h[1];
        var C = this.h[2];
        var D = this.h[3];
        var E = this.h[4];
        var Ah = A;
        var Bh = B;
        var Ch = C;
        var Dh = D;
        var Eh = E;
        for (var j = 0; j < 80; j++) {
          var T = sum32(rotl32(sum32_4(A, f(j, B, C, D), msg[r[j] + start], K(j)), s[j]), E);
          A = E;
          E = D;
          D = rotl32(C, 10);
          C = B;
          B = T;
          T = sum32(rotl32(sum32_4(Ah, f(79 - j, Bh, Ch, Dh), msg[rh[j] + start], Kh(j)), sh[j]), Eh);
          Ah = Eh;
          Eh = Dh;
          Dh = rotl32(Ch, 10);
          Ch = Bh;
          Bh = T;
        }
        T = sum32_3(this.h[1], C, Dh);
        this.h[1] = sum32_3(this.h[2], D, Eh);
        this.h[2] = sum32_3(this.h[3], E, Ah);
        this.h[3] = sum32_3(this.h[4], A, Bh);
        this.h[4] = sum32_3(this.h[0], B, Ch);
        this.h[0] = T;
      };
      RIPEMD160.prototype._digest = function digest(enc) {
        if (enc === "hex")
          return utils2.toHex32(this.h, "little");
        else
          return utils2.split32(this.h, "little");
      };
      function f(j, x, y, z) {
        if (j <= 15)
          return x ^ y ^ z;
        else if (j <= 31)
          return x & y | ~x & z;
        else if (j <= 47)
          return (x | ~y) ^ z;
        else if (j <= 63)
          return x & z | y & ~z;
        else
          return x ^ (y | ~z);
      }
      function K(j) {
        if (j <= 15)
          return 0;
        else if (j <= 31)
          return 1518500249;
        else if (j <= 47)
          return 1859775393;
        else if (j <= 63)
          return 2400959708;
        else
          return 2840853838;
      }
      function Kh(j) {
        if (j <= 15)
          return 1352829926;
        else if (j <= 31)
          return 1548603684;
        else if (j <= 47)
          return 1836072691;
        else if (j <= 63)
          return 2053994217;
        else
          return 0;
      }
      var r = [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        7,
        4,
        13,
        1,
        10,
        6,
        15,
        3,
        12,
        0,
        9,
        5,
        2,
        14,
        11,
        8,
        3,
        10,
        14,
        4,
        9,
        15,
        8,
        1,
        2,
        7,
        0,
        6,
        13,
        11,
        5,
        12,
        1,
        9,
        11,
        10,
        0,
        8,
        12,
        4,
        13,
        3,
        7,
        15,
        14,
        5,
        6,
        2,
        4,
        0,
        5,
        9,
        7,
        12,
        2,
        10,
        14,
        1,
        3,
        8,
        11,
        6,
        15,
        13
      ];
      var rh = [
        5,
        14,
        7,
        0,
        9,
        2,
        11,
        4,
        13,
        6,
        15,
        8,
        1,
        10,
        3,
        12,
        6,
        11,
        3,
        7,
        0,
        13,
        5,
        10,
        14,
        15,
        8,
        12,
        4,
        9,
        1,
        2,
        15,
        5,
        1,
        3,
        7,
        14,
        6,
        9,
        11,
        8,
        12,
        2,
        10,
        0,
        4,
        13,
        8,
        6,
        4,
        1,
        3,
        11,
        15,
        0,
        5,
        12,
        2,
        13,
        9,
        7,
        10,
        14,
        12,
        15,
        10,
        4,
        1,
        5,
        8,
        7,
        6,
        2,
        13,
        14,
        0,
        3,
        9,
        11
      ];
      var s = [
        11,
        14,
        15,
        12,
        5,
        8,
        7,
        9,
        11,
        13,
        14,
        15,
        6,
        7,
        9,
        8,
        7,
        6,
        8,
        13,
        11,
        9,
        7,
        15,
        7,
        12,
        15,
        9,
        11,
        7,
        13,
        12,
        11,
        13,
        6,
        7,
        14,
        9,
        13,
        15,
        14,
        8,
        13,
        6,
        5,
        12,
        7,
        5,
        11,
        12,
        14,
        15,
        14,
        15,
        9,
        8,
        9,
        14,
        5,
        6,
        8,
        6,
        5,
        12,
        9,
        15,
        5,
        11,
        6,
        8,
        13,
        12,
        5,
        12,
        13,
        14,
        11,
        8,
        5,
        6
      ];
      var sh = [
        8,
        9,
        9,
        11,
        13,
        15,
        15,
        5,
        7,
        7,
        8,
        11,
        14,
        14,
        12,
        6,
        9,
        13,
        15,
        7,
        12,
        8,
        9,
        11,
        7,
        7,
        12,
        7,
        6,
        15,
        13,
        11,
        9,
        7,
        15,
        11,
        8,
        6,
        6,
        14,
        12,
        13,
        5,
        14,
        13,
        13,
        7,
        5,
        15,
        5,
        8,
        11,
        14,
        14,
        6,
        14,
        6,
        9,
        12,
        9,
        12,
        5,
        15,
        8,
        8,
        5,
        12,
        9,
        12,
        5,
        14,
        6,
        8,
        13,
        6,
        5,
        15,
        13,
        11,
        11
      ];
      return ripemd;
    }
    var hmac;
    var hasRequiredHmac;
    function requireHmac() {
      if (hasRequiredHmac)
        return hmac;
      hasRequiredHmac = 1;
      var utils2 = requireUtils();
      var assert2 = requireMinimalisticAssert();
      function Hmac(hash2, key2, enc) {
        if (!(this instanceof Hmac))
          return new Hmac(hash2, key2, enc);
        this.Hash = hash2;
        this.blockSize = hash2.blockSize / 8;
        this.outSize = hash2.outSize / 8;
        this.inner = null;
        this.outer = null;
        this._init(utils2.toArray(key2, enc));
      }
      hmac = Hmac;
      Hmac.prototype._init = function init2(key2) {
        if (key2.length > this.blockSize)
          key2 = new this.Hash().update(key2).digest();
        assert2(key2.length <= this.blockSize);
        for (var i = key2.length; i < this.blockSize; i++)
          key2.push(0);
        for (i = 0; i < key2.length; i++)
          key2[i] ^= 54;
        this.inner = new this.Hash().update(key2);
        for (i = 0; i < key2.length; i++)
          key2[i] ^= 106;
        this.outer = new this.Hash().update(key2);
      };
      Hmac.prototype.update = function update(msg, enc) {
        this.inner.update(msg, enc);
        return this;
      };
      Hmac.prototype.digest = function digest(enc) {
        this.outer.update(this.inner.digest());
        return this.outer.digest(enc);
      };
      return hmac;
    }
    var hasRequiredHash;
    function requireHash() {
      if (hasRequiredHash)
        return hash;
      hasRequiredHash = 1;
      (function(exports2) {
        var hash2 = exports2;
        hash2.utils = requireUtils();
        hash2.common = requireCommon$1();
        hash2.sha = requireSha();
        hash2.ripemd = requireRipemd();
        hash2.hmac = requireHmac();
        hash2.sha1 = hash2.sha.sha1;
        hash2.sha256 = hash2.sha.sha256;
        hash2.sha224 = hash2.sha.sha224;
        hash2.sha384 = hash2.sha.sha384;
        hash2.sha512 = hash2.sha.sha512;
        hash2.ripemd160 = hash2.ripemd.ripemd160;
      })(hash);
      return hash;
    }
    var secp256k1;
    var hasRequiredSecp256k1;
    function requireSecp256k1() {
      if (hasRequiredSecp256k1)
        return secp256k1;
      hasRequiredSecp256k1 = 1;
      secp256k1 = {
        doubles: {
          step: 4,
          points: [
            [
              "e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a",
              "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"
            ],
            [
              "8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508",
              "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"
            ],
            [
              "175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739",
              "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"
            ],
            [
              "363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640",
              "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"
            ],
            [
              "8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c",
              "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"
            ],
            [
              "723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda",
              "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"
            ],
            [
              "eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa",
              "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"
            ],
            [
              "100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0",
              "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"
            ],
            [
              "e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d",
              "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"
            ],
            [
              "feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d",
              "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"
            ],
            [
              "da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1",
              "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"
            ],
            [
              "53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0",
              "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"
            ],
            [
              "8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047",
              "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"
            ],
            [
              "385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862",
              "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"
            ],
            [
              "6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7",
              "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"
            ],
            [
              "3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd",
              "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"
            ],
            [
              "85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83",
              "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"
            ],
            [
              "948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a",
              "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"
            ],
            [
              "6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8",
              "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"
            ],
            [
              "e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d",
              "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"
            ],
            [
              "e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725",
              "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"
            ],
            [
              "213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754",
              "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"
            ],
            [
              "4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c",
              "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"
            ],
            [
              "fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6",
              "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"
            ],
            [
              "76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39",
              "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"
            ],
            [
              "c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891",
              "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"
            ],
            [
              "d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b",
              "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"
            ],
            [
              "b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03",
              "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"
            ],
            [
              "e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d",
              "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"
            ],
            [
              "a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070",
              "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"
            ],
            [
              "90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4",
              "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"
            ],
            [
              "8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da",
              "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"
            ],
            [
              "e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11",
              "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"
            ],
            [
              "8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e",
              "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"
            ],
            [
              "e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41",
              "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"
            ],
            [
              "b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef",
              "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"
            ],
            [
              "d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8",
              "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"
            ],
            [
              "324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d",
              "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"
            ],
            [
              "4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96",
              "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"
            ],
            [
              "9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd",
              "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"
            ],
            [
              "6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5",
              "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"
            ],
            [
              "a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266",
              "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"
            ],
            [
              "7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71",
              "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"
            ],
            [
              "928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac",
              "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"
            ],
            [
              "85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751",
              "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"
            ],
            [
              "ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e",
              "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"
            ],
            [
              "827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241",
              "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"
            ],
            [
              "eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3",
              "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"
            ],
            [
              "e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f",
              "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"
            ],
            [
              "1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19",
              "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"
            ],
            [
              "146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be",
              "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"
            ],
            [
              "fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9",
              "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"
            ],
            [
              "da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2",
              "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"
            ],
            [
              "a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13",
              "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"
            ],
            [
              "174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c",
              "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"
            ],
            [
              "959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba",
              "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"
            ],
            [
              "d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151",
              "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"
            ],
            [
              "64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073",
              "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"
            ],
            [
              "8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458",
              "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"
            ],
            [
              "13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b",
              "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"
            ],
            [
              "bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366",
              "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"
            ],
            [
              "8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa",
              "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"
            ],
            [
              "8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0",
              "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"
            ],
            [
              "dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787",
              "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"
            ],
            [
              "f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e",
              "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"
            ]
          ]
        },
        naf: {
          wnd: 7,
          points: [
            [
              "f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9",
              "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"
            ],
            [
              "2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4",
              "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"
            ],
            [
              "5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc",
              "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"
            ],
            [
              "acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe",
              "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"
            ],
            [
              "774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb",
              "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"
            ],
            [
              "f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8",
              "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"
            ],
            [
              "d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e",
              "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"
            ],
            [
              "defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34",
              "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"
            ],
            [
              "2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c",
              "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"
            ],
            [
              "352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5",
              "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"
            ],
            [
              "2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f",
              "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"
            ],
            [
              "9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714",
              "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"
            ],
            [
              "daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729",
              "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"
            ],
            [
              "c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db",
              "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"
            ],
            [
              "6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4",
              "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"
            ],
            [
              "1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5",
              "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"
            ],
            [
              "605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479",
              "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"
            ],
            [
              "62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d",
              "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"
            ],
            [
              "80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f",
              "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"
            ],
            [
              "7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb",
              "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"
            ],
            [
              "d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9",
              "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"
            ],
            [
              "49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963",
              "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"
            ],
            [
              "77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74",
              "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"
            ],
            [
              "f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530",
              "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"
            ],
            [
              "463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b",
              "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"
            ],
            [
              "f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247",
              "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"
            ],
            [
              "caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1",
              "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"
            ],
            [
              "2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120",
              "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"
            ],
            [
              "7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435",
              "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"
            ],
            [
              "754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18",
              "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"
            ],
            [
              "e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8",
              "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"
            ],
            [
              "186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb",
              "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"
            ],
            [
              "df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f",
              "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"
            ],
            [
              "5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143",
              "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"
            ],
            [
              "290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba",
              "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"
            ],
            [
              "af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45",
              "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"
            ],
            [
              "766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a",
              "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"
            ],
            [
              "59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e",
              "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"
            ],
            [
              "f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8",
              "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"
            ],
            [
              "7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c",
              "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"
            ],
            [
              "948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519",
              "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"
            ],
            [
              "7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab",
              "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"
            ],
            [
              "3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca",
              "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"
            ],
            [
              "d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf",
              "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"
            ],
            [
              "1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610",
              "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"
            ],
            [
              "733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4",
              "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"
            ],
            [
              "15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c",
              "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"
            ],
            [
              "a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940",
              "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"
            ],
            [
              "e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980",
              "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"
            ],
            [
              "311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3",
              "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"
            ],
            [
              "34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf",
              "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"
            ],
            [
              "f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63",
              "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"
            ],
            [
              "d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448",
              "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"
            ],
            [
              "32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf",
              "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"
            ],
            [
              "7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5",
              "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"
            ],
            [
              "ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6",
              "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"
            ],
            [
              "16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5",
              "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"
            ],
            [
              "eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99",
              "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"
            ],
            [
              "78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51",
              "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"
            ],
            [
              "494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5",
              "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"
            ],
            [
              "a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5",
              "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"
            ],
            [
              "c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997",
              "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"
            ],
            [
              "841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881",
              "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"
            ],
            [
              "5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5",
              "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"
            ],
            [
              "36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66",
              "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"
            ],
            [
              "336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726",
              "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"
            ],
            [
              "8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede",
              "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"
            ],
            [
              "1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94",
              "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"
            ],
            [
              "85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31",
              "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"
            ],
            [
              "29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51",
              "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"
            ],
            [
              "a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252",
              "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"
            ],
            [
              "4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5",
              "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"
            ],
            [
              "d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b",
              "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"
            ],
            [
              "ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4",
              "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"
            ],
            [
              "af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f",
              "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"
            ],
            [
              "e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889",
              "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"
            ],
            [
              "591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246",
              "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"
            ],
            [
              "11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984",
              "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"
            ],
            [
              "3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a",
              "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"
            ],
            [
              "cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030",
              "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"
            ],
            [
              "c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197",
              "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"
            ],
            [
              "c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593",
              "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"
            ],
            [
              "a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef",
              "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"
            ],
            [
              "347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38",
              "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"
            ],
            [
              "da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a",
              "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"
            ],
            [
              "c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111",
              "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"
            ],
            [
              "4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502",
              "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"
            ],
            [
              "3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea",
              "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"
            ],
            [
              "cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26",
              "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"
            ],
            [
              "b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986",
              "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"
            ],
            [
              "d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e",
              "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"
            ],
            [
              "48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4",
              "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"
            ],
            [
              "dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda",
              "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"
            ],
            [
              "6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859",
              "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"
            ],
            [
              "e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f",
              "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"
            ],
            [
              "eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c",
              "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"
            ],
            [
              "13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942",
              "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"
            ],
            [
              "ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a",
              "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"
            ],
            [
              "b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80",
              "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"
            ],
            [
              "ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d",
              "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"
            ],
            [
              "8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1",
              "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"
            ],
            [
              "52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63",
              "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"
            ],
            [
              "e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352",
              "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"
            ],
            [
              "7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193",
              "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"
            ],
            [
              "5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00",
              "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"
            ],
            [
              "32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58",
              "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"
            ],
            [
              "e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7",
              "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"
            ],
            [
              "8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8",
              "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"
            ],
            [
              "4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e",
              "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"
            ],
            [
              "3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d",
              "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"
            ],
            [
              "674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b",
              "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"
            ],
            [
              "d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f",
              "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"
            ],
            [
              "30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6",
              "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"
            ],
            [
              "be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297",
              "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"
            ],
            [
              "93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a",
              "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"
            ],
            [
              "b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c",
              "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"
            ],
            [
              "d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52",
              "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"
            ],
            [
              "d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb",
              "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"
            ],
            [
              "463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065",
              "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"
            ],
            [
              "7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917",
              "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"
            ],
            [
              "74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9",
              "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"
            ],
            [
              "30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3",
              "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"
            ],
            [
              "9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57",
              "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"
            ],
            [
              "176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66",
              "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"
            ],
            [
              "75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8",
              "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"
            ],
            [
              "809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721",
              "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"
            ],
            [
              "1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180",
              "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"
            ]
          ]
        }
      };
      return secp256k1;
    }
    var hasRequiredCurves;
    function requireCurves() {
      if (hasRequiredCurves)
        return curves;
      hasRequiredCurves = 1;
      (function(exports2) {
        var curves2 = exports2;
        var hash2 = requireHash();
        var curve2 = requireCurve();
        var utils2 = requireUtils$1();
        var assert2 = utils2.assert;
        function PresetCurve(options) {
          if (options.type === "short")
            this.curve = new curve2.short(options);
          else if (options.type === "edwards")
            this.curve = new curve2.edwards(options);
          else
            this.curve = new curve2.mont(options);
          this.g = this.curve.g;
          this.n = this.curve.n;
          this.hash = options.hash;
          assert2(this.g.validate(), "Invalid curve");
          assert2(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
        }
        curves2.PresetCurve = PresetCurve;
        function defineCurve(name2, options) {
          Object.defineProperty(curves2, name2, {
            configurable: true,
            enumerable: true,
            get: function() {
              var curve3 = new PresetCurve(options);
              Object.defineProperty(curves2, name2, {
                configurable: true,
                enumerable: true,
                value: curve3
              });
              return curve3;
            }
          });
        }
        defineCurve("p192", {
          type: "short",
          prime: "p192",
          p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
          a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
          b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
          n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
          hash: hash2.sha256,
          gRed: false,
          g: [
            "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
            "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
          ]
        });
        defineCurve("p224", {
          type: "short",
          prime: "p224",
          p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
          a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
          b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
          n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
          hash: hash2.sha256,
          gRed: false,
          g: [
            "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
            "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
          ]
        });
        defineCurve("p256", {
          type: "short",
          prime: null,
          p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
          a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
          b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
          n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
          hash: hash2.sha256,
          gRed: false,
          g: [
            "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
            "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
          ]
        });
        defineCurve("p384", {
          type: "short",
          prime: null,
          p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
          a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
          b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
          n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
          hash: hash2.sha384,
          gRed: false,
          g: [
            "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
            "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
          ]
        });
        defineCurve("p521", {
          type: "short",
          prime: null,
          p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
          a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
          b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
          n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
          hash: hash2.sha512,
          gRed: false,
          g: [
            "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
            "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
          ]
        });
        defineCurve("curve25519", {
          type: "mont",
          prime: "p25519",
          p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
          a: "76d06",
          b: "1",
          n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
          hash: hash2.sha256,
          gRed: false,
          g: [
            "9"
          ]
        });
        defineCurve("ed25519", {
          type: "edwards",
          prime: "p25519",
          p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
          a: "-1",
          c: "1",
          d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
          n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
          hash: hash2.sha256,
          gRed: false,
          g: [
            "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
            "6666666666666666666666666666666666666666666666666666666666666658"
          ]
        });
        var pre;
        try {
          pre = requireSecp256k1();
        } catch (e) {
          pre = void 0;
        }
        defineCurve("secp256k1", {
          type: "short",
          prime: "k256",
          p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
          a: "0",
          b: "7",
          n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
          h: "1",
          hash: hash2.sha256,
          beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
          lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
          basis: [
            {
              a: "3086d221a7d46bcde86c90e49284eb15",
              b: "-e4437ed6010e88286f547fa90abfe4c3"
            },
            {
              a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
              b: "3086d221a7d46bcde86c90e49284eb15"
            }
          ],
          gRed: false,
          g: [
            "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
            "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
            pre
          ]
        });
      })(curves);
      return curves;
    }
    var hmacDrbg;
    var hasRequiredHmacDrbg;
    function requireHmacDrbg() {
      if (hasRequiredHmacDrbg)
        return hmacDrbg;
      hasRequiredHmacDrbg = 1;
      var hash2 = requireHash();
      var utils2 = requireUtils$2();
      var assert2 = requireMinimalisticAssert();
      function HmacDRBG(options) {
        if (!(this instanceof HmacDRBG))
          return new HmacDRBG(options);
        this.hash = options.hash;
        this.predResist = !!options.predResist;
        this.outLen = this.hash.outSize;
        this.minEntropy = options.minEntropy || this.hash.hmacStrength;
        this._reseed = null;
        this.reseedInterval = null;
        this.K = null;
        this.V = null;
        var entropy = utils2.toArray(options.entropy, options.entropyEnc || "hex");
        var nonce = utils2.toArray(options.nonce, options.nonceEnc || "hex");
        var pers = utils2.toArray(options.pers, options.persEnc || "hex");
        assert2(entropy.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits");
        this._init(entropy, nonce, pers);
      }
      hmacDrbg = HmacDRBG;
      HmacDRBG.prototype._init = function init2(entropy, nonce, pers) {
        var seed = entropy.concat(nonce).concat(pers);
        this.K = new Array(this.outLen / 8);
        this.V = new Array(this.outLen / 8);
        for (var i = 0; i < this.V.length; i++) {
          this.K[i] = 0;
          this.V[i] = 1;
        }
        this._update(seed);
        this._reseed = 1;
        this.reseedInterval = 281474976710656;
      };
      HmacDRBG.prototype._hmac = function hmac2() {
        return new hash2.hmac(this.hash, this.K);
      };
      HmacDRBG.prototype._update = function update(seed) {
        var kmac = this._hmac().update(this.V).update([0]);
        if (seed)
          kmac = kmac.update(seed);
        this.K = kmac.digest();
        this.V = this._hmac().update(this.V).digest();
        if (!seed)
          return;
        this.K = this._hmac().update(this.V).update([1]).update(seed).digest();
        this.V = this._hmac().update(this.V).digest();
      };
      HmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {
        if (typeof entropyEnc !== "string") {
          addEnc = add;
          add = entropyEnc;
          entropyEnc = null;
        }
        entropy = utils2.toArray(entropy, entropyEnc);
        add = utils2.toArray(add, addEnc);
        assert2(entropy.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits");
        this._update(entropy.concat(add || []));
        this._reseed = 1;
      };
      HmacDRBG.prototype.generate = function generate(len, enc, add, addEnc) {
        if (this._reseed > this.reseedInterval)
          throw new Error("Reseed is required");
        if (typeof enc !== "string") {
          addEnc = add;
          add = enc;
          enc = null;
        }
        if (add) {
          add = utils2.toArray(add, addEnc || "hex");
          this._update(add);
        }
        var temp = [];
        while (temp.length < len) {
          this.V = this._hmac().update(this.V).digest();
          temp = temp.concat(this.V);
        }
        var res = temp.slice(0, len);
        this._update(add);
        this._reseed++;
        return utils2.encode(res, enc);
      };
      return hmacDrbg;
    }
    var key$1;
    var hasRequiredKey$1;
    function requireKey$1() {
      if (hasRequiredKey$1)
        return key$1;
      hasRequiredKey$1 = 1;
      var BN = requireBn$1();
      var utils2 = requireUtils$1();
      var assert2 = utils2.assert;
      function KeyPair(ec2, options) {
        this.ec = ec2;
        this.priv = null;
        this.pub = null;
        if (options.priv)
          this._importPrivate(options.priv, options.privEnc);
        if (options.pub)
          this._importPublic(options.pub, options.pubEnc);
      }
      key$1 = KeyPair;
      KeyPair.fromPublic = function fromPublic(ec2, pub, enc) {
        if (pub instanceof KeyPair)
          return pub;
        return new KeyPair(ec2, {
          pub,
          pubEnc: enc
        });
      };
      KeyPair.fromPrivate = function fromPrivate(ec2, priv, enc) {
        if (priv instanceof KeyPair)
          return priv;
        return new KeyPair(ec2, {
          priv,
          privEnc: enc
        });
      };
      KeyPair.prototype.validate = function validate() {
        var pub = this.getPublic();
        if (pub.isInfinity())
          return {result: false, reason: "Invalid public key"};
        if (!pub.validate())
          return {result: false, reason: "Public key is not a point"};
        if (!pub.mul(this.ec.curve.n).isInfinity())
          return {result: false, reason: "Public key * N != O"};
        return {result: true, reason: null};
      };
      KeyPair.prototype.getPublic = function getPublic(compact, enc) {
        if (typeof compact === "string") {
          enc = compact;
          compact = null;
        }
        if (!this.pub)
          this.pub = this.ec.g.mul(this.priv);
        if (!enc)
          return this.pub;
        return this.pub.encode(enc, compact);
      };
      KeyPair.prototype.getPrivate = function getPrivate(enc) {
        if (enc === "hex")
          return this.priv.toString(16, 2);
        else
          return this.priv;
      };
      KeyPair.prototype._importPrivate = function _importPrivate(key2, enc) {
        this.priv = new BN(key2, enc || 16);
        this.priv = this.priv.umod(this.ec.curve.n);
      };
      KeyPair.prototype._importPublic = function _importPublic(key2, enc) {
        if (key2.x || key2.y) {
          if (this.ec.curve.type === "mont") {
            assert2(key2.x, "Need x coordinate");
          } else if (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") {
            assert2(key2.x && key2.y, "Need both x and y coordinate");
          }
          this.pub = this.ec.curve.point(key2.x, key2.y);
          return;
        }
        this.pub = this.ec.curve.decodePoint(key2, enc);
      };
      KeyPair.prototype.derive = function derive(pub) {
        if (!pub.validate()) {
          assert2(pub.validate(), "public point not validated");
        }
        return pub.mul(this.priv).getX();
      };
      KeyPair.prototype.sign = function sign2(msg, enc, options) {
        return this.ec.sign(msg, this, enc, options);
      };
      KeyPair.prototype.verify = function verify(msg, signature2) {
        return this.ec.verify(msg, signature2, this);
      };
      KeyPair.prototype.inspect = function inspect2() {
        return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
      };
      return key$1;
    }
    var signature$1;
    var hasRequiredSignature$1;
    function requireSignature$1() {
      if (hasRequiredSignature$1)
        return signature$1;
      hasRequiredSignature$1 = 1;
      var BN = requireBn$1();
      var utils2 = requireUtils$1();
      var assert2 = utils2.assert;
      function Signature(options, enc) {
        if (options instanceof Signature)
          return options;
        if (this._importDER(options, enc))
          return;
        assert2(options.r && options.s, "Signature without r or s");
        this.r = new BN(options.r, 16);
        this.s = new BN(options.s, 16);
        if (options.recoveryParam === void 0)
          this.recoveryParam = null;
        else
          this.recoveryParam = options.recoveryParam;
      }
      signature$1 = Signature;
      function Position() {
        this.place = 0;
      }
      function getLength(buf2, p) {
        var initial = buf2[p.place++];
        if (!(initial & 128)) {
          return initial;
        }
        var octetLen = initial & 15;
        if (octetLen === 0 || octetLen > 4) {
          return false;
        }
        var val = 0;
        for (var i = 0, off2 = p.place; i < octetLen; i++, off2++) {
          val <<= 8;
          val |= buf2[off2];
          val >>>= 0;
        }
        if (val <= 127) {
          return false;
        }
        p.place = off2;
        return val;
      }
      function rmPadding(buf2) {
        var i = 0;
        var len = buf2.length - 1;
        while (!buf2[i] && !(buf2[i + 1] & 128) && i < len) {
          i++;
        }
        if (i === 0) {
          return buf2;
        }
        return buf2.slice(i);
      }
      Signature.prototype._importDER = function _importDER(data, enc) {
        data = utils2.toArray(data, enc);
        var p = new Position();
        if (data[p.place++] !== 48) {
          return false;
        }
        var len = getLength(data, p);
        if (len === false) {
          return false;
        }
        if (len + p.place !== data.length) {
          return false;
        }
        if (data[p.place++] !== 2) {
          return false;
        }
        var rlen = getLength(data, p);
        if (rlen === false) {
          return false;
        }
        var r = data.slice(p.place, rlen + p.place);
        p.place += rlen;
        if (data[p.place++] !== 2) {
          return false;
        }
        var slen = getLength(data, p);
        if (slen === false) {
          return false;
        }
        if (data.length !== slen + p.place) {
          return false;
        }
        var s = data.slice(p.place, slen + p.place);
        if (r[0] === 0) {
          if (r[1] & 128) {
            r = r.slice(1);
          } else {
            return false;
          }
        }
        if (s[0] === 0) {
          if (s[1] & 128) {
            s = s.slice(1);
          } else {
            return false;
          }
        }
        this.r = new BN(r);
        this.s = new BN(s);
        this.recoveryParam = null;
        return true;
      };
      function constructLength(arr, len) {
        if (len < 128) {
          arr.push(len);
          return;
        }
        var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
        arr.push(octets | 128);
        while (--octets) {
          arr.push(len >>> (octets << 3) & 255);
        }
        arr.push(len);
      }
      Signature.prototype.toDER = function toDER(enc) {
        var r = this.r.toArray();
        var s = this.s.toArray();
        if (r[0] & 128)
          r = [0].concat(r);
        if (s[0] & 128)
          s = [0].concat(s);
        r = rmPadding(r);
        s = rmPadding(s);
        while (!s[0] && !(s[1] & 128)) {
          s = s.slice(1);
        }
        var arr = [2];
        constructLength(arr, r.length);
        arr = arr.concat(r);
        arr.push(2);
        constructLength(arr, s.length);
        var backHalf = arr.concat(s);
        var res = [48];
        constructLength(res, backHalf.length);
        res = res.concat(backHalf);
        return utils2.encode(res, enc);
      };
      return signature$1;
    }
    var ec;
    var hasRequiredEc;
    function requireEc() {
      if (hasRequiredEc)
        return ec;
      hasRequiredEc = 1;
      var BN = requireBn$1();
      var HmacDRBG = requireHmacDrbg();
      var utils2 = requireUtils$1();
      var curves2 = requireCurves();
      var rand = requireBrorand();
      var assert2 = utils2.assert;
      var KeyPair = requireKey$1();
      var Signature = requireSignature$1();
      function EC(options) {
        if (!(this instanceof EC))
          return new EC(options);
        if (typeof options === "string") {
          assert2(Object.prototype.hasOwnProperty.call(curves2, options), "Unknown curve " + options);
          options = curves2[options];
        }
        if (options instanceof curves2.PresetCurve)
          options = {curve: options};
        this.curve = options.curve.curve;
        this.n = this.curve.n;
        this.nh = this.n.ushrn(1);
        this.g = this.curve.g;
        this.g = options.curve.g;
        this.g.precompute(options.curve.n.bitLength() + 1);
        this.hash = options.hash || options.curve.hash;
      }
      ec = EC;
      EC.prototype.keyPair = function keyPair(options) {
        return new KeyPair(this, options);
      };
      EC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
        return KeyPair.fromPrivate(this, priv, enc);
      };
      EC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
        return KeyPair.fromPublic(this, pub, enc);
      };
      EC.prototype.genKeyPair = function genKeyPair(options) {
        if (!options)
          options = {};
        var drbg = new HmacDRBG({
          hash: this.hash,
          pers: options.pers,
          persEnc: options.persEnc || "utf8",
          entropy: options.entropy || rand(this.hash.hmacStrength),
          entropyEnc: options.entropy && options.entropyEnc || "utf8",
          nonce: this.n.toArray()
        });
        var bytes = this.n.byteLength();
        var ns2 = this.n.sub(new BN(2));
        for (; ; ) {
          var priv = new BN(drbg.generate(bytes));
          if (priv.cmp(ns2) > 0)
            continue;
          priv.iaddn(1);
          return this.keyFromPrivate(priv);
        }
      };
      EC.prototype._truncateToN = function _truncateToN(msg, truncOnly) {
        var delta = msg.byteLength() * 8 - this.n.bitLength();
        if (delta > 0)
          msg = msg.ushrn(delta);
        if (!truncOnly && msg.cmp(this.n) >= 0)
          return msg.sub(this.n);
        else
          return msg;
      };
      EC.prototype.sign = function sign2(msg, key2, enc, options) {
        if (typeof enc === "object") {
          options = enc;
          enc = null;
        }
        if (!options)
          options = {};
        key2 = this.keyFromPrivate(key2, enc);
        msg = this._truncateToN(new BN(msg, 16));
        var bytes = this.n.byteLength();
        var bkey = key2.getPrivate().toArray("be", bytes);
        var nonce = msg.toArray("be", bytes);
        var drbg = new HmacDRBG({
          hash: this.hash,
          entropy: bkey,
          nonce,
          pers: options.pers,
          persEnc: options.persEnc || "utf8"
        });
        var ns1 = this.n.sub(new BN(1));
        for (var iter = 0; ; iter++) {
          var k = options.k ? options.k(iter) : new BN(drbg.generate(this.n.byteLength()));
          k = this._truncateToN(k, true);
          if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0)
            continue;
          var kp = this.g.mul(k);
          if (kp.isInfinity())
            continue;
          var kpX = kp.getX();
          var r = kpX.umod(this.n);
          if (r.cmpn(0) === 0)
            continue;
          var s = k.invm(this.n).mul(r.mul(key2.getPrivate()).iadd(msg));
          s = s.umod(this.n);
          if (s.cmpn(0) === 0)
            continue;
          var recoveryParam = (kp.getY().isOdd() ? 1 : 0) | (kpX.cmp(r) !== 0 ? 2 : 0);
          if (options.canonical && s.cmp(this.nh) > 0) {
            s = this.n.sub(s);
            recoveryParam ^= 1;
          }
          return new Signature({r, s, recoveryParam});
        }
      };
      EC.prototype.verify = function verify(msg, signature2, key2, enc) {
        msg = this._truncateToN(new BN(msg, 16));
        key2 = this.keyFromPublic(key2, enc);
        signature2 = new Signature(signature2, "hex");
        var r = signature2.r;
        var s = signature2.s;
        if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0)
          return false;
        if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0)
          return false;
        var sinv = s.invm(this.n);
        var u1 = sinv.mul(msg).umod(this.n);
        var u2 = sinv.mul(r).umod(this.n);
        var p;
        if (!this.curve._maxwellTrick) {
          p = this.g.mulAdd(u1, key2.getPublic(), u2);
          if (p.isInfinity())
            return false;
          return p.getX().umod(this.n).cmp(r) === 0;
        }
        p = this.g.jmulAdd(u1, key2.getPublic(), u2);
        if (p.isInfinity())
          return false;
        return p.eqXToP(r);
      };
      EC.prototype.recoverPubKey = function(msg, signature2, j, enc) {
        assert2((3 & j) === j, "The recovery param is more than two bits");
        signature2 = new Signature(signature2, enc);
        var n = this.n;
        var e = new BN(msg);
        var r = signature2.r;
        var s = signature2.s;
        var isYOdd = j & 1;
        var isSecondKey = j >> 1;
        if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
          throw new Error("Unable to find sencond key candinate");
        if (isSecondKey)
          r = this.curve.pointFromX(r.add(this.curve.n), isYOdd);
        else
          r = this.curve.pointFromX(r, isYOdd);
        var rInv = signature2.r.invm(n);
        var s1 = n.sub(e).mul(rInv).umod(n);
        var s2 = s.mul(rInv).umod(n);
        return this.g.mulAdd(s1, r, s2);
      };
      EC.prototype.getKeyRecoveryParam = function(e, signature2, Q, enc) {
        signature2 = new Signature(signature2, enc);
        if (signature2.recoveryParam !== null)
          return signature2.recoveryParam;
        for (var i = 0; i < 4; i++) {
          var Qprime;
          try {
            Qprime = this.recoverPubKey(e, signature2, i);
          } catch (e2) {
            continue;
          }
          if (Qprime.eq(Q))
            return i;
        }
        throw new Error("Unable to find valid recovery factor");
      };
      return ec;
    }
    var key;
    var hasRequiredKey;
    function requireKey() {
      if (hasRequiredKey)
        return key;
      hasRequiredKey = 1;
      var utils2 = requireUtils$1();
      var assert2 = utils2.assert;
      var parseBytes = utils2.parseBytes;
      var cachedProperty = utils2.cachedProperty;
      function KeyPair(eddsa2, params2) {
        this.eddsa = eddsa2;
        this._secret = parseBytes(params2.secret);
        if (eddsa2.isPoint(params2.pub))
          this._pub = params2.pub;
        else
          this._pubBytes = parseBytes(params2.pub);
      }
      KeyPair.fromPublic = function fromPublic(eddsa2, pub) {
        if (pub instanceof KeyPair)
          return pub;
        return new KeyPair(eddsa2, {pub});
      };
      KeyPair.fromSecret = function fromSecret(eddsa2, secret) {
        if (secret instanceof KeyPair)
          return secret;
        return new KeyPair(eddsa2, {secret});
      };
      KeyPair.prototype.secret = function secret() {
        return this._secret;
      };
      cachedProperty(KeyPair, "pubBytes", function pubBytes() {
        return this.eddsa.encodePoint(this.pub());
      });
      cachedProperty(KeyPair, "pub", function pub() {
        if (this._pubBytes)
          return this.eddsa.decodePoint(this._pubBytes);
        return this.eddsa.g.mul(this.priv());
      });
      cachedProperty(KeyPair, "privBytes", function privBytes() {
        var eddsa2 = this.eddsa;
        var hash2 = this.hash();
        var lastIx = eddsa2.encodingLength - 1;
        var a = hash2.slice(0, eddsa2.encodingLength);
        a[0] &= 248;
        a[lastIx] &= 127;
        a[lastIx] |= 64;
        return a;
      });
      cachedProperty(KeyPair, "priv", function priv() {
        return this.eddsa.decodeInt(this.privBytes());
      });
      cachedProperty(KeyPair, "hash", function hash2() {
        return this.eddsa.hash().update(this.secret()).digest();
      });
      cachedProperty(KeyPair, "messagePrefix", function messagePrefix() {
        return this.hash().slice(this.eddsa.encodingLength);
      });
      KeyPair.prototype.sign = function sign2(message) {
        assert2(this._secret, "KeyPair can only verify");
        return this.eddsa.sign(message, this);
      };
      KeyPair.prototype.verify = function verify(message, sig) {
        return this.eddsa.verify(message, sig, this);
      };
      KeyPair.prototype.getSecret = function getSecret(enc) {
        assert2(this._secret, "KeyPair is public only");
        return utils2.encode(this.secret(), enc);
      };
      KeyPair.prototype.getPublic = function getPublic(enc) {
        return utils2.encode(this.pubBytes(), enc);
      };
      key = KeyPair;
      return key;
    }
    var signature;
    var hasRequiredSignature;
    function requireSignature() {
      if (hasRequiredSignature)
        return signature;
      hasRequiredSignature = 1;
      var BN = requireBn$1();
      var utils2 = requireUtils$1();
      var assert2 = utils2.assert;
      var cachedProperty = utils2.cachedProperty;
      var parseBytes = utils2.parseBytes;
      function Signature(eddsa2, sig) {
        this.eddsa = eddsa2;
        if (typeof sig !== "object")
          sig = parseBytes(sig);
        if (Array.isArray(sig)) {
          sig = {
            R: sig.slice(0, eddsa2.encodingLength),
            S: sig.slice(eddsa2.encodingLength)
          };
        }
        assert2(sig.R && sig.S, "Signature without R or S");
        if (eddsa2.isPoint(sig.R))
          this._R = sig.R;
        if (sig.S instanceof BN)
          this._S = sig.S;
        this._Rencoded = Array.isArray(sig.R) ? sig.R : sig.Rencoded;
        this._Sencoded = Array.isArray(sig.S) ? sig.S : sig.Sencoded;
      }
      cachedProperty(Signature, "S", function S() {
        return this.eddsa.decodeInt(this.Sencoded());
      });
      cachedProperty(Signature, "R", function R() {
        return this.eddsa.decodePoint(this.Rencoded());
      });
      cachedProperty(Signature, "Rencoded", function Rencoded() {
        return this.eddsa.encodePoint(this.R());
      });
      cachedProperty(Signature, "Sencoded", function Sencoded() {
        return this.eddsa.encodeInt(this.S());
      });
      Signature.prototype.toBytes = function toBytes() {
        return this.Rencoded().concat(this.Sencoded());
      };
      Signature.prototype.toHex = function toHex2() {
        return utils2.encode(this.toBytes(), "hex").toUpperCase();
      };
      signature = Signature;
      return signature;
    }
    var eddsa;
    var hasRequiredEddsa;
    function requireEddsa() {
      if (hasRequiredEddsa)
        return eddsa;
      hasRequiredEddsa = 1;
      var hash2 = requireHash();
      var curves2 = requireCurves();
      var utils2 = requireUtils$1();
      var assert2 = utils2.assert;
      var parseBytes = utils2.parseBytes;
      var KeyPair = requireKey();
      var Signature = requireSignature();
      function EDDSA(curve2) {
        assert2(curve2 === "ed25519", "only tested with ed25519 so far");
        if (!(this instanceof EDDSA))
          return new EDDSA(curve2);
        curve2 = curves2[curve2].curve;
        this.curve = curve2;
        this.g = curve2.g;
        this.g.precompute(curve2.n.bitLength() + 1);
        this.pointClass = curve2.point().constructor;
        this.encodingLength = Math.ceil(curve2.n.bitLength() / 8);
        this.hash = hash2.sha512;
      }
      eddsa = EDDSA;
      EDDSA.prototype.sign = function sign2(message, secret) {
        message = parseBytes(message);
        var key2 = this.keyFromSecret(secret);
        var r = this.hashInt(key2.messagePrefix(), message);
        var R = this.g.mul(r);
        var Rencoded = this.encodePoint(R);
        var s_ = this.hashInt(Rencoded, key2.pubBytes(), message).mul(key2.priv());
        var S = r.add(s_).umod(this.curve.n);
        return this.makeSignature({R, S, Rencoded});
      };
      EDDSA.prototype.verify = function verify(message, sig, pub) {
        message = parseBytes(message);
        sig = this.makeSignature(sig);
        var key2 = this.keyFromPublic(pub);
        var h = this.hashInt(sig.Rencoded(), key2.pubBytes(), message);
        var SG = this.g.mul(sig.S());
        var RplusAh = sig.R().add(key2.pub().mul(h));
        return RplusAh.eq(SG);
      };
      EDDSA.prototype.hashInt = function hashInt() {
        var hash3 = this.hash();
        for (var i = 0; i < arguments.length; i++)
          hash3.update(arguments[i]);
        return utils2.intFromLE(hash3.digest()).umod(this.curve.n);
      };
      EDDSA.prototype.keyFromPublic = function keyFromPublic(pub) {
        return KeyPair.fromPublic(this, pub);
      };
      EDDSA.prototype.keyFromSecret = function keyFromSecret(secret) {
        return KeyPair.fromSecret(this, secret);
      };
      EDDSA.prototype.makeSignature = function makeSignature(sig) {
        if (sig instanceof Signature)
          return sig;
        return new Signature(this, sig);
      };
      EDDSA.prototype.encodePoint = function encodePoint(point) {
        var enc = point.getY().toArray("le", this.encodingLength);
        enc[this.encodingLength - 1] |= point.getX().isOdd() ? 128 : 0;
        return enc;
      };
      EDDSA.prototype.decodePoint = function decodePoint(bytes) {
        bytes = utils2.parseBytes(bytes);
        var lastIx = bytes.length - 1;
        var normed = bytes.slice(0, lastIx).concat(bytes[lastIx] & ~128);
        var xIsOdd = (bytes[lastIx] & 128) !== 0;
        var y = utils2.intFromLE(normed);
        return this.curve.pointFromY(y, xIsOdd);
      };
      EDDSA.prototype.encodeInt = function encodeInt(num) {
        return num.toArray("le", this.encodingLength);
      };
      EDDSA.prototype.decodeInt = function decodeInt(bytes) {
        return utils2.intFromLE(bytes);
      };
      EDDSA.prototype.isPoint = function isPoint(val) {
        return val instanceof this.pointClass;
      };
      return eddsa;
    }
    var hasRequiredElliptic;
    function requireElliptic() {
      if (hasRequiredElliptic)
        return elliptic;
      hasRequiredElliptic = 1;
      (function(exports2) {
        var elliptic2 = exports2;
        elliptic2.version = require$$0.version;
        elliptic2.utils = requireUtils$1();
        elliptic2.rand = requireBrorand();
        elliptic2.curve = requireCurve();
        elliptic2.curves = requireCurves();
        elliptic2.ec = requireEc();
        elliptic2.eddsa = requireEddsa();
      })(elliptic);
      return elliptic;
    }
    var asn1$1 = {};
    var asn1 = {};
    var api = {};
    var encoders = {};
    var safer_1;
    var hasRequiredSafer;
    function requireSafer() {
      if (hasRequiredSafer)
        return safer_1;
      hasRequiredSafer = 1;
      var buffer2 = require$$6$1;
      var Buffer2 = buffer2.Buffer;
      var safer = {};
      var key2;
      for (key2 in buffer2) {
        if (!buffer2.hasOwnProperty(key2))
          continue;
        if (key2 === "SlowBuffer" || key2 === "Buffer")
          continue;
        safer[key2] = buffer2[key2];
      }
      var Safer = safer.Buffer = {};
      for (key2 in Buffer2) {
        if (!Buffer2.hasOwnProperty(key2))
          continue;
        if (key2 === "allocUnsafe" || key2 === "allocUnsafeSlow")
          continue;
        Safer[key2] = Buffer2[key2];
      }
      safer.Buffer.prototype = Buffer2.prototype;
      if (!Safer.from || Safer.from === Uint8Array.from) {
        Safer.from = function(value, encodingOrOffset, length2) {
          if (typeof value === "number") {
            throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof value);
          }
          if (value && typeof value.length === "undefined") {
            throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
          }
          return Buffer2(value, encodingOrOffset, length2);
        };
      }
      if (!Safer.alloc) {
        Safer.alloc = function(size, fill, encoding) {
          if (typeof size !== "number") {
            throw new TypeError('The "size" argument must be of type number. Received type ' + typeof size);
          }
          if (size < 0 || size >= 2 * (1 << 30)) {
            throw new RangeError('The value "' + size + '" is invalid for option "size"');
          }
          var buf2 = Buffer2(size);
          if (!fill || fill.length === 0) {
            buf2.fill(0);
          } else if (typeof encoding === "string") {
            buf2.fill(fill, encoding);
          } else {
            buf2.fill(fill);
          }
          return buf2;
        };
      }
      if (!safer.kStringMaxLength) {
        try {
          safer.kStringMaxLength = process.binding("buffer").kStringMaxLength;
        } catch (e) {
        }
      }
      if (!safer.constants) {
        safer.constants = {
          MAX_LENGTH: safer.kMaxLength
        };
        if (safer.kStringMaxLength) {
          safer.constants.MAX_STRING_LENGTH = safer.kStringMaxLength;
        }
      }
      safer_1 = safer;
      return safer_1;
    }
    var reporter = {};
    var hasRequiredReporter;
    function requireReporter() {
      if (hasRequiredReporter)
        return reporter;
      hasRequiredReporter = 1;
      const inherits2 = require$$3$1;
      function Reporter(options) {
        this._reporterState = {
          obj: null,
          path: [],
          options: options || {},
          errors: []
        };
      }
      reporter.Reporter = Reporter;
      Reporter.prototype.isError = function isError2(obj) {
        return obj instanceof ReporterError;
      };
      Reporter.prototype.save = function save2() {
        const state2 = this._reporterState;
        return {obj: state2.obj, pathLen: state2.path.length};
      };
      Reporter.prototype.restore = function restore(data) {
        const state2 = this._reporterState;
        state2.obj = data.obj;
        state2.path = state2.path.slice(0, data.pathLen);
      };
      Reporter.prototype.enterKey = function enterKey(key2) {
        return this._reporterState.path.push(key2);
      };
      Reporter.prototype.exitKey = function exitKey(index2) {
        const state2 = this._reporterState;
        state2.path = state2.path.slice(0, index2 - 1);
      };
      Reporter.prototype.leaveKey = function leaveKey(index2, key2, value) {
        const state2 = this._reporterState;
        this.exitKey(index2);
        if (state2.obj !== null)
          state2.obj[key2] = value;
      };
      Reporter.prototype.path = function path() {
        return this._reporterState.path.join("/");
      };
      Reporter.prototype.enterObject = function enterObject() {
        const state2 = this._reporterState;
        const prev = state2.obj;
        state2.obj = {};
        return prev;
      };
      Reporter.prototype.leaveObject = function leaveObject(prev) {
        const state2 = this._reporterState;
        const now = state2.obj;
        state2.obj = prev;
        return now;
      };
      Reporter.prototype.error = function error(msg) {
        let err;
        const state2 = this._reporterState;
        const inherited = msg instanceof ReporterError;
        if (inherited) {
          err = msg;
        } else {
          err = new ReporterError(state2.path.map(function(elem) {
            return "[" + JSON.stringify(elem) + "]";
          }).join(""), msg.message || msg, msg.stack);
        }
        if (!state2.options.partial)
          throw err;
        if (!inherited)
          state2.errors.push(err);
        return err;
      };
      Reporter.prototype.wrapResult = function wrapResult(result) {
        const state2 = this._reporterState;
        if (!state2.options.partial)
          return result;
        return {
          result: this.isError(result) ? null : result,
          errors: state2.errors
        };
      };
      function ReporterError(path, msg) {
        this.path = path;
        this.rethrow(msg);
      }
      inherits2(ReporterError, Error);
      ReporterError.prototype.rethrow = function rethrow(msg) {
        this.message = msg + " at: " + (this.path || "(shallow)");
        if (Error.captureStackTrace)
          Error.captureStackTrace(this, ReporterError);
        if (!this.stack) {
          try {
            throw new Error(this.message);
          } catch (e) {
            this.stack = e.stack;
          }
        }
        return this;
      };
      return reporter;
    }
    var buffer = {};
    var hasRequiredBuffer;
    function requireBuffer() {
      if (hasRequiredBuffer)
        return buffer;
      hasRequiredBuffer = 1;
      const inherits2 = require$$3$1;
      const Reporter = requireReporter().Reporter;
      const Buffer2 = requireSafer().Buffer;
      function DecoderBuffer(base2, options) {
        Reporter.call(this, options);
        if (!Buffer2.isBuffer(base2)) {
          this.error("Input not Buffer");
          return;
        }
        this.base = base2;
        this.offset = 0;
        this.length = base2.length;
      }
      inherits2(DecoderBuffer, Reporter);
      buffer.DecoderBuffer = DecoderBuffer;
      DecoderBuffer.isDecoderBuffer = function isDecoderBuffer(data) {
        if (data instanceof DecoderBuffer) {
          return true;
        }
        const isCompatible = typeof data === "object" && Buffer2.isBuffer(data.base) && data.constructor.name === "DecoderBuffer" && typeof data.offset === "number" && typeof data.length === "number" && typeof data.save === "function" && typeof data.restore === "function" && typeof data.isEmpty === "function" && typeof data.readUInt8 === "function" && typeof data.skip === "function" && typeof data.raw === "function";
        return isCompatible;
      };
      DecoderBuffer.prototype.save = function save2() {
        return {offset: this.offset, reporter: Reporter.prototype.save.call(this)};
      };
      DecoderBuffer.prototype.restore = function restore(save2) {
        const res = new DecoderBuffer(this.base);
        res.offset = save2.offset;
        res.length = this.offset;
        this.offset = save2.offset;
        Reporter.prototype.restore.call(this, save2.reporter);
        return res;
      };
      DecoderBuffer.prototype.isEmpty = function isEmpty() {
        return this.offset === this.length;
      };
      DecoderBuffer.prototype.readUInt8 = function readUInt8(fail) {
        if (this.offset + 1 <= this.length)
          return this.base.readUInt8(this.offset++, true);
        else
          return this.error(fail || "DecoderBuffer overrun");
      };
      DecoderBuffer.prototype.skip = function skip(bytes, fail) {
        if (!(this.offset + bytes <= this.length))
          return this.error(fail || "DecoderBuffer overrun");
        const res = new DecoderBuffer(this.base);
        res._reporterState = this._reporterState;
        res.offset = this.offset;
        res.length = this.offset + bytes;
        this.offset += bytes;
        return res;
      };
      DecoderBuffer.prototype.raw = function raw2(save2) {
        return this.base.slice(save2 ? save2.offset : this.offset, this.length);
      };
      function EncoderBuffer(value, reporter2) {
        if (Array.isArray(value)) {
          this.length = 0;
          this.value = value.map(function(item) {
            if (!EncoderBuffer.isEncoderBuffer(item))
              item = new EncoderBuffer(item, reporter2);
            this.length += item.length;
            return item;
          }, this);
        } else if (typeof value === "number") {
          if (!(0 <= value && value <= 255))
            return reporter2.error("non-byte EncoderBuffer value");
          this.value = value;
          this.length = 1;
        } else if (typeof value === "string") {
          this.value = value;
          this.length = Buffer2.byteLength(value);
        } else if (Buffer2.isBuffer(value)) {
          this.value = value;
          this.length = value.length;
        } else {
          return reporter2.error("Unsupported type: " + typeof value);
        }
      }
      buffer.EncoderBuffer = EncoderBuffer;
      EncoderBuffer.isEncoderBuffer = function isEncoderBuffer(data) {
        if (data instanceof EncoderBuffer) {
          return true;
        }
        const isCompatible = typeof data === "object" && data.constructor.name === "EncoderBuffer" && typeof data.length === "number" && typeof data.join === "function";
        return isCompatible;
      };
      EncoderBuffer.prototype.join = function join(out, offset) {
        if (!out)
          out = Buffer2.alloc(this.length);
        if (!offset)
          offset = 0;
        if (this.length === 0)
          return out;
        if (Array.isArray(this.value)) {
          this.value.forEach(function(item) {
            item.join(out, offset);
            offset += item.length;
          });
        } else {
          if (typeof this.value === "number")
            out[offset] = this.value;
          else if (typeof this.value === "string")
            out.write(this.value, offset);
          else if (Buffer2.isBuffer(this.value))
            this.value.copy(out, offset);
          offset += this.length;
        }
        return out;
      };
      return buffer;
    }
    var node;
    var hasRequiredNode;
    function requireNode() {
      if (hasRequiredNode)
        return node;
      hasRequiredNode = 1;
      const Reporter = requireReporter().Reporter;
      const EncoderBuffer = requireBuffer().EncoderBuffer;
      const DecoderBuffer = requireBuffer().DecoderBuffer;
      const assert2 = requireMinimalisticAssert();
      const tags = [
        "seq",
        "seqof",
        "set",
        "setof",
        "objid",
        "bool",
        "gentime",
        "utctime",
        "null_",
        "enum",
        "int",
        "objDesc",
        "bitstr",
        "bmpstr",
        "charstr",
        "genstr",
        "graphstr",
        "ia5str",
        "iso646str",
        "numstr",
        "octstr",
        "printstr",
        "t61str",
        "unistr",
        "utf8str",
        "videostr"
      ];
      const methods = [
        "key",
        "obj",
        "use",
        "optional",
        "explicit",
        "implicit",
        "def",
        "choice",
        "any",
        "contains"
      ].concat(tags);
      const overrided = [
        "_peekTag",
        "_decodeTag",
        "_use",
        "_decodeStr",
        "_decodeObjid",
        "_decodeTime",
        "_decodeNull",
        "_decodeInt",
        "_decodeBool",
        "_decodeList",
        "_encodeComposite",
        "_encodeStr",
        "_encodeObjid",
        "_encodeTime",
        "_encodeNull",
        "_encodeInt",
        "_encodeBool"
      ];
      function Node2(enc, parent, name2) {
        const state2 = {};
        this._baseState = state2;
        state2.name = name2;
        state2.enc = enc;
        state2.parent = parent || null;
        state2.children = null;
        state2.tag = null;
        state2.args = null;
        state2.reverseArgs = null;
        state2.choice = null;
        state2.optional = false;
        state2.any = false;
        state2.obj = false;
        state2.use = null;
        state2.useDecoder = null;
        state2.key = null;
        state2["default"] = null;
        state2.explicit = null;
        state2.implicit = null;
        state2.contains = null;
        if (!state2.parent) {
          state2.children = [];
          this._wrap();
        }
      }
      node = Node2;
      const stateProps = [
        "enc",
        "parent",
        "children",
        "tag",
        "args",
        "reverseArgs",
        "choice",
        "optional",
        "any",
        "obj",
        "use",
        "alteredUse",
        "key",
        "default",
        "explicit",
        "implicit",
        "contains"
      ];
      Node2.prototype.clone = function clone() {
        const state2 = this._baseState;
        const cstate = {};
        stateProps.forEach(function(prop) {
          cstate[prop] = state2[prop];
        });
        const res = new this.constructor(cstate.parent);
        res._baseState = cstate;
        return res;
      };
      Node2.prototype._wrap = function wrap2() {
        const state2 = this._baseState;
        methods.forEach(function(method2) {
          this[method2] = function _wrappedMethod() {
            const clone = new this.constructor(this);
            state2.children.push(clone);
            return clone[method2].apply(clone, arguments);
          };
        }, this);
      };
      Node2.prototype._init = function init2(body) {
        const state2 = this._baseState;
        assert2(state2.parent === null);
        body.call(this);
        state2.children = state2.children.filter(function(child) {
          return child._baseState.parent === this;
        }, this);
        assert2.equal(state2.children.length, 1, "Root node can have only one child");
      };
      Node2.prototype._useArgs = function useArgs(args) {
        const state2 = this._baseState;
        const children = args.filter(function(arg) {
          return arg instanceof this.constructor;
        }, this);
        args = args.filter(function(arg) {
          return !(arg instanceof this.constructor);
        }, this);
        if (children.length !== 0) {
          assert2(state2.children === null);
          state2.children = children;
          children.forEach(function(child) {
            child._baseState.parent = this;
          }, this);
        }
        if (args.length !== 0) {
          assert2(state2.args === null);
          state2.args = args;
          state2.reverseArgs = args.map(function(arg) {
            if (typeof arg !== "object" || arg.constructor !== Object)
              return arg;
            const res = {};
            Object.keys(arg).forEach(function(key2) {
              if (key2 == (key2 | 0))
                key2 |= 0;
              const value = arg[key2];
              res[value] = key2;
            });
            return res;
          });
        }
      };
      overrided.forEach(function(method2) {
        Node2.prototype[method2] = function _overrided() {
          const state2 = this._baseState;
          throw new Error(method2 + " not implemented for encoding: " + state2.enc);
        };
      });
      tags.forEach(function(tag) {
        Node2.prototype[tag] = function _tagMethod() {
          const state2 = this._baseState;
          const args = Array.prototype.slice.call(arguments);
          assert2(state2.tag === null);
          state2.tag = tag;
          this._useArgs(args);
          return this;
        };
      });
      Node2.prototype.use = function use(item) {
        assert2(item);
        const state2 = this._baseState;
        assert2(state2.use === null);
        state2.use = item;
        return this;
      };
      Node2.prototype.optional = function optional() {
        const state2 = this._baseState;
        state2.optional = true;
        return this;
      };
      Node2.prototype.def = function def(val) {
        const state2 = this._baseState;
        assert2(state2["default"] === null);
        state2["default"] = val;
        state2.optional = true;
        return this;
      };
      Node2.prototype.explicit = function explicit(num) {
        const state2 = this._baseState;
        assert2(state2.explicit === null && state2.implicit === null);
        state2.explicit = num;
        return this;
      };
      Node2.prototype.implicit = function implicit(num) {
        const state2 = this._baseState;
        assert2(state2.explicit === null && state2.implicit === null);
        state2.implicit = num;
        return this;
      };
      Node2.prototype.obj = function obj() {
        const state2 = this._baseState;
        const args = Array.prototype.slice.call(arguments);
        state2.obj = true;
        if (args.length !== 0)
          this._useArgs(args);
        return this;
      };
      Node2.prototype.key = function key2(newKey) {
        const state2 = this._baseState;
        assert2(state2.key === null);
        state2.key = newKey;
        return this;
      };
      Node2.prototype.any = function any() {
        const state2 = this._baseState;
        state2.any = true;
        return this;
      };
      Node2.prototype.choice = function choice(obj) {
        const state2 = this._baseState;
        assert2(state2.choice === null);
        state2.choice = obj;
        this._useArgs(Object.keys(obj).map(function(key2) {
          return obj[key2];
        }));
        return this;
      };
      Node2.prototype.contains = function contains2(item) {
        const state2 = this._baseState;
        assert2(state2.use === null);
        state2.contains = item;
        return this;
      };
      Node2.prototype._decode = function decode2(input, options) {
        const state2 = this._baseState;
        if (state2.parent === null)
          return input.wrapResult(state2.children[0]._decode(input, options));
        let result = state2["default"];
        let present = true;
        let prevKey = null;
        if (state2.key !== null)
          prevKey = input.enterKey(state2.key);
        if (state2.optional) {
          let tag = null;
          if (state2.explicit !== null)
            tag = state2.explicit;
          else if (state2.implicit !== null)
            tag = state2.implicit;
          else if (state2.tag !== null)
            tag = state2.tag;
          if (tag === null && !state2.any) {
            const save2 = input.save();
            try {
              if (state2.choice === null)
                this._decodeGeneric(state2.tag, input, options);
              else
                this._decodeChoice(input, options);
              present = true;
            } catch (e) {
              present = false;
            }
            input.restore(save2);
          } else {
            present = this._peekTag(input, tag, state2.any);
            if (input.isError(present))
              return present;
          }
        }
        let prevObj;
        if (state2.obj && present)
          prevObj = input.enterObject();
        if (present) {
          if (state2.explicit !== null) {
            const explicit = this._decodeTag(input, state2.explicit);
            if (input.isError(explicit))
              return explicit;
            input = explicit;
          }
          const start = input.offset;
          if (state2.use === null && state2.choice === null) {
            let save2;
            if (state2.any)
              save2 = input.save();
            const body = this._decodeTag(input, state2.implicit !== null ? state2.implicit : state2.tag, state2.any);
            if (input.isError(body))
              return body;
            if (state2.any)
              result = input.raw(save2);
            else
              input = body;
          }
          if (options && options.track && state2.tag !== null)
            options.track(input.path(), start, input.length, "tagged");
          if (options && options.track && state2.tag !== null)
            options.track(input.path(), input.offset, input.length, "content");
          if (state2.any)
            ;
          else if (state2.choice === null) {
            result = this._decodeGeneric(state2.tag, input, options);
          } else {
            result = this._decodeChoice(input, options);
          }
          if (input.isError(result))
            return result;
          if (!state2.any && state2.choice === null && state2.children !== null) {
            state2.children.forEach(function decodeChildren(child) {
              child._decode(input, options);
            });
          }
          if (state2.contains && (state2.tag === "octstr" || state2.tag === "bitstr")) {
            const data = new DecoderBuffer(result);
            result = this._getUse(state2.contains, input._reporterState.obj)._decode(data, options);
          }
        }
        if (state2.obj && present)
          result = input.leaveObject(prevObj);
        if (state2.key !== null && (result !== null || present === true))
          input.leaveKey(prevKey, state2.key, result);
        else if (prevKey !== null)
          input.exitKey(prevKey);
        return result;
      };
      Node2.prototype._decodeGeneric = function decodeGeneric(tag, input, options) {
        const state2 = this._baseState;
        if (tag === "seq" || tag === "set")
          return null;
        if (tag === "seqof" || tag === "setof")
          return this._decodeList(input, tag, state2.args[0], options);
        else if (/str$/.test(tag))
          return this._decodeStr(input, tag, options);
        else if (tag === "objid" && state2.args)
          return this._decodeObjid(input, state2.args[0], state2.args[1], options);
        else if (tag === "objid")
          return this._decodeObjid(input, null, null, options);
        else if (tag === "gentime" || tag === "utctime")
          return this._decodeTime(input, tag, options);
        else if (tag === "null_")
          return this._decodeNull(input, options);
        else if (tag === "bool")
          return this._decodeBool(input, options);
        else if (tag === "objDesc")
          return this._decodeStr(input, tag, options);
        else if (tag === "int" || tag === "enum")
          return this._decodeInt(input, state2.args && state2.args[0], options);
        if (state2.use !== null) {
          return this._getUse(state2.use, input._reporterState.obj)._decode(input, options);
        } else {
          return input.error("unknown tag: " + tag);
        }
      };
      Node2.prototype._getUse = function _getUse(entity, obj) {
        const state2 = this._baseState;
        state2.useDecoder = this._use(entity, obj);
        assert2(state2.useDecoder._baseState.parent === null);
        state2.useDecoder = state2.useDecoder._baseState.children[0];
        if (state2.implicit !== state2.useDecoder._baseState.implicit) {
          state2.useDecoder = state2.useDecoder.clone();
          state2.useDecoder._baseState.implicit = state2.implicit;
        }
        return state2.useDecoder;
      };
      Node2.prototype._decodeChoice = function decodeChoice(input, options) {
        const state2 = this._baseState;
        let result = null;
        let match = false;
        Object.keys(state2.choice).some(function(key2) {
          const save2 = input.save();
          const node2 = state2.choice[key2];
          try {
            const value = node2._decode(input, options);
            if (input.isError(value))
              return false;
            result = {type: key2, value};
            match = true;
          } catch (e) {
            input.restore(save2);
            return false;
          }
          return true;
        }, this);
        if (!match)
          return input.error("Choice not matched");
        return result;
      };
      Node2.prototype._createEncoderBuffer = function createEncoderBuffer(data) {
        return new EncoderBuffer(data, this.reporter);
      };
      Node2.prototype._encode = function encode2(data, reporter2, parent) {
        const state2 = this._baseState;
        if (state2["default"] !== null && state2["default"] === data)
          return;
        const result = this._encodeValue(data, reporter2, parent);
        if (result === void 0)
          return;
        if (this._skipDefault(result, reporter2, parent))
          return;
        return result;
      };
      Node2.prototype._encodeValue = function encode2(data, reporter2, parent) {
        const state2 = this._baseState;
        if (state2.parent === null)
          return state2.children[0]._encode(data, reporter2 || new Reporter());
        let result = null;
        this.reporter = reporter2;
        if (state2.optional && data === void 0) {
          if (state2["default"] !== null)
            data = state2["default"];
          else
            return;
        }
        let content = null;
        let primitive = false;
        if (state2.any) {
          result = this._createEncoderBuffer(data);
        } else if (state2.choice) {
          result = this._encodeChoice(data, reporter2);
        } else if (state2.contains) {
          content = this._getUse(state2.contains, parent)._encode(data, reporter2);
          primitive = true;
        } else if (state2.children) {
          content = state2.children.map(function(child) {
            if (child._baseState.tag === "null_")
              return child._encode(null, reporter2, data);
            if (child._baseState.key === null)
              return reporter2.error("Child should have a key");
            const prevKey = reporter2.enterKey(child._baseState.key);
            if (typeof data !== "object")
              return reporter2.error("Child expected, but input is not object");
            const res = child._encode(data[child._baseState.key], reporter2, data);
            reporter2.leaveKey(prevKey);
            return res;
          }, this).filter(function(child) {
            return child;
          });
          content = this._createEncoderBuffer(content);
        } else {
          if (state2.tag === "seqof" || state2.tag === "setof") {
            if (!(state2.args && state2.args.length === 1))
              return reporter2.error("Too many args for : " + state2.tag);
            if (!Array.isArray(data))
              return reporter2.error("seqof/setof, but data is not Array");
            const child = this.clone();
            child._baseState.implicit = null;
            content = this._createEncoderBuffer(data.map(function(item) {
              const state3 = this._baseState;
              return this._getUse(state3.args[0], data)._encode(item, reporter2);
            }, child));
          } else if (state2.use !== null) {
            result = this._getUse(state2.use, parent)._encode(data, reporter2);
          } else {
            content = this._encodePrimitive(state2.tag, data);
            primitive = true;
          }
        }
        if (!state2.any && state2.choice === null) {
          const tag = state2.implicit !== null ? state2.implicit : state2.tag;
          const cls = state2.implicit === null ? "universal" : "context";
          if (tag === null) {
            if (state2.use === null)
              reporter2.error("Tag could be omitted only for .use()");
          } else {
            if (state2.use === null)
              result = this._encodeComposite(tag, primitive, cls, content);
          }
        }
        if (state2.explicit !== null)
          result = this._encodeComposite(state2.explicit, false, "context", result);
        return result;
      };
      Node2.prototype._encodeChoice = function encodeChoice(data, reporter2) {
        const state2 = this._baseState;
        const node2 = state2.choice[data.type];
        if (!node2) {
          assert2(false, data.type + " not found in " + JSON.stringify(Object.keys(state2.choice)));
        }
        return node2._encode(data.value, reporter2);
      };
      Node2.prototype._encodePrimitive = function encodePrimitive(tag, data) {
        const state2 = this._baseState;
        if (/str$/.test(tag))
          return this._encodeStr(data, tag);
        else if (tag === "objid" && state2.args)
          return this._encodeObjid(data, state2.reverseArgs[0], state2.args[1]);
        else if (tag === "objid")
          return this._encodeObjid(data, null, null);
        else if (tag === "gentime" || tag === "utctime")
          return this._encodeTime(data, tag);
        else if (tag === "null_")
          return this._encodeNull();
        else if (tag === "int" || tag === "enum")
          return this._encodeInt(data, state2.args && state2.reverseArgs[0]);
        else if (tag === "bool")
          return this._encodeBool(data);
        else if (tag === "objDesc")
          return this._encodeStr(data, tag);
        else
          throw new Error("Unsupported tag: " + tag);
      };
      Node2.prototype._isNumstr = function isNumstr(str) {
        return /^[0-9 ]*$/.test(str);
      };
      Node2.prototype._isPrintstr = function isPrintstr(str) {
        return /^[A-Za-z0-9 '()+,-./:=?]*$/.test(str);
      };
      return node;
    }
    var der = {};
    var hasRequiredDer$2;
    function requireDer$2() {
      if (hasRequiredDer$2)
        return der;
      hasRequiredDer$2 = 1;
      (function(exports2) {
        function reverse(map) {
          const res = {};
          Object.keys(map).forEach(function(key2) {
            if ((key2 | 0) == key2)
              key2 = key2 | 0;
            const value = map[key2];
            res[value] = key2;
          });
          return res;
        }
        exports2.tagClass = {
          0: "universal",
          1: "application",
          2: "context",
          3: "private"
        };
        exports2.tagClassByName = reverse(exports2.tagClass);
        exports2.tag = {
          0: "end",
          1: "bool",
          2: "int",
          3: "bitstr",
          4: "octstr",
          5: "null_",
          6: "objid",
          7: "objDesc",
          8: "external",
          9: "real",
          10: "enum",
          11: "embed",
          12: "utf8str",
          13: "relativeOid",
          16: "seq",
          17: "set",
          18: "numstr",
          19: "printstr",
          20: "t61str",
          21: "videostr",
          22: "ia5str",
          23: "utctime",
          24: "gentime",
          25: "graphstr",
          26: "iso646str",
          27: "genstr",
          28: "unistr",
          29: "charstr",
          30: "bmpstr"
        };
        exports2.tagByName = reverse(exports2.tag);
      })(der);
      return der;
    }
    var der_1$1;
    var hasRequiredDer$1;
    function requireDer$1() {
      if (hasRequiredDer$1)
        return der_1$1;
      hasRequiredDer$1 = 1;
      const inherits2 = require$$3$1;
      const Buffer2 = requireSafer().Buffer;
      const Node2 = requireNode();
      const der2 = requireDer$2();
      function DEREncoder(entity) {
        this.enc = "der";
        this.name = entity.name;
        this.entity = entity;
        this.tree = new DERNode();
        this.tree._init(entity.body);
      }
      der_1$1 = DEREncoder;
      DEREncoder.prototype.encode = function encode2(data, reporter2) {
        return this.tree._encode(data, reporter2).join();
      };
      function DERNode(parent) {
        Node2.call(this, "der", parent);
      }
      inherits2(DERNode, Node2);
      DERNode.prototype._encodeComposite = function encodeComposite(tag, primitive, cls, content) {
        const encodedTag = encodeTag2(tag, primitive, cls, this.reporter);
        if (content.length < 128) {
          const header2 = Buffer2.alloc(2);
          header2[0] = encodedTag;
          header2[1] = content.length;
          return this._createEncoderBuffer([header2, content]);
        }
        let lenOctets = 1;
        for (let i = content.length; i >= 256; i >>= 8)
          lenOctets++;
        const header = Buffer2.alloc(1 + 1 + lenOctets);
        header[0] = encodedTag;
        header[1] = 128 | lenOctets;
        for (let i = 1 + lenOctets, j = content.length; j > 0; i--, j >>= 8)
          header[i] = j & 255;
        return this._createEncoderBuffer([header, content]);
      };
      DERNode.prototype._encodeStr = function encodeStr(str, tag) {
        if (tag === "bitstr") {
          return this._createEncoderBuffer([str.unused | 0, str.data]);
        } else if (tag === "bmpstr") {
          const buf2 = Buffer2.alloc(str.length * 2);
          for (let i = 0; i < str.length; i++) {
            buf2.writeUInt16BE(str.charCodeAt(i), i * 2);
          }
          return this._createEncoderBuffer(buf2);
        } else if (tag === "numstr") {
          if (!this._isNumstr(str)) {
            return this.reporter.error("Encoding of string type: numstr supports only digits and space");
          }
          return this._createEncoderBuffer(str);
        } else if (tag === "printstr") {
          if (!this._isPrintstr(str)) {
            return this.reporter.error("Encoding of string type: printstr supports only latin upper and lower case letters, digits, space, apostrophe, left and rigth parenthesis, plus sign, comma, hyphen, dot, slash, colon, equal sign, question mark");
          }
          return this._createEncoderBuffer(str);
        } else if (/str$/.test(tag)) {
          return this._createEncoderBuffer(str);
        } else if (tag === "objDesc") {
          return this._createEncoderBuffer(str);
        } else {
          return this.reporter.error("Encoding of string type: " + tag + " unsupported");
        }
      };
      DERNode.prototype._encodeObjid = function encodeObjid(id, values, relative) {
        if (typeof id === "string") {
          if (!values)
            return this.reporter.error("string objid given, but no values map found");
          if (!values.hasOwnProperty(id))
            return this.reporter.error("objid not found in values map");
          id = values[id].split(/[\s.]+/g);
          for (let i = 0; i < id.length; i++)
            id[i] |= 0;
        } else if (Array.isArray(id)) {
          id = id.slice();
          for (let i = 0; i < id.length; i++)
            id[i] |= 0;
        }
        if (!Array.isArray(id)) {
          return this.reporter.error("objid() should be either array or string, got: " + JSON.stringify(id));
        }
        if (!relative) {
          if (id[1] >= 40)
            return this.reporter.error("Second objid identifier OOB");
          id.splice(0, 2, id[0] * 40 + id[1]);
        }
        let size = 0;
        for (let i = 0; i < id.length; i++) {
          let ident = id[i];
          for (size++; ident >= 128; ident >>= 7)
            size++;
        }
        const objid = Buffer2.alloc(size);
        let offset = objid.length - 1;
        for (let i = id.length - 1; i >= 0; i--) {
          let ident = id[i];
          objid[offset--] = ident & 127;
          while ((ident >>= 7) > 0)
            objid[offset--] = 128 | ident & 127;
        }
        return this._createEncoderBuffer(objid);
      };
      function two(num) {
        if (num < 10)
          return "0" + num;
        else
          return num;
      }
      DERNode.prototype._encodeTime = function encodeTime(time, tag) {
        let str;
        const date = new Date(time);
        if (tag === "gentime") {
          str = [
            two(date.getUTCFullYear()),
            two(date.getUTCMonth() + 1),
            two(date.getUTCDate()),
            two(date.getUTCHours()),
            two(date.getUTCMinutes()),
            two(date.getUTCSeconds()),
            "Z"
          ].join("");
        } else if (tag === "utctime") {
          str = [
            two(date.getUTCFullYear() % 100),
            two(date.getUTCMonth() + 1),
            two(date.getUTCDate()),
            two(date.getUTCHours()),
            two(date.getUTCMinutes()),
            two(date.getUTCSeconds()),
            "Z"
          ].join("");
        } else {
          this.reporter.error("Encoding " + tag + " time is not supported yet");
        }
        return this._encodeStr(str, "octstr");
      };
      DERNode.prototype._encodeNull = function encodeNull() {
        return this._createEncoderBuffer("");
      };
      DERNode.prototype._encodeInt = function encodeInt(num, values) {
        if (typeof num === "string") {
          if (!values)
            return this.reporter.error("String int or enum given, but no values map");
          if (!values.hasOwnProperty(num)) {
            return this.reporter.error("Values map doesn't contain: " + JSON.stringify(num));
          }
          num = values[num];
        }
        if (typeof num !== "number" && !Buffer2.isBuffer(num)) {
          const numArray = num.toArray();
          if (!num.sign && numArray[0] & 128) {
            numArray.unshift(0);
          }
          num = Buffer2.from(numArray);
        }
        if (Buffer2.isBuffer(num)) {
          let size2 = num.length;
          if (num.length === 0)
            size2++;
          const out2 = Buffer2.alloc(size2);
          num.copy(out2);
          if (num.length === 0)
            out2[0] = 0;
          return this._createEncoderBuffer(out2);
        }
        if (num < 128)
          return this._createEncoderBuffer(num);
        if (num < 256)
          return this._createEncoderBuffer([0, num]);
        let size = 1;
        for (let i = num; i >= 256; i >>= 8)
          size++;
        const out = new Array(size);
        for (let i = out.length - 1; i >= 0; i--) {
          out[i] = num & 255;
          num >>= 8;
        }
        if (out[0] & 128) {
          out.unshift(0);
        }
        return this._createEncoderBuffer(Buffer2.from(out));
      };
      DERNode.prototype._encodeBool = function encodeBool(value) {
        return this._createEncoderBuffer(value ? 255 : 0);
      };
      DERNode.prototype._use = function use(entity, obj) {
        if (typeof entity === "function")
          entity = entity(obj);
        return entity._getEncoder("der").tree;
      };
      DERNode.prototype._skipDefault = function skipDefault(dataBuffer, reporter2, parent) {
        const state2 = this._baseState;
        let i;
        if (state2["default"] === null)
          return false;
        const data = dataBuffer.join();
        if (state2.defaultBuffer === void 0)
          state2.defaultBuffer = this._encodeValue(state2["default"], reporter2, parent).join();
        if (data.length !== state2.defaultBuffer.length)
          return false;
        for (i = 0; i < data.length; i++)
          if (data[i] !== state2.defaultBuffer[i])
            return false;
        return true;
      };
      function encodeTag2(tag, primitive, cls, reporter2) {
        let res;
        if (tag === "seqof")
          tag = "seq";
        else if (tag === "setof")
          tag = "set";
        if (der2.tagByName.hasOwnProperty(tag))
          res = der2.tagByName[tag];
        else if (typeof tag === "number" && (tag | 0) === tag)
          res = tag;
        else
          return reporter2.error("Unknown tag: " + tag);
        if (res >= 31)
          return reporter2.error("Multi-octet tag encoding unsupported");
        if (!primitive)
          res |= 32;
        res |= der2.tagClassByName[cls || "universal"] << 6;
        return res;
      }
      return der_1$1;
    }
    var pem$1;
    var hasRequiredPem$1;
    function requirePem$1() {
      if (hasRequiredPem$1)
        return pem$1;
      hasRequiredPem$1 = 1;
      const inherits2 = require$$3$1;
      const DEREncoder = requireDer$1();
      function PEMEncoder(entity) {
        DEREncoder.call(this, entity);
        this.enc = "pem";
      }
      inherits2(PEMEncoder, DEREncoder);
      pem$1 = PEMEncoder;
      PEMEncoder.prototype.encode = function encode2(data, options) {
        const buf2 = DEREncoder.prototype.encode.call(this, data);
        const p = buf2.toString("base64");
        const out = ["-----BEGIN " + options.label + "-----"];
        for (let i = 0; i < p.length; i += 64)
          out.push(p.slice(i, i + 64));
        out.push("-----END " + options.label + "-----");
        return out.join("\n");
      };
      return pem$1;
    }
    var hasRequiredEncoders;
    function requireEncoders() {
      if (hasRequiredEncoders)
        return encoders;
      hasRequiredEncoders = 1;
      (function(exports2) {
        const encoders2 = exports2;
        encoders2.der = requireDer$1();
        encoders2.pem = requirePem$1();
      })(encoders);
      return encoders;
    }
    var decoders = {};
    var der_1;
    var hasRequiredDer;
    function requireDer() {
      if (hasRequiredDer)
        return der_1;
      hasRequiredDer = 1;
      const inherits2 = require$$3$1;
      const bignum = requireBn$1();
      const DecoderBuffer = requireBuffer().DecoderBuffer;
      const Node2 = requireNode();
      const der2 = requireDer$2();
      function DERDecoder(entity) {
        this.enc = "der";
        this.name = entity.name;
        this.entity = entity;
        this.tree = new DERNode();
        this.tree._init(entity.body);
      }
      der_1 = DERDecoder;
      DERDecoder.prototype.decode = function decode2(data, options) {
        if (!DecoderBuffer.isDecoderBuffer(data)) {
          data = new DecoderBuffer(data, options);
        }
        return this.tree._decode(data, options);
      };
      function DERNode(parent) {
        Node2.call(this, "der", parent);
      }
      inherits2(DERNode, Node2);
      DERNode.prototype._peekTag = function peekTag(buffer2, tag, any) {
        if (buffer2.isEmpty())
          return false;
        const state2 = buffer2.save();
        const decodedTag = derDecodeTag(buffer2, 'Failed to peek tag: "' + tag + '"');
        if (buffer2.isError(decodedTag))
          return decodedTag;
        buffer2.restore(state2);
        return decodedTag.tag === tag || decodedTag.tagStr === tag || decodedTag.tagStr + "of" === tag || any;
      };
      DERNode.prototype._decodeTag = function decodeTag(buffer2, tag, any) {
        const decodedTag = derDecodeTag(buffer2, 'Failed to decode tag of "' + tag + '"');
        if (buffer2.isError(decodedTag))
          return decodedTag;
        let len = derDecodeLen(buffer2, decodedTag.primitive, 'Failed to get length of "' + tag + '"');
        if (buffer2.isError(len))
          return len;
        if (!any && decodedTag.tag !== tag && decodedTag.tagStr !== tag && decodedTag.tagStr + "of" !== tag) {
          return buffer2.error('Failed to match tag: "' + tag + '"');
        }
        if (decodedTag.primitive || len !== null)
          return buffer2.skip(len, 'Failed to match body of: "' + tag + '"');
        const state2 = buffer2.save();
        const res = this._skipUntilEnd(buffer2, 'Failed to skip indefinite length body: "' + this.tag + '"');
        if (buffer2.isError(res))
          return res;
        len = buffer2.offset - state2.offset;
        buffer2.restore(state2);
        return buffer2.skip(len, 'Failed to match body of: "' + tag + '"');
      };
      DERNode.prototype._skipUntilEnd = function skipUntilEnd(buffer2, fail) {
        for (; ; ) {
          const tag = derDecodeTag(buffer2, fail);
          if (buffer2.isError(tag))
            return tag;
          const len = derDecodeLen(buffer2, tag.primitive, fail);
          if (buffer2.isError(len))
            return len;
          let res;
          if (tag.primitive || len !== null)
            res = buffer2.skip(len);
          else
            res = this._skipUntilEnd(buffer2, fail);
          if (buffer2.isError(res))
            return res;
          if (tag.tagStr === "end")
            break;
        }
      };
      DERNode.prototype._decodeList = function decodeList(buffer2, tag, decoder, options) {
        const result = [];
        while (!buffer2.isEmpty()) {
          const possibleEnd = this._peekTag(buffer2, "end");
          if (buffer2.isError(possibleEnd))
            return possibleEnd;
          const res = decoder.decode(buffer2, "der", options);
          if (buffer2.isError(res) && possibleEnd)
            break;
          result.push(res);
        }
        return result;
      };
      DERNode.prototype._decodeStr = function decodeStr(buffer2, tag) {
        if (tag === "bitstr") {
          const unused = buffer2.readUInt8();
          if (buffer2.isError(unused))
            return unused;
          return {unused, data: buffer2.raw()};
        } else if (tag === "bmpstr") {
          const raw2 = buffer2.raw();
          if (raw2.length % 2 === 1)
            return buffer2.error("Decoding of string type: bmpstr length mismatch");
          let str = "";
          for (let i = 0; i < raw2.length / 2; i++) {
            str += String.fromCharCode(raw2.readUInt16BE(i * 2));
          }
          return str;
        } else if (tag === "numstr") {
          const numstr = buffer2.raw().toString("ascii");
          if (!this._isNumstr(numstr)) {
            return buffer2.error("Decoding of string type: numstr unsupported characters");
          }
          return numstr;
        } else if (tag === "octstr") {
          return buffer2.raw();
        } else if (tag === "objDesc") {
          return buffer2.raw();
        } else if (tag === "printstr") {
          const printstr = buffer2.raw().toString("ascii");
          if (!this._isPrintstr(printstr)) {
            return buffer2.error("Decoding of string type: printstr unsupported characters");
          }
          return printstr;
        } else if (/str$/.test(tag)) {
          return buffer2.raw().toString();
        } else {
          return buffer2.error("Decoding of string type: " + tag + " unsupported");
        }
      };
      DERNode.prototype._decodeObjid = function decodeObjid(buffer2, values, relative) {
        let result;
        const identifiers = [];
        let ident = 0;
        let subident = 0;
        while (!buffer2.isEmpty()) {
          subident = buffer2.readUInt8();
          ident <<= 7;
          ident |= subident & 127;
          if ((subident & 128) === 0) {
            identifiers.push(ident);
            ident = 0;
          }
        }
        if (subident & 128)
          identifiers.push(ident);
        const first = identifiers[0] / 40 | 0;
        const second = identifiers[0] % 40;
        if (relative)
          result = identifiers;
        else
          result = [first, second].concat(identifiers.slice(1));
        if (values) {
          let tmp = values[result.join(" ")];
          if (tmp === void 0)
            tmp = values[result.join(".")];
          if (tmp !== void 0)
            result = tmp;
        }
        return result;
      };
      DERNode.prototype._decodeTime = function decodeTime(buffer2, tag) {
        const str = buffer2.raw().toString();
        let year;
        let mon;
        let day;
        let hour;
        let min;
        let sec;
        if (tag === "gentime") {
          year = str.slice(0, 4) | 0;
          mon = str.slice(4, 6) | 0;
          day = str.slice(6, 8) | 0;
          hour = str.slice(8, 10) | 0;
          min = str.slice(10, 12) | 0;
          sec = str.slice(12, 14) | 0;
        } else if (tag === "utctime") {
          year = str.slice(0, 2) | 0;
          mon = str.slice(2, 4) | 0;
          day = str.slice(4, 6) | 0;
          hour = str.slice(6, 8) | 0;
          min = str.slice(8, 10) | 0;
          sec = str.slice(10, 12) | 0;
          if (year < 70)
            year = 2e3 + year;
          else
            year = 1900 + year;
        } else {
          return buffer2.error("Decoding " + tag + " time is not supported yet");
        }
        return Date.UTC(year, mon - 1, day, hour, min, sec, 0);
      };
      DERNode.prototype._decodeNull = function decodeNull() {
        return null;
      };
      DERNode.prototype._decodeBool = function decodeBool(buffer2) {
        const res = buffer2.readUInt8();
        if (buffer2.isError(res))
          return res;
        else
          return res !== 0;
      };
      DERNode.prototype._decodeInt = function decodeInt(buffer2, values) {
        const raw2 = buffer2.raw();
        let res = new bignum(raw2);
        if (values)
          res = values[res.toString(10)] || res;
        return res;
      };
      DERNode.prototype._use = function use(entity, obj) {
        if (typeof entity === "function")
          entity = entity(obj);
        return entity._getDecoder("der").tree;
      };
      function derDecodeTag(buf2, fail) {
        let tag = buf2.readUInt8(fail);
        if (buf2.isError(tag))
          return tag;
        const cls = der2.tagClass[tag >> 6];
        const primitive = (tag & 32) === 0;
        if ((tag & 31) === 31) {
          let oct = tag;
          tag = 0;
          while ((oct & 128) === 128) {
            oct = buf2.readUInt8(fail);
            if (buf2.isError(oct))
              return oct;
            tag <<= 7;
            tag |= oct & 127;
          }
        } else {
          tag &= 31;
        }
        const tagStr = der2.tag[tag];
        return {
          cls,
          primitive,
          tag,
          tagStr
        };
      }
      function derDecodeLen(buf2, primitive, fail) {
        let len = buf2.readUInt8(fail);
        if (buf2.isError(len))
          return len;
        if (!primitive && len === 128)
          return null;
        if ((len & 128) === 0) {
          return len;
        }
        const num = len & 127;
        if (num > 4)
          return buf2.error("length octect is too long");
        len = 0;
        for (let i = 0; i < num; i++) {
          len <<= 8;
          const j = buf2.readUInt8(fail);
          if (buf2.isError(j))
            return j;
          len |= j;
        }
        return len;
      }
      return der_1;
    }
    var pem;
    var hasRequiredPem;
    function requirePem() {
      if (hasRequiredPem)
        return pem;
      hasRequiredPem = 1;
      const inherits2 = require$$3$1;
      const Buffer2 = requireSafer().Buffer;
      const DERDecoder = requireDer();
      function PEMDecoder(entity) {
        DERDecoder.call(this, entity);
        this.enc = "pem";
      }
      inherits2(PEMDecoder, DERDecoder);
      pem = PEMDecoder;
      PEMDecoder.prototype.decode = function decode2(data, options) {
        const lines = data.toString().split(/[\r\n]+/g);
        const label = options.label.toUpperCase();
        const re = /^-----(BEGIN|END) ([^-]+)-----$/;
        let start = -1;
        let end = -1;
        for (let i = 0; i < lines.length; i++) {
          const match = lines[i].match(re);
          if (match === null)
            continue;
          if (match[2] !== label)
            continue;
          if (start === -1) {
            if (match[1] !== "BEGIN")
              break;
            start = i;
          } else {
            if (match[1] !== "END")
              break;
            end = i;
            break;
          }
        }
        if (start === -1 || end === -1)
          throw new Error("PEM section not found for: " + label);
        const base64 = lines.slice(start + 1, end).join("");
        base64.replace(/[^a-z0-9+/=]+/gi, "");
        const input = Buffer2.from(base64, "base64");
        return DERDecoder.prototype.decode.call(this, input, options);
      };
      return pem;
    }
    var hasRequiredDecoders;
    function requireDecoders() {
      if (hasRequiredDecoders)
        return decoders;
      hasRequiredDecoders = 1;
      (function(exports2) {
        const decoders2 = exports2;
        decoders2.der = requireDer();
        decoders2.pem = requirePem();
      })(decoders);
      return decoders;
    }
    var hasRequiredApi;
    function requireApi() {
      if (hasRequiredApi)
        return api;
      hasRequiredApi = 1;
      (function(exports2) {
        const encoders2 = requireEncoders();
        const decoders2 = requireDecoders();
        const inherits2 = require$$3$1;
        const api2 = exports2;
        api2.define = function define(name2, body) {
          return new Entity(name2, body);
        };
        function Entity(name2, body) {
          this.name = name2;
          this.body = body;
          this.decoders = {};
          this.encoders = {};
        }
        Entity.prototype._createNamed = function createNamed(Base2) {
          const name2 = this.name;
          function Generated(entity) {
            this._initNamed(entity, name2);
          }
          inherits2(Generated, Base2);
          Generated.prototype._initNamed = function _initNamed(entity, name3) {
            Base2.call(this, entity, name3);
          };
          return new Generated(this);
        };
        Entity.prototype._getDecoder = function _getDecoder(enc) {
          enc = enc || "der";
          if (!this.decoders.hasOwnProperty(enc))
            this.decoders[enc] = this._createNamed(decoders2[enc]);
          return this.decoders[enc];
        };
        Entity.prototype.decode = function decode2(data, enc, options) {
          return this._getDecoder(enc).decode(data, options);
        };
        Entity.prototype._getEncoder = function _getEncoder(enc) {
          enc = enc || "der";
          if (!this.encoders.hasOwnProperty(enc))
            this.encoders[enc] = this._createNamed(encoders2[enc]);
          return this.encoders[enc];
        };
        Entity.prototype.encode = function encode2(data, enc, reporter2) {
          return this._getEncoder(enc).encode(data, reporter2);
        };
      })(api);
      return api;
    }
    var base = {};
    var hasRequiredBase;
    function requireBase() {
      if (hasRequiredBase)
        return base;
      hasRequiredBase = 1;
      (function(exports2) {
        const base2 = exports2;
        base2.Reporter = requireReporter().Reporter;
        base2.DecoderBuffer = requireBuffer().DecoderBuffer;
        base2.EncoderBuffer = requireBuffer().EncoderBuffer;
        base2.Node = requireNode();
      })(base);
      return base;
    }
    var constants = {};
    var hasRequiredConstants;
    function requireConstants() {
      if (hasRequiredConstants)
        return constants;
      hasRequiredConstants = 1;
      (function(exports2) {
        const constants2 = exports2;
        constants2._reverse = function reverse(map) {
          const res = {};
          Object.keys(map).forEach(function(key2) {
            if ((key2 | 0) == key2)
              key2 = key2 | 0;
            const value = map[key2];
            res[value] = key2;
          });
          return res;
        };
        constants2.der = requireDer$2();
      })(constants);
      return constants;
    }
    var hasRequiredAsn1$1;
    function requireAsn1$1() {
      if (hasRequiredAsn1$1)
        return asn1;
      hasRequiredAsn1$1 = 1;
      (function(exports2) {
        const asn12 = exports2;
        asn12.bignum = requireBn$1();
        asn12.define = requireApi().define;
        asn12.base = requireBase();
        asn12.constants = requireConstants();
        asn12.decoders = requireDecoders();
        asn12.encoders = requireEncoders();
      })(asn1);
      return asn1;
    }
    var certificate;
    var hasRequiredCertificate;
    function requireCertificate() {
      if (hasRequiredCertificate)
        return certificate;
      hasRequiredCertificate = 1;
      var asn = requireAsn1$1();
      var Time = asn.define("Time", function() {
        this.choice({
          utcTime: this.utctime(),
          generalTime: this.gentime()
        });
      });
      var AttributeTypeValue = asn.define("AttributeTypeValue", function() {
        this.seq().obj(this.key("type").objid(), this.key("value").any());
      });
      var AlgorithmIdentifier = asn.define("AlgorithmIdentifier", function() {
        this.seq().obj(this.key("algorithm").objid(), this.key("parameters").optional(), this.key("curve").objid().optional());
      });
      var SubjectPublicKeyInfo = asn.define("SubjectPublicKeyInfo", function() {
        this.seq().obj(this.key("algorithm").use(AlgorithmIdentifier), this.key("subjectPublicKey").bitstr());
      });
      var RelativeDistinguishedName = asn.define("RelativeDistinguishedName", function() {
        this.setof(AttributeTypeValue);
      });
      var RDNSequence = asn.define("RDNSequence", function() {
        this.seqof(RelativeDistinguishedName);
      });
      var Name = asn.define("Name", function() {
        this.choice({
          rdnSequence: this.use(RDNSequence)
        });
      });
      var Validity = asn.define("Validity", function() {
        this.seq().obj(this.key("notBefore").use(Time), this.key("notAfter").use(Time));
      });
      var Extension = asn.define("Extension", function() {
        this.seq().obj(this.key("extnID").objid(), this.key("critical").bool().def(false), this.key("extnValue").octstr());
      });
      var TBSCertificate = asn.define("TBSCertificate", function() {
        this.seq().obj(this.key("version").explicit(0).int().optional(), this.key("serialNumber").int(), this.key("signature").use(AlgorithmIdentifier), this.key("issuer").use(Name), this.key("validity").use(Validity), this.key("subject").use(Name), this.key("subjectPublicKeyInfo").use(SubjectPublicKeyInfo), this.key("issuerUniqueID").implicit(1).bitstr().optional(), this.key("subjectUniqueID").implicit(2).bitstr().optional(), this.key("extensions").explicit(3).seqof(Extension).optional());
      });
      var X509Certificate = asn.define("X509Certificate", function() {
        this.seq().obj(this.key("tbsCertificate").use(TBSCertificate), this.key("signatureAlgorithm").use(AlgorithmIdentifier), this.key("signatureValue").bitstr());
      });
      certificate = X509Certificate;
      return certificate;
    }
    var hasRequiredAsn1;
    function requireAsn1() {
      if (hasRequiredAsn1)
        return asn1$1;
      hasRequiredAsn1 = 1;
      var asn12 = requireAsn1$1();
      asn1$1.certificate = requireCertificate();
      var RSAPrivateKey = asn12.define("RSAPrivateKey", function() {
        this.seq().obj(this.key("version").int(), this.key("modulus").int(), this.key("publicExponent").int(), this.key("privateExponent").int(), this.key("prime1").int(), this.key("prime2").int(), this.key("exponent1").int(), this.key("exponent2").int(), this.key("coefficient").int());
      });
      asn1$1.RSAPrivateKey = RSAPrivateKey;
      var RSAPublicKey = asn12.define("RSAPublicKey", function() {
        this.seq().obj(this.key("modulus").int(), this.key("publicExponent").int());
      });
      asn1$1.RSAPublicKey = RSAPublicKey;
      var PublicKey = asn12.define("SubjectPublicKeyInfo", function() {
        this.seq().obj(this.key("algorithm").use(AlgorithmIdentifier), this.key("subjectPublicKey").bitstr());
      });
      asn1$1.PublicKey = PublicKey;
      var AlgorithmIdentifier = asn12.define("AlgorithmIdentifier", function() {
        this.seq().obj(this.key("algorithm").objid(), this.key("none").null_().optional(), this.key("curve").objid().optional(), this.key("params").seq().obj(this.key("p").int(), this.key("q").int(), this.key("g").int()).optional());
      });
      var PrivateKeyInfo = asn12.define("PrivateKeyInfo", function() {
        this.seq().obj(this.key("version").int(), this.key("algorithm").use(AlgorithmIdentifier), this.key("subjectPrivateKey").octstr());
      });
      asn1$1.PrivateKey = PrivateKeyInfo;
      var EncryptedPrivateKeyInfo = asn12.define("EncryptedPrivateKeyInfo", function() {
        this.seq().obj(this.key("algorithm").seq().obj(this.key("id").objid(), this.key("decrypt").seq().obj(this.key("kde").seq().obj(this.key("id").objid(), this.key("kdeparams").seq().obj(this.key("salt").octstr(), this.key("iters").int())), this.key("cipher").seq().obj(this.key("algo").objid(), this.key("iv").octstr()))), this.key("subjectPrivateKey").octstr());
      });
      asn1$1.EncryptedPrivateKey = EncryptedPrivateKeyInfo;
      var DSAPrivateKey = asn12.define("DSAPrivateKey", function() {
        this.seq().obj(this.key("version").int(), this.key("p").int(), this.key("q").int(), this.key("g").int(), this.key("pub_key").int(), this.key("priv_key").int());
      });
      asn1$1.DSAPrivateKey = DSAPrivateKey;
      asn1$1.DSAparam = asn12.define("DSAparam", function() {
        this.int();
      });
      var ECPrivateKey = asn12.define("ECPrivateKey", function() {
        this.seq().obj(this.key("version").int(), this.key("privateKey").octstr(), this.key("parameters").optional().explicit(0).use(ECParameters), this.key("publicKey").optional().explicit(1).bitstr());
      });
      asn1$1.ECPrivateKey = ECPrivateKey;
      var ECParameters = asn12.define("ECParameters", function() {
        this.choice({
          namedCurve: this.objid()
        });
      });
      asn1$1.signature = asn12.define("signature", function() {
        this.seq().obj(this.key("r").int(), this.key("s").int());
      });
      return asn1$1;
    }
    var require$$1 = {
      "2.16.840.1.101.3.4.1.1": "aes-128-ecb",
      "2.16.840.1.101.3.4.1.2": "aes-128-cbc",
      "2.16.840.1.101.3.4.1.3": "aes-128-ofb",
      "2.16.840.1.101.3.4.1.4": "aes-128-cfb",
      "2.16.840.1.101.3.4.1.21": "aes-192-ecb",
      "2.16.840.1.101.3.4.1.22": "aes-192-cbc",
      "2.16.840.1.101.3.4.1.23": "aes-192-ofb",
      "2.16.840.1.101.3.4.1.24": "aes-192-cfb",
      "2.16.840.1.101.3.4.1.41": "aes-256-ecb",
      "2.16.840.1.101.3.4.1.42": "aes-256-cbc",
      "2.16.840.1.101.3.4.1.43": "aes-256-ofb",
      "2.16.840.1.101.3.4.1.44": "aes-256-cfb"
    };
    var fixProc;
    var hasRequiredFixProc;
    function requireFixProc() {
      if (hasRequiredFixProc)
        return fixProc;
      hasRequiredFixProc = 1;
      var findProc = /Proc-Type: 4,ENCRYPTED[\n\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\n\r]+([0-9A-z\n\r+/=]+)[\n\r]+/m;
      var startRegex = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----/m;
      var fullRegex = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----([0-9A-z\n\r+/=]+)-----END \1-----$/m;
      var evp = requireEvp_bytestokey();
      var ciphers2 = requireBrowser$6();
      var Buffer2 = safeBufferExports.Buffer;
      fixProc = function(okey, password) {
        var key2 = okey.toString();
        var match = key2.match(findProc);
        var decrypted;
        if (!match) {
          var match2 = key2.match(fullRegex);
          decrypted = Buffer2.from(match2[2].replace(/[\r\n]/g, ""), "base64");
        } else {
          var suite = "aes" + match[1];
          var iv = Buffer2.from(match[2], "hex");
          var cipherText = Buffer2.from(match[3].replace(/[\r\n]/g, ""), "base64");
          var cipherKey = evp(password, iv.slice(0, 8), parseInt(match[1], 10)).key;
          var out = [];
          var cipher2 = ciphers2.createDecipheriv(suite, cipherKey, iv);
          out.push(cipher2.update(cipherText));
          out.push(cipher2.final());
          decrypted = Buffer2.concat(out);
        }
        var tag = key2.match(startRegex)[1];
        return {
          tag,
          data: decrypted
        };
      };
      return fixProc;
    }
    var parseAsn1;
    var hasRequiredParseAsn1;
    function requireParseAsn1() {
      if (hasRequiredParseAsn1)
        return parseAsn1;
      hasRequiredParseAsn1 = 1;
      var asn12 = requireAsn1();
      var aesid = require$$1;
      var fixProc2 = requireFixProc();
      var ciphers2 = requireBrowser$6();
      var compat = requireBrowser$7();
      var Buffer2 = safeBufferExports.Buffer;
      parseAsn1 = parseKeys;
      function parseKeys(buffer2) {
        var password;
        if (typeof buffer2 === "object" && !Buffer2.isBuffer(buffer2)) {
          password = buffer2.passphrase;
          buffer2 = buffer2.key;
        }
        if (typeof buffer2 === "string") {
          buffer2 = Buffer2.from(buffer2);
        }
        var stripped = fixProc2(buffer2, password);
        var type = stripped.tag;
        var data = stripped.data;
        var subtype, ndata;
        switch (type) {
          case "CERTIFICATE":
            ndata = asn12.certificate.decode(data, "der").tbsCertificate.subjectPublicKeyInfo;
          case "PUBLIC KEY":
            if (!ndata) {
              ndata = asn12.PublicKey.decode(data, "der");
            }
            subtype = ndata.algorithm.algorithm.join(".");
            switch (subtype) {
              case "1.2.840.113549.1.1.1":
                return asn12.RSAPublicKey.decode(ndata.subjectPublicKey.data, "der");
              case "1.2.840.10045.2.1":
                ndata.subjectPrivateKey = ndata.subjectPublicKey;
                return {
                  type: "ec",
                  data: ndata
                };
              case "1.2.840.10040.4.1":
                ndata.algorithm.params.pub_key = asn12.DSAparam.decode(ndata.subjectPublicKey.data, "der");
                return {
                  type: "dsa",
                  data: ndata.algorithm.params
                };
              default:
                throw new Error("unknown key id " + subtype);
            }
          case "ENCRYPTED PRIVATE KEY":
            data = asn12.EncryptedPrivateKey.decode(data, "der");
            data = decrypt2(data, password);
          case "PRIVATE KEY":
            ndata = asn12.PrivateKey.decode(data, "der");
            subtype = ndata.algorithm.algorithm.join(".");
            switch (subtype) {
              case "1.2.840.113549.1.1.1":
                return asn12.RSAPrivateKey.decode(ndata.subjectPrivateKey, "der");
              case "1.2.840.10045.2.1":
                return {
                  curve: ndata.algorithm.curve,
                  privateKey: asn12.ECPrivateKey.decode(ndata.subjectPrivateKey, "der").privateKey
                };
              case "1.2.840.10040.4.1":
                ndata.algorithm.params.priv_key = asn12.DSAparam.decode(ndata.subjectPrivateKey, "der");
                return {
                  type: "dsa",
                  params: ndata.algorithm.params
                };
              default:
                throw new Error("unknown key id " + subtype);
            }
          case "RSA PUBLIC KEY":
            return asn12.RSAPublicKey.decode(data, "der");
          case "RSA PRIVATE KEY":
            return asn12.RSAPrivateKey.decode(data, "der");
          case "DSA PRIVATE KEY":
            return {
              type: "dsa",
              params: asn12.DSAPrivateKey.decode(data, "der")
            };
          case "EC PRIVATE KEY":
            data = asn12.ECPrivateKey.decode(data, "der");
            return {
              curve: data.parameters.value,
              privateKey: data.privateKey
            };
          default:
            throw new Error("unknown key type " + type);
        }
      }
      parseKeys.signature = asn12.signature;
      function decrypt2(data, password) {
        var salt = data.algorithm.decrypt.kde.kdeparams.salt;
        var iters = parseInt(data.algorithm.decrypt.kde.kdeparams.iters.toString(), 10);
        var algo = aesid[data.algorithm.decrypt.cipher.algo.join(".")];
        var iv = data.algorithm.decrypt.cipher.iv;
        var cipherText = data.subjectPrivateKey;
        var keylen = parseInt(algo.split("-")[1], 10) / 8;
        var key2 = compat.pbkdf2Sync(password, salt, iters, keylen, "sha1");
        var cipher2 = ciphers2.createDecipheriv(algo, key2, iv);
        var out = [];
        out.push(cipher2.update(cipherText));
        out.push(cipher2.final());
        return Buffer2.concat(out);
      }
      return parseAsn1;
    }
    var require$$4 = {
      "1.3.132.0.10": "secp256k1",
      "1.3.132.0.33": "p224",
      "1.2.840.10045.3.1.1": "p192",
      "1.2.840.10045.3.1.7": "p256",
      "1.3.132.0.34": "p384",
      "1.3.132.0.35": "p521"
    };
    var hasRequiredSign;
    function requireSign() {
      if (hasRequiredSign)
        return signExports;
      hasRequiredSign = 1;
      var Buffer2 = safeBufferExports.Buffer;
      var createHmac = requireBrowser$8();
      var crt = requireBrowserifyRsa();
      var EC = requireElliptic().ec;
      var BN = requireBn();
      var parseKeys = requireParseAsn1();
      var curves2 = require$$4;
      function sign$1(hash2, key2, hashType, signType, tag) {
        var priv = parseKeys(key2);
        if (priv.curve) {
          if (signType !== "ecdsa" && signType !== "ecdsa/rsa")
            throw new Error("wrong private key type");
          return ecSign(hash2, priv);
        } else if (priv.type === "dsa") {
          if (signType !== "dsa")
            throw new Error("wrong private key type");
          return dsaSign(hash2, priv, hashType);
        } else {
          if (signType !== "rsa" && signType !== "ecdsa/rsa")
            throw new Error("wrong private key type");
        }
        hash2 = Buffer2.concat([tag, hash2]);
        var len = priv.modulus.byteLength();
        var pad2 = [0, 1];
        while (hash2.length + pad2.length + 1 < len)
          pad2.push(255);
        pad2.push(0);
        var i = -1;
        while (++i < hash2.length)
          pad2.push(hash2[i]);
        var out = crt(pad2, priv);
        return out;
      }
      function ecSign(hash2, priv) {
        var curveId = curves2[priv.curve.join(".")];
        if (!curveId)
          throw new Error("unknown curve " + priv.curve.join("."));
        var curve2 = new EC(curveId);
        var key2 = curve2.keyFromPrivate(priv.privateKey);
        var out = key2.sign(hash2);
        return Buffer2.from(out.toDER());
      }
      function dsaSign(hash2, priv, algo) {
        var x = priv.params.priv_key;
        var p = priv.params.p;
        var q = priv.params.q;
        var g = priv.params.g;
        var r = new BN(0);
        var k;
        var H = bits2int(hash2, q).mod(q);
        var s = false;
        var kv = getKey(x, q, hash2, algo);
        while (s === false) {
          k = makeKey(q, kv, algo);
          r = makeR(g, k, p, q);
          s = k.invm(q).imul(H.add(x.mul(r))).mod(q);
          if (s.cmpn(0) === 0) {
            s = false;
            r = new BN(0);
          }
        }
        return toDER(r, s);
      }
      function toDER(r, s) {
        r = r.toArray();
        s = s.toArray();
        if (r[0] & 128)
          r = [0].concat(r);
        if (s[0] & 128)
          s = [0].concat(s);
        var total = r.length + s.length + 4;
        var res = [48, total, 2, r.length];
        res = res.concat(r, [2, s.length], s);
        return Buffer2.from(res);
      }
      function getKey(x, q, hash2, algo) {
        x = Buffer2.from(x.toArray());
        if (x.length < q.byteLength()) {
          var zeros = Buffer2.alloc(q.byteLength() - x.length);
          x = Buffer2.concat([zeros, x]);
        }
        var hlen = hash2.length;
        var hbits = bits2octets(hash2, q);
        var v2 = Buffer2.alloc(hlen);
        v2.fill(1);
        var k = Buffer2.alloc(hlen);
        k = createHmac(algo, k).update(v2).update(Buffer2.from([0])).update(x).update(hbits).digest();
        v2 = createHmac(algo, k).update(v2).digest();
        k = createHmac(algo, k).update(v2).update(Buffer2.from([1])).update(x).update(hbits).digest();
        v2 = createHmac(algo, k).update(v2).digest();
        return {k, v: v2};
      }
      function bits2int(obits, q) {
        var bits = new BN(obits);
        var shift = (obits.length << 3) - q.bitLength();
        if (shift > 0)
          bits.ishrn(shift);
        return bits;
      }
      function bits2octets(bits, q) {
        bits = bits2int(bits, q);
        bits = bits.mod(q);
        var out = Buffer2.from(bits.toArray());
        if (out.length < q.byteLength()) {
          var zeros = Buffer2.alloc(q.byteLength() - out.length);
          out = Buffer2.concat([zeros, out]);
        }
        return out;
      }
      function makeKey(q, kv, algo) {
        var t;
        var k;
        do {
          t = Buffer2.alloc(0);
          while (t.length * 8 < q.bitLength()) {
            kv.v = createHmac(algo, kv.k).update(kv.v).digest();
            t = Buffer2.concat([t, kv.v]);
          }
          k = bits2int(t, q);
          kv.k = createHmac(algo, kv.k).update(kv.v).update(Buffer2.from([0])).digest();
          kv.v = createHmac(algo, kv.k).update(kv.v).digest();
        } while (k.cmp(q) !== -1);
        return k;
      }
      function makeR(g, k, p, q) {
        return g.toRed(BN.mont(p)).redPow(k).fromRed().mod(q);
      }
      sign.exports = sign$1;
      signExports.getKey = getKey;
      signExports.makeKey = makeKey;
      return signExports;
    }
    var verify_1;
    var hasRequiredVerify;
    function requireVerify() {
      if (hasRequiredVerify)
        return verify_1;
      hasRequiredVerify = 1;
      var Buffer2 = safeBufferExports.Buffer;
      var BN = requireBn();
      var EC = requireElliptic().ec;
      var parseKeys = requireParseAsn1();
      var curves2 = require$$4;
      function verify(sig, hash2, key2, signType, tag) {
        var pub = parseKeys(key2);
        if (pub.type === "ec") {
          if (signType !== "ecdsa" && signType !== "ecdsa/rsa")
            throw new Error("wrong public key type");
          return ecVerify(sig, hash2, pub);
        } else if (pub.type === "dsa") {
          if (signType !== "dsa")
            throw new Error("wrong public key type");
          return dsaVerify(sig, hash2, pub);
        } else {
          if (signType !== "rsa" && signType !== "ecdsa/rsa")
            throw new Error("wrong public key type");
        }
        hash2 = Buffer2.concat([tag, hash2]);
        var len = pub.modulus.byteLength();
        var pad2 = [1];
        var padNum = 0;
        while (hash2.length + pad2.length + 2 < len) {
          pad2.push(255);
          padNum++;
        }
        pad2.push(0);
        var i = -1;
        while (++i < hash2.length) {
          pad2.push(hash2[i]);
        }
        pad2 = Buffer2.from(pad2);
        var red = BN.mont(pub.modulus);
        sig = new BN(sig).toRed(red);
        sig = sig.redPow(new BN(pub.publicExponent));
        sig = Buffer2.from(sig.fromRed().toArray());
        var out = padNum < 8 ? 1 : 0;
        len = Math.min(sig.length, pad2.length);
        if (sig.length !== pad2.length)
          out = 1;
        i = -1;
        while (++i < len)
          out |= sig[i] ^ pad2[i];
        return out === 0;
      }
      function ecVerify(sig, hash2, pub) {
        var curveId = curves2[pub.data.algorithm.curve.join(".")];
        if (!curveId)
          throw new Error("unknown curve " + pub.data.algorithm.curve.join("."));
        var curve2 = new EC(curveId);
        var pubkey = pub.data.subjectPrivateKey.data;
        return curve2.verify(hash2, sig, pubkey);
      }
      function dsaVerify(sig, hash2, pub) {
        var p = pub.data.p;
        var q = pub.data.q;
        var g = pub.data.g;
        var y = pub.data.pub_key;
        var unpacked = parseKeys.signature.decode(sig, "der");
        var s = unpacked.s;
        var r = unpacked.r;
        checkValue(s, q);
        checkValue(r, q);
        var montp = BN.mont(p);
        var w = s.invm(q);
        var v2 = g.toRed(montp).redPow(new BN(hash2).mul(w).mod(q)).fromRed().mul(y.toRed(montp).redPow(r.mul(w).mod(q)).fromRed()).mod(p).mod(q);
        return v2.cmp(r) === 0;
      }
      function checkValue(b, q) {
        if (b.cmpn(0) <= 0)
          throw new Error("invalid sig");
        if (b.cmp(q) >= q)
          throw new Error("invalid sig");
      }
      verify_1 = verify;
      return verify_1;
    }
    var browser$4;
    var hasRequiredBrowser$3;
    function requireBrowser$3() {
      if (hasRequiredBrowser$3)
        return browser$4;
      hasRequiredBrowser$3 = 1;
      var Buffer2 = safeBufferExports.Buffer;
      var createHash = requireBrowser$9();
      var stream2 = readableBrowserExports;
      var inherits2 = require$$3$1;
      var sign2 = requireSign();
      var verify = requireVerify();
      var algorithms = require$$6;
      Object.keys(algorithms).forEach(function(key2) {
        algorithms[key2].id = Buffer2.from(algorithms[key2].id, "hex");
        algorithms[key2.toLowerCase()] = algorithms[key2];
      });
      function Sign(algorithm) {
        stream2.Writable.call(this);
        var data = algorithms[algorithm];
        if (!data)
          throw new Error("Unknown message digest");
        this._hashType = data.hash;
        this._hash = createHash(data.hash);
        this._tag = data.id;
        this._signType = data.sign;
      }
      inherits2(Sign, stream2.Writable);
      Sign.prototype._write = function _write(data, _, done2) {
        this._hash.update(data);
        done2();
      };
      Sign.prototype.update = function update(data, enc) {
        if (typeof data === "string")
          data = Buffer2.from(data, enc);
        this._hash.update(data);
        return this;
      };
      Sign.prototype.sign = function signMethod(key2, enc) {
        this.end();
        var hash2 = this._hash.digest();
        var sig = sign2(hash2, key2, this._hashType, this._signType, this._tag);
        return enc ? sig.toString(enc) : sig;
      };
      function Verify(algorithm) {
        stream2.Writable.call(this);
        var data = algorithms[algorithm];
        if (!data)
          throw new Error("Unknown message digest");
        this._hash = createHash(data.hash);
        this._tag = data.id;
        this._signType = data.sign;
      }
      inherits2(Verify, stream2.Writable);
      Verify.prototype._write = function _write(data, _, done2) {
        this._hash.update(data);
        done2();
      };
      Verify.prototype.update = function update(data, enc) {
        if (typeof data === "string")
          data = Buffer2.from(data, enc);
        this._hash.update(data);
        return this;
      };
      Verify.prototype.verify = function verifyMethod(key2, sig, enc) {
        if (typeof sig === "string")
          sig = Buffer2.from(sig, enc);
        this.end();
        var hash2 = this._hash.digest();
        return verify(sig, hash2, key2, this._signType, this._tag);
      };
      function createSign(algorithm) {
        return new Sign(algorithm);
      }
      function createVerify(algorithm) {
        return new Verify(algorithm);
      }
      browser$4 = {
        Sign: createSign,
        Verify: createVerify,
        createSign,
        createVerify
      };
      return browser$4;
    }
    var browser$3;
    var hasRequiredBrowser$2;
    function requireBrowser$2() {
      if (hasRequiredBrowser$2)
        return browser$3;
      hasRequiredBrowser$2 = 1;
      var elliptic2 = requireElliptic();
      var BN = requireBn$1();
      browser$3 = function createECDH(curve2) {
        return new ECDH(curve2);
      };
      var aliases = {
        secp256k1: {
          name: "secp256k1",
          byteLength: 32
        },
        secp224r1: {
          name: "p224",
          byteLength: 28
        },
        prime256v1: {
          name: "p256",
          byteLength: 32
        },
        prime192v1: {
          name: "p192",
          byteLength: 24
        },
        ed25519: {
          name: "ed25519",
          byteLength: 32
        },
        secp384r1: {
          name: "p384",
          byteLength: 48
        },
        secp521r1: {
          name: "p521",
          byteLength: 66
        }
      };
      aliases.p224 = aliases.secp224r1;
      aliases.p256 = aliases.secp256r1 = aliases.prime256v1;
      aliases.p192 = aliases.secp192r1 = aliases.prime192v1;
      aliases.p384 = aliases.secp384r1;
      aliases.p521 = aliases.secp521r1;
      function ECDH(curve2) {
        this.curveType = aliases[curve2];
        if (!this.curveType) {
          this.curveType = {
            name: curve2
          };
        }
        this.curve = new elliptic2.ec(this.curveType.name);
        this.keys = void 0;
      }
      ECDH.prototype.generateKeys = function(enc, format2) {
        this.keys = this.curve.genKeyPair();
        return this.getPublicKey(enc, format2);
      };
      ECDH.prototype.computeSecret = function(other, inenc, enc) {
        inenc = inenc || "utf8";
        if (!Buffer.isBuffer(other)) {
          other = new Buffer(other, inenc);
        }
        var otherPub = this.curve.keyFromPublic(other).getPublic();
        var out = otherPub.mul(this.keys.getPrivate()).getX();
        return formatReturnValue(out, enc, this.curveType.byteLength);
      };
      ECDH.prototype.getPublicKey = function(enc, format2) {
        var key2 = this.keys.getPublic(format2 === "compressed", true);
        if (format2 === "hybrid") {
          if (key2[key2.length - 1] % 2) {
            key2[0] = 7;
          } else {
            key2[0] = 6;
          }
        }
        return formatReturnValue(key2, enc);
      };
      ECDH.prototype.getPrivateKey = function(enc) {
        return formatReturnValue(this.keys.getPrivate(), enc);
      };
      ECDH.prototype.setPublicKey = function(pub, enc) {
        enc = enc || "utf8";
        if (!Buffer.isBuffer(pub)) {
          pub = new Buffer(pub, enc);
        }
        this.keys._importPublic(pub);
        return this;
      };
      ECDH.prototype.setPrivateKey = function(priv, enc) {
        enc = enc || "utf8";
        if (!Buffer.isBuffer(priv)) {
          priv = new Buffer(priv, enc);
        }
        var _priv = new BN(priv);
        _priv = _priv.toString(16);
        this.keys = this.curve.genKeyPair();
        this.keys._importPrivate(_priv);
        return this;
      };
      function formatReturnValue(bn2, enc, len) {
        if (!Array.isArray(bn2)) {
          bn2 = bn2.toArray();
        }
        var buf2 = new Buffer(bn2);
        if (len && buf2.length < len) {
          var zeros = new Buffer(len - buf2.length);
          zeros.fill(0);
          buf2 = Buffer.concat([zeros, buf2]);
        }
        if (!enc) {
          return buf2;
        } else {
          return buf2.toString(enc);
        }
      }
      return browser$3;
    }
    var browser$2 = {};
    var mgf;
    var hasRequiredMgf;
    function requireMgf() {
      if (hasRequiredMgf)
        return mgf;
      hasRequiredMgf = 1;
      var createHash = requireBrowser$9();
      var Buffer2 = safeBufferExports.Buffer;
      mgf = function(seed, len) {
        var t = Buffer2.alloc(0);
        var i = 0;
        var c;
        while (t.length < len) {
          c = i2ops(i++);
          t = Buffer2.concat([t, createHash("sha1").update(seed).update(c).digest()]);
        }
        return t.slice(0, len);
      };
      function i2ops(c) {
        var out = Buffer2.allocUnsafe(4);
        out.writeUInt32BE(c, 0);
        return out;
      }
      return mgf;
    }
    var xor;
    var hasRequiredXor;
    function requireXor() {
      if (hasRequiredXor)
        return xor;
      hasRequiredXor = 1;
      xor = function xor2(a, b) {
        var len = a.length;
        var i = -1;
        while (++i < len) {
          a[i] ^= b[i];
        }
        return a;
      };
      return xor;
    }
    var withPublic_1;
    var hasRequiredWithPublic;
    function requireWithPublic() {
      if (hasRequiredWithPublic)
        return withPublic_1;
      hasRequiredWithPublic = 1;
      var BN = requireBn$1();
      var Buffer2 = safeBufferExports.Buffer;
      function withPublic(paddedMsg, key2) {
        return Buffer2.from(paddedMsg.toRed(BN.mont(key2.modulus)).redPow(new BN(key2.publicExponent)).fromRed().toArray());
      }
      withPublic_1 = withPublic;
      return withPublic_1;
    }
    var publicEncrypt;
    var hasRequiredPublicEncrypt;
    function requirePublicEncrypt() {
      if (hasRequiredPublicEncrypt)
        return publicEncrypt;
      hasRequiredPublicEncrypt = 1;
      var parseKeys = requireParseAsn1();
      var randomBytes2 = browserExports$1;
      var createHash = requireBrowser$9();
      var mgf2 = requireMgf();
      var xor2 = requireXor();
      var BN = requireBn$1();
      var withPublic = requireWithPublic();
      var crt = requireBrowserifyRsa();
      var Buffer2 = safeBufferExports.Buffer;
      publicEncrypt = function publicEncrypt2(publicKey, msg, reverse) {
        var padding;
        if (publicKey.padding) {
          padding = publicKey.padding;
        } else if (reverse) {
          padding = 1;
        } else {
          padding = 4;
        }
        var key2 = parseKeys(publicKey);
        var paddedMsg;
        if (padding === 4) {
          paddedMsg = oaep(key2, msg);
        } else if (padding === 1) {
          paddedMsg = pkcs1(key2, msg, reverse);
        } else if (padding === 3) {
          paddedMsg = new BN(msg);
          if (paddedMsg.cmp(key2.modulus) >= 0) {
            throw new Error("data too long for modulus");
          }
        } else {
          throw new Error("unknown padding");
        }
        if (reverse) {
          return crt(paddedMsg, key2);
        } else {
          return withPublic(paddedMsg, key2);
        }
      };
      function oaep(key2, msg) {
        var k = key2.modulus.byteLength();
        var mLen = msg.length;
        var iHash = createHash("sha1").update(Buffer2.alloc(0)).digest();
        var hLen = iHash.length;
        var hLen2 = 2 * hLen;
        if (mLen > k - hLen2 - 2) {
          throw new Error("message too long");
        }
        var ps = Buffer2.alloc(k - mLen - hLen2 - 2);
        var dblen = k - hLen - 1;
        var seed = randomBytes2(hLen);
        var maskedDb = xor2(Buffer2.concat([iHash, ps, Buffer2.alloc(1, 1), msg], dblen), mgf2(seed, dblen));
        var maskedSeed = xor2(seed, mgf2(maskedDb, hLen));
        return new BN(Buffer2.concat([Buffer2.alloc(1), maskedSeed, maskedDb], k));
      }
      function pkcs1(key2, msg, reverse) {
        var mLen = msg.length;
        var k = key2.modulus.byteLength();
        if (mLen > k - 11) {
          throw new Error("message too long");
        }
        var ps;
        if (reverse) {
          ps = Buffer2.alloc(k - mLen - 3, 255);
        } else {
          ps = nonZero(k - mLen - 3);
        }
        return new BN(Buffer2.concat([Buffer2.from([0, reverse ? 1 : 2]), ps, Buffer2.alloc(1), msg], k));
      }
      function nonZero(len) {
        var out = Buffer2.allocUnsafe(len);
        var i = 0;
        var cache2 = randomBytes2(len * 2);
        var cur = 0;
        var num;
        while (i < len) {
          if (cur === cache2.length) {
            cache2 = randomBytes2(len * 2);
            cur = 0;
          }
          num = cache2[cur++];
          if (num) {
            out[i++] = num;
          }
        }
        return out;
      }
      return publicEncrypt;
    }
    var privateDecrypt;
    var hasRequiredPrivateDecrypt;
    function requirePrivateDecrypt() {
      if (hasRequiredPrivateDecrypt)
        return privateDecrypt;
      hasRequiredPrivateDecrypt = 1;
      var parseKeys = requireParseAsn1();
      var mgf2 = requireMgf();
      var xor2 = requireXor();
      var BN = requireBn$1();
      var crt = requireBrowserifyRsa();
      var createHash = requireBrowser$9();
      var withPublic = requireWithPublic();
      var Buffer2 = safeBufferExports.Buffer;
      privateDecrypt = function privateDecrypt2(privateKey, enc, reverse) {
        var padding;
        if (privateKey.padding) {
          padding = privateKey.padding;
        } else if (reverse) {
          padding = 1;
        } else {
          padding = 4;
        }
        var key2 = parseKeys(privateKey);
        var k = key2.modulus.byteLength();
        if (enc.length > k || new BN(enc).cmp(key2.modulus) >= 0) {
          throw new Error("decryption error");
        }
        var msg;
        if (reverse) {
          msg = withPublic(new BN(enc), key2);
        } else {
          msg = crt(enc, key2);
        }
        var zBuffer = Buffer2.alloc(k - msg.length);
        msg = Buffer2.concat([zBuffer, msg], k);
        if (padding === 4) {
          return oaep(key2, msg);
        } else if (padding === 1) {
          return pkcs1(key2, msg, reverse);
        } else if (padding === 3) {
          return msg;
        } else {
          throw new Error("unknown padding");
        }
      };
      function oaep(key2, msg) {
        var k = key2.modulus.byteLength();
        var iHash = createHash("sha1").update(Buffer2.alloc(0)).digest();
        var hLen = iHash.length;
        if (msg[0] !== 0) {
          throw new Error("decryption error");
        }
        var maskedSeed = msg.slice(1, hLen + 1);
        var maskedDb = msg.slice(hLen + 1);
        var seed = xor2(maskedSeed, mgf2(maskedDb, hLen));
        var db = xor2(maskedDb, mgf2(seed, k - hLen - 1));
        if (compare2(iHash, db.slice(0, hLen))) {
          throw new Error("decryption error");
        }
        var i = hLen;
        while (db[i] === 0) {
          i++;
        }
        if (db[i++] !== 1) {
          throw new Error("decryption error");
        }
        return db.slice(i);
      }
      function pkcs1(key2, msg, reverse) {
        var p1 = msg.slice(0, 2);
        var i = 2;
        var status = 0;
        while (msg[i++] !== 0) {
          if (i >= msg.length) {
            status++;
            break;
          }
        }
        var ps = msg.slice(2, i - 1);
        if (p1.toString("hex") !== "0002" && !reverse || p1.toString("hex") !== "0001" && reverse) {
          status++;
        }
        if (ps.length < 8) {
          status++;
        }
        if (status) {
          throw new Error("decryption error");
        }
        return msg.slice(i);
      }
      function compare2(a, b) {
        a = Buffer2.from(a);
        b = Buffer2.from(b);
        var dif = 0;
        var len = a.length;
        if (a.length !== b.length) {
          dif++;
          len = Math.min(a.length, b.length);
        }
        var i = -1;
        while (++i < len) {
          dif += a[i] ^ b[i];
        }
        return dif;
      }
      return privateDecrypt;
    }
    var hasRequiredBrowser$1;
    function requireBrowser$1() {
      if (hasRequiredBrowser$1)
        return browser$2;
      hasRequiredBrowser$1 = 1;
      (function(exports2) {
        exports2.publicEncrypt = requirePublicEncrypt();
        exports2.privateDecrypt = requirePrivateDecrypt();
        exports2.privateEncrypt = function privateEncrypt(key2, buf2) {
          return exports2.publicEncrypt(key2, buf2, true);
        };
        exports2.publicDecrypt = function publicDecrypt(key2, buf2) {
          return exports2.privateDecrypt(key2, buf2, true);
        };
      })(browser$2);
      return browser$2;
    }
    var browser$1 = {};
    var hasRequiredBrowser;
    function requireBrowser() {
      if (hasRequiredBrowser)
        return browser$1;
      hasRequiredBrowser = 1;
      function oldBrowser2() {
        throw new Error("secure random number generation not supported by this browser\nuse chrome, FireFox or Internet Explorer 11");
      }
      var safeBuffer2 = safeBufferExports;
      var randombytes2 = browserExports$1;
      var Buffer2 = safeBuffer2.Buffer;
      var kBufferMaxLength = safeBuffer2.kMaxLength;
      var crypto2 = commonjsGlobal.crypto || commonjsGlobal.msCrypto;
      var kMaxUint32 = Math.pow(2, 32) - 1;
      function assertOffset(offset, length2) {
        if (typeof offset !== "number" || offset !== offset) {
          throw new TypeError("offset must be a number");
        }
        if (offset > kMaxUint32 || offset < 0) {
          throw new TypeError("offset must be a uint32");
        }
        if (offset > kBufferMaxLength || offset > length2) {
          throw new RangeError("offset out of range");
        }
      }
      function assertSize2(size, offset, length2) {
        if (typeof size !== "number" || size !== size) {
          throw new TypeError("size must be a number");
        }
        if (size > kMaxUint32 || size < 0) {
          throw new TypeError("size must be a uint32");
        }
        if (size + offset > length2 || size > kBufferMaxLength) {
          throw new RangeError("buffer too small");
        }
      }
      if (crypto2 && crypto2.getRandomValues || !process.browser) {
        browser$1.randomFill = randomFill;
        browser$1.randomFillSync = randomFillSync;
      } else {
        browser$1.randomFill = oldBrowser2;
        browser$1.randomFillSync = oldBrowser2;
      }
      function randomFill(buf2, offset, size, cb) {
        if (!Buffer2.isBuffer(buf2) && !(buf2 instanceof commonjsGlobal.Uint8Array)) {
          throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
        }
        if (typeof offset === "function") {
          cb = offset;
          offset = 0;
          size = buf2.length;
        } else if (typeof size === "function") {
          cb = size;
          size = buf2.length - offset;
        } else if (typeof cb !== "function") {
          throw new TypeError('"cb" argument must be a function');
        }
        assertOffset(offset, buf2.length);
        assertSize2(size, offset, buf2.length);
        return actualFill(buf2, offset, size, cb);
      }
      function actualFill(buf2, offset, size, cb) {
        if (process.browser) {
          var ourBuf = buf2.buffer;
          var uint = new Uint8Array(ourBuf, offset, size);
          crypto2.getRandomValues(uint);
          if (cb) {
            process.nextTick(function() {
              cb(null, buf2);
            });
            return;
          }
          return buf2;
        }
        if (cb) {
          randombytes2(size, function(err, bytes2) {
            if (err) {
              return cb(err);
            }
            bytes2.copy(buf2, offset);
            cb(null, buf2);
          });
          return;
        }
        var bytes = randombytes2(size);
        bytes.copy(buf2, offset);
        return buf2;
      }
      function randomFillSync(buf2, offset, size) {
        if (typeof offset === "undefined") {
          offset = 0;
        }
        if (!Buffer2.isBuffer(buf2) && !(buf2 instanceof commonjsGlobal.Uint8Array)) {
          throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
        }
        assertOffset(offset, buf2.length);
        if (size === void 0)
          size = buf2.length - offset;
        assertSize2(size, offset, buf2.length);
        return actualFill(buf2, offset, size);
      }
      return browser$1;
    }
    var hasRequiredCryptoBrowserify;
    function requireCryptoBrowserify() {
      if (hasRequiredCryptoBrowserify)
        return cryptoBrowserify;
      hasRequiredCryptoBrowserify = 1;
      cryptoBrowserify.randomBytes = cryptoBrowserify.rng = cryptoBrowserify.pseudoRandomBytes = cryptoBrowserify.prng = browserExports$1;
      cryptoBrowserify.createHash = cryptoBrowserify.Hash = requireBrowser$9();
      cryptoBrowserify.createHmac = cryptoBrowserify.Hmac = requireBrowser$8();
      var algos2 = requireAlgos();
      var algoKeys = Object.keys(algos2);
      var hashes = ["sha1", "sha224", "sha256", "sha384", "sha512", "md5", "rmd160"].concat(algoKeys);
      cryptoBrowserify.getHashes = function() {
        return hashes;
      };
      var p = requireBrowser$7();
      cryptoBrowserify.pbkdf2 = p.pbkdf2;
      cryptoBrowserify.pbkdf2Sync = p.pbkdf2Sync;
      var aes2 = requireBrowser$5();
      cryptoBrowserify.Cipher = aes2.Cipher;
      cryptoBrowserify.createCipher = aes2.createCipher;
      cryptoBrowserify.Cipheriv = aes2.Cipheriv;
      cryptoBrowserify.createCipheriv = aes2.createCipheriv;
      cryptoBrowserify.Decipher = aes2.Decipher;
      cryptoBrowserify.createDecipher = aes2.createDecipher;
      cryptoBrowserify.Decipheriv = aes2.Decipheriv;
      cryptoBrowserify.createDecipheriv = aes2.createDecipheriv;
      cryptoBrowserify.getCiphers = aes2.getCiphers;
      cryptoBrowserify.listCiphers = aes2.listCiphers;
      var dh2 = requireBrowser$4();
      cryptoBrowserify.DiffieHellmanGroup = dh2.DiffieHellmanGroup;
      cryptoBrowserify.createDiffieHellmanGroup = dh2.createDiffieHellmanGroup;
      cryptoBrowserify.getDiffieHellman = dh2.getDiffieHellman;
      cryptoBrowserify.createDiffieHellman = dh2.createDiffieHellman;
      cryptoBrowserify.DiffieHellman = dh2.DiffieHellman;
      var sign2 = requireBrowser$3();
      cryptoBrowserify.createSign = sign2.createSign;
      cryptoBrowserify.Sign = sign2.Sign;
      cryptoBrowserify.createVerify = sign2.createVerify;
      cryptoBrowserify.Verify = sign2.Verify;
      cryptoBrowserify.createECDH = requireBrowser$2();
      var publicEncrypt2 = requireBrowser$1();
      cryptoBrowserify.publicEncrypt = publicEncrypt2.publicEncrypt;
      cryptoBrowserify.privateEncrypt = publicEncrypt2.privateEncrypt;
      cryptoBrowserify.publicDecrypt = publicEncrypt2.publicDecrypt;
      cryptoBrowserify.privateDecrypt = publicEncrypt2.privateDecrypt;
      var rf = requireBrowser();
      cryptoBrowserify.randomFill = rf.randomFill;
      cryptoBrowserify.randomFillSync = rf.randomFillSync;
      cryptoBrowserify.createCredentials = function() {
        throw new Error([
          "sorry, createCredentials is not implemented yet",
          "we accept pull requests",
          "https://github.com/crypto-browserify/crypto-browserify"
        ].join("\n"));
      };
      cryptoBrowserify.constants = {
        DH_CHECK_P_NOT_SAFE_PRIME: 2,
        DH_CHECK_P_NOT_PRIME: 1,
        DH_UNABLE_TO_CHECK_GENERATOR: 4,
        DH_NOT_SUITABLE_GENERATOR: 8,
        NPN_ENABLED: 1,
        ALPN_ENABLED: 1,
        RSA_PKCS1_PADDING: 1,
        RSA_SSLV23_PADDING: 2,
        RSA_NO_PADDING: 3,
        RSA_PKCS1_OAEP_PADDING: 4,
        RSA_X931_PADDING: 5,
        RSA_PKCS1_PSS_PADDING: 6,
        POINT_CONVERSION_COMPRESSED: 2,
        POINT_CONVERSION_UNCOMPRESSED: 4,
        POINT_CONVERSION_HYBRID: 6
      };
      return cryptoBrowserify;
    }
    Object.defineProperty(dist, "__esModule", {value: true});
    dist.getCrypto = dist.getRootWebCrypto = dist.getWebCrypto = dist.getNodeCrypto = void 0;
    var getNodeCrypto = function() {
      if (typeof window !== "undefined" && window.crypto) {
        return void 0;
      } else if (typeof window === "undefined" && typeof crypto !== "undefined") {
        return void 0;
      } else
        return requireCryptoBrowserify();
    };
    dist.getNodeCrypto = getNodeCrypto;
    var getWebCrypto = function() {
      if (typeof window !== "undefined" && window.crypto) {
        return window.crypto.subtle;
      } else if (typeof window === "undefined" && typeof crypto !== "undefined") {
        return crypto.subtle;
      }
      return void 0;
    };
    dist.getWebCrypto = getWebCrypto;
    var getRootWebCrypto = function() {
      if (typeof window !== "undefined" && window.crypto) {
        return window.crypto;
      } else if (typeof window === "undefined" && typeof crypto !== "undefined") {
        return crypto;
      }
      return void 0;
    };
    dist.getRootWebCrypto = getRootWebCrypto;
    var getCrypto = function() {
      var webCrypto = getWebCrypto();
      var nodeCrypto = getNodeCrypto();
      if (typeof nodeCrypto !== "undefined")
        return {name: "nodeCrypto", crypto: nodeCrypto};
      else if (typeof webCrypto !== "undefined")
        return {name: "webCrypto", crypto: webCrypto};
      else
        return {name: void 0};
    };
    dist.getCrypto = getCrypto;
    dist.default = {getNodeCrypto, getWebCrypto, getRootWebCrypto, getCrypto};
    var nodeapi$1 = {};
    var params = {};
    Object.defineProperty(params, "__esModule", {value: true});
    var ciphers = {
      "AES-GCM": {
        nodePrefix: "aes-",
        nodeSuffix: "-gcm",
        ivLength: 12,
        tagLength: 16,
        staticIvLength: true
      },
      "AES-CBC": {
        nodePrefix: "aes-",
        nodeSuffix: "-cbc",
        ivLength: 16,
        staticIvLength: true
      },
      "AES-CTR": {
        nodePrefix: "aes-",
        nodeSuffix: "-ctr",
        ivLength: 12,
        staticIvLength: false
      }
    };
    var wrapKeys = {
      "AES-KW": {
        nodePrefix: "id-aes",
        nodeSuffix: "-wrap",
        ivLength: 8,
        staticIvLength: true,
        defaultIv: new Uint8Array([166, 166, 166, 166, 166, 166, 166, 166])
      }
    };
    params.default = {ciphers, wrapKeys};
    (function(exports2) {
      var __importDefault2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : {default: mod};
      };
      Object.defineProperty(exports2, "__esModule", {value: true});
      exports2.decrypt = exports2.encrypt = exports2.unwrapKey = exports2.wrapKey = void 0;
      var params_12 = __importDefault2(params);
      var wrapKey2 = function(keyToBeWrapped, wrappingKey, _a, nodeCrypto) {
        var name2 = _a.name, iv = _a.iv;
        return (0, exports2.encrypt)(keyToBeWrapped, wrappingKey, {name: name2, iv}, nodeCrypto, true);
      };
      exports2.wrapKey = wrapKey2;
      var unwrapKey2 = function(wrappedKey, unwrappingKey, _a, nodeCrypto) {
        var name2 = _a.name, iv = _a.iv;
        return (0, exports2.decrypt)(wrappedKey, unwrappingKey, {name: name2, iv}, nodeCrypto, true);
      };
      exports2.unwrapKey = unwrapKey2;
      var encrypt2 = function(msg, key2, _a, nodeCrypto, wrapKey3) {
        var name2 = _a.name, iv = _a.iv, additionalData = _a.additionalData, tagLength = _a.tagLength;
        if (wrapKey3 === void 0) {
          wrapKey3 = false;
        }
        var alg = getNodeName(name2, key2.byteLength, wrapKey3 ? params_12.default.wrapKeys : params_12.default.ciphers);
        var cipher2;
        switch (name2) {
          case "AES-GCM": {
            cipher2 = nodeCrypto.createCipheriv(alg, key2, iv, {authTagLength: tagLength});
            cipher2.setAAD(additionalData);
            break;
          }
          case "AES-CTR": {
            if (iv.length === 0 || iv.length > 16)
              throw new Error("InvalidIVLength");
            var counter = new Uint8Array(16);
            counter.set(iv);
            counter[15] += 1;
            cipher2 = nodeCrypto.createCipheriv(alg, key2, counter);
            break;
          }
          default: {
            cipher2 = nodeCrypto.createCipheriv(alg, key2, iv);
            break;
          }
        }
        var body;
        var final;
        var tag;
        try {
          body = new Uint8Array(cipher2.update(msg));
          final = new Uint8Array(cipher2.final());
          tag = new Uint8Array([]);
          if (name2 === "AES-GCM")
            tag = new Uint8Array(cipher2.getAuthTag());
        } catch (e) {
          throw new Error("NodeCrypto_EncryptionFailure");
        }
        var data = new Uint8Array(body.length + final.length + tag.length);
        data.set(body);
        data.set(final, body.length);
        data.set(tag, body.length + final.length);
        return data;
      };
      exports2.encrypt = encrypt2;
      var decrypt2 = function(data, key2, _a, nodeCrypto, unwrapKey3) {
        var name2 = _a.name, iv = _a.iv, additionalData = _a.additionalData, tagLength = _a.tagLength;
        if (unwrapKey3 === void 0) {
          unwrapKey3 = false;
        }
        var alg = getNodeName(name2, key2.byteLength, unwrapKey3 ? params_12.default.wrapKeys : params_12.default.ciphers);
        var decipher;
        var body;
        switch (name2) {
          case "AES-GCM": {
            decipher = nodeCrypto.createDecipheriv(alg, key2, iv, {authTagLength: tagLength});
            decipher.setAAD(additionalData);
            body = data.slice(0, data.length - tagLength);
            var tag = data.slice(data.length - tagLength);
            decipher.setAuthTag(tag);
            break;
          }
          case "AES-CTR": {
            if (iv.length === 0 || iv.length > 16)
              throw new Error("InvalidIVLength");
            var counter = new Uint8Array(16);
            counter.set(iv);
            counter[15] += 1;
            decipher = nodeCrypto.createDecipheriv(alg, key2, counter);
            body = data;
            break;
          }
          default: {
            decipher = nodeCrypto.createDecipheriv(alg, key2, iv);
            body = data;
            break;
          }
        }
        var decryptedBody;
        var final;
        try {
          decryptedBody = decipher.update(body);
          final = decipher.final();
        } catch (e) {
          throw new Error("NodeCrypto_DecryptionFailure");
        }
        var msg = new Uint8Array(final.length + decryptedBody.length);
        msg.set(decryptedBody);
        msg.set(final, decryptedBody.length);
        return msg;
      };
      exports2.decrypt = decrypt2;
      var getNodeName = function(name2, keyLength, dict) {
        var alg = dict[name2].nodePrefix;
        alg = "".concat(alg).concat((keyLength * 8).toString());
        return alg + dict[name2].nodeSuffix;
      };
    })(nodeapi$1);
    var webapi$1 = {};
    var __awaiter$1 = commonjsGlobal && commonjsGlobal.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator$1 = commonjsGlobal && commonjsGlobal.__generator || function(thisArg, body) {
      var _ = {label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: []}, f, y, t, g;
      return g = {next: verb(0), throw: verb(1), return: verb(2)}, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v2) {
          return step([n, v2]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return {value: op[1], done: false};
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return {value: op[0] ? op[1] : void 0, done: true};
      }
    };
    Object.defineProperty(webapi$1, "__esModule", {value: true});
    webapi$1.decrypt = webapi$1.encrypt = webapi$1.unwrapKey = webapi$1.wrapKey = void 0;
    var wrapKey$1 = function(keyToBeWrapped, wrappingKey, _a, webCrypto) {
      var name2 = _a.name, iv = _a.iv;
      return __awaiter$1(void 0, void 0, void 0, function() {
        var kek, cek, data, e_1;
        return __generator$1(this, function(_b) {
          switch (_b.label) {
            case 0:
              _b.trys.push([0, 4, , 5]);
              return [4, webCrypto.importKey("raw", wrappingKey, {name: name2}, false, ["wrapKey", "unwrapKey"])];
            case 1:
              kek = _b.sent();
              return [4, webCrypto.importKey("raw", keyToBeWrapped, {name: name2}, true, ["wrapKey", "unwrapKey"])];
            case 2:
              cek = _b.sent();
              return [4, webCrypto.wrapKey("raw", cek, kek, {name: name2, iv})];
            case 3:
              data = _b.sent();
              return [2, new Uint8Array(data)];
            case 4:
              e_1 = _b.sent();
              if (e_1 instanceof Error) {
                throw new Error("WebCrypto_FailedToWrapKey - ".concat(e_1.message));
              } else {
                throw new Error("WebCrypto_FailedToWrapKey");
              }
            case 5:
              return [2];
          }
        });
      });
    };
    webapi$1.wrapKey = wrapKey$1;
    var unwrapKey$1 = function(wrappedKey, unwrappingKey, _a, webCrypto) {
      var name2 = _a.name, iv = _a.iv;
      return __awaiter$1(void 0, void 0, void 0, function() {
        var kek, cek, _b, e_2;
        return __generator$1(this, function(_c) {
          switch (_c.label) {
            case 0:
              _c.trys.push([0, 4, , 5]);
              return [4, webCrypto.importKey("raw", unwrappingKey, {name: name2}, false, ["wrapKey", "unwrapKey"])];
            case 1:
              kek = _c.sent();
              return [4, webCrypto.unwrapKey("raw", wrappedKey, kek, {name: name2, iv}, {name: "AES-GCM"}, true, ["encrypt", "decrypt"])];
            case 2:
              cek = _c.sent();
              _b = Uint8Array.bind;
              return [4, webCrypto.exportKey("raw", cek)];
            case 3:
              return [2, new (_b.apply(Uint8Array, [void 0, _c.sent()]))()];
            case 4:
              e_2 = _c.sent();
              if (e_2 instanceof Error) {
                throw new Error("WebCrypto_FailedToUnwrapKey - ".concat(e_2.message));
              } else {
                throw new Error("WebCrypto_FailedToUnwrapKey");
              }
            case 5:
              return [2];
          }
        });
      });
    };
    webapi$1.unwrapKey = unwrapKey$1;
    var encrypt$3 = function(msg, key2, _a, webCrypto) {
      var _b = _a.name, name2 = _b === void 0 ? "AES-GCM" : _b, iv = _a.iv, additionalData = _a.additionalData, tagLength = _a.tagLength;
      return __awaiter$1(void 0, void 0, void 0, function() {
        var encryptionConfig, sessionKeyObj, data, e_3;
        return __generator$1(this, function(_c) {
          switch (_c.label) {
            case 0:
              encryptionConfig = setCipherParams({name: name2, iv, additionalData, tagLength});
              _c.label = 1;
            case 1:
              _c.trys.push([1, 4, , 5]);
              return [4, webCrypto.importKey("raw", key2, encryptionConfig, false, ["encrypt", "decrypt"])];
            case 2:
              sessionKeyObj = _c.sent();
              return [4, webCrypto.encrypt(encryptionConfig, sessionKeyObj, msg)];
            case 3:
              data = _c.sent();
              return [2, new Uint8Array(data)];
            case 4:
              e_3 = _c.sent();
              if (e_3 instanceof Error) {
                throw new Error("WebCrypto_EncryptionFailure: ".concat(e_3.message));
              } else {
                throw new Error("WebCrypto_EncryptionFailure");
              }
            case 5:
              return [2];
          }
        });
      });
    };
    webapi$1.encrypt = encrypt$3;
    var decrypt$3 = function(data, key2, _a, webCrypto) {
      var name2 = _a.name, iv = _a.iv, additionalData = _a.additionalData, tagLength = _a.tagLength;
      return __awaiter$1(void 0, void 0, void 0, function() {
        var decryptionConfig, sessionKeyObj, msg, e_4;
        return __generator$1(this, function(_b) {
          switch (_b.label) {
            case 0:
              decryptionConfig = setCipherParams({name: name2, iv, additionalData, tagLength});
              _b.label = 1;
            case 1:
              _b.trys.push([1, 4, , 5]);
              return [4, webCrypto.importKey("raw", key2, decryptionConfig, false, ["encrypt", "decrypt"])];
            case 2:
              sessionKeyObj = _b.sent();
              return [4, webCrypto.decrypt(decryptionConfig, sessionKeyObj, data)];
            case 3:
              msg = _b.sent();
              return [2, new Uint8Array(msg)];
            case 4:
              e_4 = _b.sent();
              if (e_4 instanceof Error) {
                throw new Error("WebCrypto_DecryptionFailure: ".concat(e_4.message));
              } else {
                throw new Error("WebCrypto_DecryptionFailure");
              }
            case 5:
              return [2];
          }
        });
      });
    };
    webapi$1.decrypt = decrypt$3;
    var setCipherParams = function(_a) {
      var name2 = _a.name, iv = _a.iv, additionalData = _a.additionalData, tagLength = _a.tagLength;
      var alg = {name: name2, iv, additionalData, tagLength};
      switch (name2) {
        case "AES-GCM": {
          alg.tagLength = tagLength * 8;
          break;
        }
        case "AES-CBC": {
          break;
        }
        case "AES-CTR": {
          if (iv.length === 0 || iv.length > 16)
            throw new Error("InvalidIVLength");
          alg.counter = new Uint8Array(16);
          alg.counter.set(iv);
          alg.counter[15] += 1;
          alg.length = 128;
          break;
        }
      }
      return alg;
    };
    var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, {enumerable: true, get: function() {
        return m[k];
      }});
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o, v2) {
      Object.defineProperty(o, "default", {enumerable: true, value: v2});
    } : function(o, v2) {
      o["default"] = v2;
    });
    var __importStar = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __awaiter = commonjsGlobal && commonjsGlobal.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = commonjsGlobal && commonjsGlobal.__generator || function(thisArg, body) {
      var _ = {label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: []}, f, y, t, g;
      return g = {next: verb(0), throw: verb(1), return: verb(2)}, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v2) {
          return step([n, v2]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return {value: op[1], done: false};
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return {value: op[0] ? op[1] : void 0, done: true};
      }
    };
    var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : {default: mod};
    };
    Object.defineProperty(aes$2, "__esModule", {value: true});
    aes$2.unwrapKey = aes$2.wrapKey = aes$2.decrypt = aes$2.encrypt = void 0;
    var util = __importStar(dist);
    var nodeapi = __importStar(nodeapi$1);
    var webapi = __importStar(webapi$1);
    var params_1 = __importDefault(params);
    var assertAlgorithms = function(_a) {
      var name2 = _a.name, iv = _a.iv, tagLength = _a.tagLength;
      if (params_1.default.ciphers[name2].ivLength) {
        if (!(iv instanceof Uint8Array))
          throw new Error("InvalidArguments");
        if (iv.byteLength < 2 || iv.byteLength > 16)
          throw new Error("InvalidIVLength");
        if (params_1.default.ciphers[name2].staticIvLength && params_1.default.ciphers[name2].ivLength !== iv.byteLength)
          throw new Error("InvalidIVLength");
      }
      if (params_1.default.ciphers[name2].tagLength && tagLength) {
        if (!Number.isInteger(tagLength))
          throw new Error("InvalidArguments");
        if (tagLength < 4 || tagLength > 16)
          throw new Error("InvalidTagLength");
      }
    };
    var encrypt$2 = function(msg, key2, _a) {
      var _b = _a.name, name2 = _b === void 0 ? "AES-GCM" : _b, iv = _a.iv, _c = _a.additionalData, additionalData = _c === void 0 ? new Uint8Array([]) : _c, tagLength = _a.tagLength;
      return __awaiter(void 0, void 0, void 0, function() {
        var env2;
        return __generator(this, function(_d) {
          assertAlgorithms({name: name2, iv, tagLength});
          if (params_1.default.ciphers[name2].tagLength && !tagLength)
            tagLength = params_1.default.ciphers[name2].tagLength;
          env2 = util.getCrypto();
          if (env2.name === "webCrypto") {
            if (typeof env2.crypto.importKey !== "function" || typeof env2.crypto.encrypt !== "function")
              throw new Error("UnsupportedWebCrypto");
            return [2, webapi.encrypt(msg, key2, {name: name2, iv, additionalData, tagLength}, env2.crypto)];
          } else if (env2.name === "nodeCrypto") {
            return [2, nodeapi.encrypt(msg, key2, {name: name2, iv, additionalData, tagLength}, env2.crypto)];
          } else
            throw new Error("UnsupportedEnvironment");
        });
      });
    };
    aes$2.encrypt = encrypt$2;
    var decrypt$2 = function(data, key2, _a) {
      var _b = _a.name, name2 = _b === void 0 ? "AES-GCM" : _b, iv = _a.iv, _c = _a.additionalData, additionalData = _c === void 0 ? new Uint8Array([]) : _c, tagLength = _a.tagLength;
      return __awaiter(void 0, void 0, void 0, function() {
        var env2;
        return __generator(this, function(_d) {
          assertAlgorithms({name: name2, iv, tagLength});
          if (params_1.default.ciphers[name2].tagLength && !tagLength)
            tagLength = params_1.default.ciphers[name2].tagLength;
          env2 = util.getCrypto();
          if (env2.name === "webCrypto") {
            if (typeof env2.crypto.importKey !== "function" || typeof env2.crypto.decrypt !== "function")
              throw new Error("UnsupportedWebCrypto");
            return [2, webapi.decrypt(data, key2, {name: name2, iv, additionalData, tagLength}, env2.crypto)];
          } else if (env2.name === "nodeCrypto") {
            return [2, nodeapi.decrypt(data, key2, {name: name2, iv, additionalData, tagLength}, env2.crypto)];
          } else
            throw new Error("UnsupportedEnvironment");
        });
      });
    };
    aes$2.decrypt = decrypt$2;
    var wrapKey = function(keyToBeWrapped, wrappingKey, _a) {
      var name2 = _a.name;
      return __awaiter(void 0, void 0, void 0, function() {
        var env2, iv;
        return __generator(this, function(_b) {
          if (keyToBeWrapped.length % 8 > 0)
            throw new Error("WrappedKeyMustBeMultipleOf8");
          env2 = util.getCrypto();
          iv = params_1.default.wrapKeys["AES-KW"].defaultIv;
          if (env2.name === "webCrypto") {
            if (typeof env2.crypto.importKey !== "function" || typeof env2.crypto.wrapKey !== "function")
              throw new Error("UnsupportedWebCrypto");
            return [2, webapi.wrapKey(keyToBeWrapped, wrappingKey, {name: name2, iv}, env2.crypto)];
          } else if (env2.name === "nodeCrypto") {
            return [2, nodeapi.wrapKey(keyToBeWrapped, wrappingKey, {name: name2, iv}, env2.crypto)];
          } else {
            throw new Error("UnsupportedEnvironment");
          }
        });
      });
    };
    aes$2.wrapKey = wrapKey;
    var unwrapKey = function(wrappedKey, wrappingKey, _a) {
      var name2 = _a.name;
      return __awaiter(void 0, void 0, void 0, function() {
        var env2, iv;
        return __generator(this, function(_b) {
          env2 = util.getCrypto();
          iv = params_1.default.wrapKeys["AES-KW"].defaultIv;
          if (env2.name === "webCrypto") {
            if (typeof env2.crypto.importKey !== "function" || typeof env2.crypto.unwrapKey !== "function")
              throw new Error("UnsupportedWebCrypto");
            return [2, webapi.unwrapKey(wrappedKey, wrappingKey, {name: name2, iv}, env2.crypto)];
          } else if (env2.name === "nodeCrypto") {
            return [2, nodeapi.unwrapKey(wrappedKey, wrappingKey, {name: name2, iv}, env2.crypto)];
          } else {
            throw new Error("UnsupportedEnvironment");
          }
        });
      });
    };
    aes$2.unwrapKey = unwrapKey;
    (function(exports2) {
      var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        Object.defineProperty(o, k2, {enumerable: true, get: function() {
          return m[k];
        }});
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault2 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o, v2) {
        Object.defineProperty(o, "default", {enumerable: true, value: v2});
      } : function(o, v2) {
        o["default"] = v2;
      });
      var __importStar2 = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding2(result, mod, k);
        }
        __setModuleDefault2(result, mod);
        return result;
      };
      Object.defineProperty(exports2, "__esModule", {value: true});
      exports2.unwrapKey = exports2.wrapKey = exports2.decrypt = exports2.encrypt = void 0;
      var aes2 = __importStar2(aes$2);
      exports2.encrypt = aes2.encrypt;
      exports2.decrypt = aes2.decrypt;
      exports2.wrapKey = aes2.wrapKey;
      exports2.unwrapKey = aes2.unwrapKey;
      exports2.default = {encrypt: exports2.encrypt, decrypt: exports2.decrypt, wrapKey: exports2.wrapKey, unwrapKey: exports2.unwrapKey};
    })(dist$1);
    var aes = /* @__PURE__ */ getDefaultExportFromCjs(dist$1);
    var enc32 = (value) => {
      value = +value;
      const buff = new Uint8Array(4);
      buff[3] = value >>> 24;
      buff[2] = value >>> 16;
      buff[1] = value >>> 8;
      buff[0] = value & 255;
      return buff;
    };
    var readUInt32LE = (buffer2) => {
      const offset = buffer2.byteLength - 4;
      return (buffer2[offset] | buffer2[offset + 1] << 8 | buffer2[offset + 2] << 16) + buffer2[offset + 3] * 16777216;
    };
    var encode = ({iv, bytes}) => concat([iv, bytes]);
    var decode = (bytes) => {
      const iv = bytes.subarray(0, 12);
      bytes = bytes.slice(12);
      return {iv, bytes};
    };
    var code = 3145728 + 1337;
    var concat = (buffers) => Uint8Array.from(buffers.map((b) => [...b]).flat());
    var decrypt$1 = async ({key: key2, value}) => {
      let {bytes, iv} = value;
      bytes = await aes.decrypt(bytes, key2, {name: "AES-GCM", iv, tagLength: 16});
      const len = readUInt32LE(bytes.subarray(0, 4));
      const cid = CID.decode(bytes.subarray(4, 4 + len));
      bytes = bytes.subarray(4 + len);
      return {cid, bytes};
    };
    var encrypt$1 = async ({key: key2, cid, bytes}) => {
      const len = enc32(cid.bytes.byteLength);
      const iv = browserExports$1(12);
      const msg = concat([len, cid.bytes, bytes]);
      bytes = await aes.encrypt(msg, key2, {name: "AES-GCM", iv, tagLength: 16});
      return {value: {bytes, iv}};
    };
    var crypto$1 = (key2) => {
      return {encrypt: (opts) => encrypt$1({key: key2, ...opts}), decrypt: (opts) => decrypt$1({key: key2, ...opts})};
    };
    var name = "mikeal@encrypted-block:aes-gcm";
    var codec = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      code,
      crypto: crypto$1,
      decode,
      decrypt: decrypt$1,
      encode,
      encrypt: encrypt$1,
      name
    });
    var compare$2 = ({bytes: a}, {bytes: b}) => binaryCompare(a, b);
    var CIDEntry = class extends Entry {
      constructor(cid) {
        super({
          address: cid,
          key: cid
        });
        this.cid = cid;
      }
      encodeNode() {
        return this.cid;
      }
      identity() {
        const buffer2 = this.cid.multihash.bytes;
        return readUInt32LE$1(buffer2);
      }
    };
    var CIDNodeEntry = class extends Entry {
      async identity() {
        const {
          multihash: {bytes}
        } = await this.address;
        return readUInt32LE$1(bytes);
      }
    };
    var CIDSetBranch = class extends IPLDBranch {
    };
    var CIDSetLeaf = class extends IPLDLeaf {
    };
    var createGetNode = (get2, cache2, chunker2, codec2, hasher2) => {
      const decoder = (block) => {
        const {value} = block;
        const opts = {
          chunker: chunker2,
          cache: cache2,
          block,
          getNode,
          codec: codec2,
          hasher: hasher2,
          compare: compare$2
        };
        let entries;
        let CLS;
        if (value.leaf) {
          entries = value.leaf.map((cid) => new CIDEntry(cid));
          CLS = CIDSetLeaf;
        } else if (value.branch) {
          const [distance, _entries] = value.branch;
          opts.distance = distance;
          entries = _entries.map(([key2, address]) => new CIDNodeEntry({
            key: key2,
            address
          }));
          CLS = CIDSetBranch;
        } else {
          throw new Error("Unknown block data, does not match schema");
        }
        const entryList = new EntryList({
          entries,
          closed: value.closed
        });
        const node2 = new CLS({
          entryList,
          ...opts
        });
        cache2.set(node2);
        return node2;
      };
      const getNode = (cid) => {
        if (cache2.has(cid))
          return cache2.get(cid);
        return get2(cid).then((block) => decoder(block));
      };
      return getNode;
    };
    var create$3 = ({get: get2, cache: cache2, chunker: chunker2, list, codec: codec2, hasher: hasher2, sorted}) => {
      if (!sorted)
        list = list.sort(compare$2);
      const getNode = createGetNode(get2, cache2, chunker2, codec2, hasher2);
      const opts = {
        list,
        codec: codec2,
        hasher: hasher2,
        chunker: chunker2,
        getNode,
        sorted,
        compare: compare$2,
        cache: cache2,
        LeafClass: CIDSetLeaf,
        LeafEntryClass: CIDEntry,
        BranchClass: CIDSetBranch,
        BranchEntryClass: CIDNodeEntry
      };
      return create$5(opts);
    };
    var load$3 = ({cid, get: get2, cache: cache2, chunker: chunker2, codec: codec2, hasher: hasher2, ...opts}) => {
      const getNode = createGetNode(get2, cache2, chunker2, codec2, hasher2);
      return getNode(cid);
    };
    var createBlock = (bytes, cid) => create$6({cid, bytes, hasher: sha256$2, codec});
    var encrypt = async function* ({get: get2, cids, hasher: hasher2, key: key2, cache: cache2, chunker: chunker2, root: root2}) {
      const set = new Set();
      let eroot;
      for (const string of cids) {
        const cid = CID.parse(string);
        const unencrypted = await get2(cid);
        const block2 = await encode$5({...await encrypt$1({...unencrypted, key: key2}), codec, hasher: hasher2});
        yield block2;
        set.add(block2.cid.toString());
        if (unencrypted.cid.equals(root2))
          eroot = block2.cid;
      }
      if (!eroot)
        throw new Error("cids does not include root");
      const list = [...set].map((s) => CID.parse(s));
      let last;
      for await (const node2 of create$3({list, get: get2, cache: cache2, chunker: chunker2, hasher: hasher2, codec: codec$1})) {
        const block2 = await node2.block;
        yield block2;
        last = block2;
      }
      const head = [eroot, last.cid];
      const block = await encode$5({value: head, codec: codec$1, hasher: hasher2});
      yield block;
    };
    var decrypt = async function* ({root: root2, get: get2, key: key2, cache: cache2, chunker: chunker2, hasher: hasher2}) {
      const o = {...await get2(root2), codec: codec$1, hasher: hasher2};
      const decodedRoot = await decode$5(o);
      const {value: [eroot, tree2]} = decodedRoot;
      const rootBlock = await get2(eroot);
      const cidset = await load$3({cid: tree2, get: get2, cache: cache2, chunker: chunker2, codec, hasher: hasher2});
      const {result: nodes} = await cidset.getAllEntries();
      const unwrap2 = async (eblock) => {
        const {bytes, cid} = await decrypt$1({...eblock, key: key2}).catch((e) => {
          throw new Error("bad key: " + key2.toString("hex"));
        });
        const block = await createBlock(bytes, cid);
        return block;
      };
      const promises = [];
      for (const {cid} of nodes) {
        if (!rootBlock.cid.equals(cid))
          promises.push(get2(cid).then(unwrap2));
      }
      yield* promises;
      yield unwrap2(rootBlock);
    };
    var bitUtils = {};
    function bitSequence$1(bytes, bitStart, bitLength) {
      const startOffset = bitStart % 8;
      const byteCount = Math.ceil((startOffset + bitLength) / 8);
      const byteStart = bitStart >> 3;
      const endOffset = byteCount * 8 - bitLength - startOffset;
      let result = 0;
      for (let i = 0; i < byteCount; i++) {
        let local = bytes[byteStart + i];
        let shift = 0;
        let localBitLength = 8;
        if (i === 0) {
          localBitLength -= startOffset;
        }
        if (i === byteCount - 1) {
          localBitLength -= endOffset;
          shift = endOffset;
          local >>= shift;
        }
        if (localBitLength < 8) {
          const mask2 = (1 << localBitLength) - 1;
          local &= mask2;
        }
        if (i < 3) {
          if (shift < 8) {
            result = result << 8 - shift;
          }
          result |= local;
        } else {
          if (shift < 8) {
            result = result * Math.pow(2, 8 - shift);
          }
          result += local;
        }
      }
      return result;
    }
    var bitSequence_1 = bitSequence$1;
    var bitSequence = bitSequence_1;
    function mask$1(hash2, depth, nbits) {
      return bitSequence(hash2, depth * nbits, nbits);
    }
    function setBit$1(bitmap, position, set) {
      const byte = Math.floor(position / 8);
      const offset = position % 8;
      const has = bitmapHas$1(bitmap, void 0, byte, offset);
      if (set && !has || !set && has) {
        const newBitmap = Uint8Array.from(bitmap);
        let b = bitmap[byte];
        if (set) {
          b |= 1 << offset;
        } else {
          b ^= 1 << offset;
        }
        newBitmap[byte] = b;
        return newBitmap;
      }
      return bitmap;
    }
    function bitmapHas$1(bitmap, position, byte, offset) {
      if (typeof byte !== "number" || typeof offset !== "number") {
        if (position === void 0) {
          throw new Error("`position` expected");
        }
        byte = Math.floor(position / 8);
        offset = position % 8;
      }
      return (bitmap[byte] >> offset & 1) === 1;
    }
    function index$1(bitmap, position) {
      let t = 0;
      for (let i = 0; i < position; i++) {
        if (bitmapHas$1(bitmap, i)) {
          t++;
        }
      }
      return t;
    }
    bitUtils.mask = mask$1;
    bitUtils.setBit = setBit$1;
    bitUtils.bitmapHas = bitmapHas$1;
    bitUtils.index = index$1;
    var {mask, setBit, bitmapHas, index} = bitUtils;
    var defaultBitWidth = 8;
    var defaultBucketSize = 5;
    var hasherRegistry = [];
    var textEncoder = new TextEncoder();
    function assert(condition, message) {
      if (!condition) {
        throw new Error(message || "Unexpected error");
      }
    }
    async function create$2(store, options, map, depth, data) {
      const newNode = new IAMap(store, options, map, depth, data);
      return save(store, newNode);
    }
    async function load$2(store, id, depth = 0, options) {
      if (depth !== 0 && typeof options !== "object") {
        throw new Error("Cannot load() without options at depth > 0");
      }
      const serialized = await store.load(id);
      return fromSerializable(store, id, serialized, options, depth);
    }
    function registerHasher(hashAlg, hashBytes, hasher2) {
      if (!Number.isInteger(hashAlg)) {
        throw new Error("Invalid `hashAlg`");
      }
      if (!Number.isInteger(hashBytes)) {
        throw new TypeError("Invalid `hashBytes`");
      }
      if (typeof hasher2 !== "function") {
        throw new TypeError("Invalid `hasher` function }");
      }
      hasherRegistry[hashAlg] = {hashBytes, hasher: hasher2};
    }
    var KV = class {
      constructor(key2, value) {
        this.key = key2;
        this.value = value;
      }
      toSerializable() {
        return [this.key, this.value];
      }
    };
    KV.fromSerializable = function(obj) {
      assert(Array.isArray(obj));
      assert(obj.length === 2);
      return new KV(obj[0], obj[1]);
    };
    var Element = class {
      constructor(bucket, link) {
        this.bucket = bucket || null;
        this.link = link !== void 0 ? link : null;
        assert(this.bucket === null === (this.link !== null));
      }
      toSerializable() {
        if (this.bucket) {
          return this.bucket.map((c) => {
            return c.toSerializable();
          });
        } else {
          assert(!IAMap.isIAMap(this.link));
          return this.link;
        }
      }
    };
    Element.fromSerializable = function(isLink, obj) {
      if (isLink(obj)) {
        return new Element(void 0, obj);
      } else if (Array.isArray(obj)) {
        return new Element(obj.map(KV.fromSerializable));
      }
      throw new Error("Unexpected error: badly formed data element");
    };
    var IAMap = class {
      constructor(store, options, map, depth, data) {
        if (!store || typeof store.save !== "function" || typeof store.load !== "function" || typeof store.isLink !== "function" || typeof store.isEqual !== "function") {
          throw new TypeError("Invalid `store` option, must be of type: { save(node):id, load(id):node, isEqual(id,id):boolean, isLink(obj):boolean  }");
        }
        this.store = store;
        this.id = null;
        this.config = buildConfig(options);
        const hashBytes = hasherRegistry[this.config.hashAlg].hashBytes;
        if (map !== void 0 && !(map instanceof Uint8Array)) {
          throw new TypeError("`map` must be a Uint8Array");
        }
        const mapLength = Math.ceil(Math.pow(2, this.config.bitWidth) / 8);
        if (map !== void 0 && map.length !== mapLength) {
          throw new Error("`map` must be a Uint8Array of length " + mapLength);
        }
        this.map = map || new Uint8Array(mapLength);
        if (depth !== void 0 && (!Number.isInteger(depth) || depth < 0)) {
          throw new TypeError("`depth` must be an integer >= 0");
        }
        this.depth = depth || 0;
        if (this.depth > Math.floor(hashBytes * 8 / this.config.bitWidth)) {
          throw new Error("Overflow: maximum tree depth reached");
        }
        this.data = Object.freeze(data || []);
        for (const e of this.data) {
          if (!(e instanceof Element)) {
            throw new TypeError("`data` array must contain only `Element` types");
          }
        }
      }
      async set(key2, value, _cachedHash) {
        if (!(key2 instanceof Uint8Array)) {
          key2 = textEncoder.encode(key2);
        }
        const hash2 = _cachedHash instanceof Uint8Array ? _cachedHash : await hasher(this)(key2);
        const bitpos = mask(hash2, this.depth, this.config.bitWidth);
        if (bitmapHas(this.map, bitpos)) {
          const {data, link} = findElement(this, bitpos, key2);
          if (data) {
            if (data.found) {
              if (data.bucketIndex === void 0 || data.bucketEntry === void 0) {
                throw new Error("Unexpected error");
              }
              if (data.bucketEntry.value === value) {
                return this;
              }
              return updateBucket(this, data.elementAt, data.bucketIndex, key2, value);
            } else {
              if (!data.element.bucket) {
                throw new Error("Unexpected error");
              }
              if (data.element.bucket.length >= this.config.bucketSize) {
                return (await replaceBucketWithNode(this, data.elementAt)).set(key2, value, hash2);
              }
              return updateBucket(this, data.elementAt, -1, key2, value);
            }
          } else if (link) {
            const child = await load$2(this.store, link.element.link, this.depth + 1, this.config);
            assert(!!child);
            const newChild = await child.set(key2, value, hash2);
            return updateNode(this, link.elementAt, newChild);
          } else {
            throw new Error("Unexpected error");
          }
        } else {
          return addNewElement(this, bitpos, key2, value);
        }
      }
      async get(key2, _cachedHash) {
        if (!(key2 instanceof Uint8Array)) {
          key2 = textEncoder.encode(key2);
        }
        const hash2 = _cachedHash instanceof Uint8Array ? _cachedHash : await hasher(this)(key2);
        const bitpos = mask(hash2, this.depth, this.config.bitWidth);
        if (bitmapHas(this.map, bitpos)) {
          const {data, link} = findElement(this, bitpos, key2);
          if (data) {
            if (data.found) {
              if (data.bucketIndex === void 0 || data.bucketEntry === void 0) {
                throw new Error("Unexpected error");
              }
              return data.bucketEntry.value;
            }
            return void 0;
          } else if (link) {
            const child = await load$2(this.store, link.element.link, this.depth + 1, this.config);
            assert(!!child);
            return await child.get(key2, hash2);
          } else {
            throw new Error("Unexpected error");
          }
        } else {
          return void 0;
        }
      }
      async has(key2) {
        return await this.get(key2) !== void 0;
      }
      async delete(key2, _cachedHash) {
        if (!(key2 instanceof Uint8Array)) {
          key2 = textEncoder.encode(key2);
        }
        const hash2 = _cachedHash instanceof Uint8Array ? _cachedHash : await hasher(this)(key2);
        assert(hash2 instanceof Uint8Array);
        const bitpos = mask(hash2, this.depth, this.config.bitWidth);
        if (bitmapHas(this.map, bitpos)) {
          const {data, link} = findElement(this, bitpos, key2);
          if (data) {
            if (data.found) {
              if (data.bucketIndex === void 0) {
                throw new Error("Unexpected error");
              }
              if (this.depth !== 0 && this.directNodeCount() === 0 && this.directEntryCount() === this.config.bucketSize + 1) {
                return collapseIntoSingleBucket(this, hash2, data.elementAt, data.bucketIndex);
              } else {
                const lastInBucket = this.data.length === 1;
                const newData = removeFromBucket(this.data, data.elementAt, lastInBucket, data.bucketIndex);
                let newMap = this.map;
                if (lastInBucket) {
                  newMap = setBit(newMap, bitpos, false);
                }
                return create$2(this.store, this.config, newMap, this.depth, newData);
              }
            } else {
              return this;
            }
          } else if (link) {
            const child = await load$2(this.store, link.element.link, this.depth + 1, this.config);
            assert(!!child);
            const newChild = await child.delete(key2, hash2);
            if (this.store.isEqual(newChild.id, link.element.link)) {
              return this;
            }
            assert(newChild.data.length > 0);
            if (newChild.directNodeCount() === 0 && newChild.directEntryCount() === this.config.bucketSize) {
              if (this.directNodeCount() === 1 && this.directEntryCount() === 0) {
                return newChild;
              } else {
                return collapseNodeInline(this, bitpos, newChild);
              }
            } else {
              return updateNode(this, link.elementAt, newChild);
            }
          } else {
            throw new Error("Unexpected error");
          }
        } else {
          return this;
        }
      }
      async size() {
        let c = 0;
        for (const e of this.data) {
          if (e.bucket) {
            c += e.bucket.length;
          } else {
            const child = await load$2(this.store, e.link, this.depth + 1, this.config);
            c += await child.size();
          }
        }
        return c;
      }
      async *keys() {
        for (const e of this.data) {
          if (e.bucket) {
            for (const kv of e.bucket) {
              yield kv.key;
            }
          } else {
            const child = await load$2(this.store, e.link, this.depth + 1, this.config);
            yield* child.keys();
          }
        }
      }
      async *values() {
        for (const e of this.data) {
          if (e.bucket) {
            for (const kv of e.bucket) {
              yield kv.value;
            }
          } else {
            const child = await load$2(this.store, e.link, this.depth + 1, this.config);
            yield* child.values();
          }
        }
      }
      async *entries() {
        for (const e of this.data) {
          if (e.bucket) {
            for (const kv of e.bucket) {
              yield {key: kv.key, value: kv.value};
            }
          } else {
            const child = await load$2(this.store, e.link, this.depth + 1, this.config);
            yield* child.entries();
          }
        }
      }
      async *ids() {
        yield this.id;
        for (const e of this.data) {
          if (e.link) {
            const child = await load$2(this.store, e.link, this.depth + 1, this.config);
            yield* child.ids();
          }
        }
      }
      toSerializable() {
        const map = this.map;
        const data = this.data.map((e) => {
          return e.toSerializable();
        });
        const hamt = [map, data];
        if (this.depth !== 0) {
          return hamt;
        }
        return {
          hashAlg: this.config.hashAlg,
          bucketSize: this.config.bucketSize,
          hamt
        };
      }
      directEntryCount() {
        return this.data.reduce((p, c) => {
          return p + (c.bucket ? c.bucket.length : 0);
        }, 0);
      }
      directNodeCount() {
        return this.data.reduce((p, c) => {
          return p + (c.link ? 1 : 0);
        }, 0);
      }
      async isInvariant() {
        const size = await this.size();
        const entryArity = this.directEntryCount();
        const nodeArity = this.directNodeCount();
        const arity = entryArity + nodeArity;
        let sizePredicate = 2;
        if (nodeArity === 0) {
          sizePredicate = Math.min(2, entryArity);
        }
        const inv1 = size - entryArity >= 2 * (arity - entryArity);
        const inv2 = arity === 0 ? sizePredicate === 0 : true;
        const inv3 = arity === 1 && entryArity === 1 ? sizePredicate === 1 : true;
        const inv4 = arity >= 2 ? sizePredicate === 2 : true;
        const inv5 = nodeArity >= 0 && entryArity >= 0 && entryArity + nodeArity === arity;
        return inv1 && inv2 && inv3 && inv4 && inv5;
      }
      fromChildSerializable(id, serializable, depth) {
        return fromSerializable(this.store, id, serializable, this.config, depth);
      }
    };
    async function save(store, newNode) {
      const id = await store.save(newNode.toSerializable());
      newNode.id = id;
      return newNode;
    }
    function findElement(node2, bitpos, key2) {
      const elementAt = index(node2.map, bitpos);
      const element = node2.data[elementAt];
      assert(!!element);
      if (element.bucket) {
        for (let bucketIndex = 0; bucketIndex < element.bucket.length; bucketIndex++) {
          const bucketEntry = element.bucket[bucketIndex];
          if (byteCompare(bucketEntry.key, key2) === 0) {
            return {data: {found: true, elementAt, element, bucketIndex, bucketEntry}};
          }
        }
        return {data: {found: false, elementAt, element}};
      }
      assert(!!element.link);
      return {link: {elementAt, element}};
    }
    async function addNewElement(node2, bitpos, key2, value) {
      const insertAt = index(node2.map, bitpos);
      const newData = node2.data.slice();
      newData.splice(insertAt, 0, new Element([new KV(key2, value)]));
      const newMap = setBit(node2.map, bitpos, true);
      return create$2(node2.store, node2.config, newMap, node2.depth, newData);
    }
    async function updateBucket(node2, elementAt, bucketAt, key2, value) {
      const oldElement = node2.data[elementAt];
      if (!oldElement.bucket) {
        throw new Error("Unexpected error");
      }
      const newElement = new Element(oldElement.bucket.slice());
      const newKv = new KV(key2, value);
      if (!newElement.bucket) {
        throw new Error("Unexpected error");
      }
      if (bucketAt === -1) {
        newElement.bucket.push(newKv);
        newElement.bucket.sort((a, b) => byteCompare(a.key, b.key));
      } else {
        newElement.bucket[bucketAt] = newKv;
      }
      const newData = node2.data.slice();
      newData[elementAt] = newElement;
      return create$2(node2.store, node2.config, node2.map, node2.depth, newData);
    }
    async function replaceBucketWithNode(node2, elementAt) {
      let newNode = new IAMap(node2.store, node2.config, void 0, node2.depth + 1);
      const element = node2.data[elementAt];
      assert(!!element);
      if (!element.bucket) {
        throw new Error("Unexpected error");
      }
      for (const c of element.bucket) {
        newNode = await newNode.set(c.key, c.value);
      }
      newNode = await save(node2.store, newNode);
      const newData = node2.data.slice();
      newData[elementAt] = new Element(void 0, newNode.id);
      return create$2(node2.store, node2.config, node2.map, node2.depth, newData);
    }
    async function updateNode(node2, elementAt, newChild) {
      assert(!!newChild.id);
      const newElement = new Element(void 0, newChild.id);
      const newData = node2.data.slice();
      newData[elementAt] = newElement;
      return create$2(node2.store, node2.config, node2.map, node2.depth, newData);
    }
    function collapseIntoSingleBucket(node2, hash2, elementAt, bucketIndex) {
      const newMap = setBit(new Uint8Array(node2.map.length), mask(hash2, 0, node2.config.bitWidth), true);
      const newBucket = node2.data.reduce((p, c, i) => {
        if (i === elementAt) {
          if (!c.bucket) {
            throw new Error("Unexpected error");
          }
          if (c.bucket.length === 1) {
            return p;
          } else {
            const tmpBucket = c.bucket.slice();
            tmpBucket.splice(bucketIndex, 1);
            return p.concat(tmpBucket);
          }
        } else {
          if (!c.bucket) {
            throw new Error("Unexpected error");
          }
          return p.concat(c.bucket);
        }
      }, []);
      newBucket.sort((a, b) => byteCompare(a.key, b.key));
      const newElement = new Element(newBucket);
      return create$2(node2.store, node2.config, newMap, 0, [newElement]);
    }
    function removeFromBucket(data, elementAt, lastInBucket, bucketIndex) {
      const newData = data.slice();
      if (!lastInBucket) {
        const oldElement = data[elementAt];
        if (!oldElement.bucket) {
          throw new Error("Unexpected error");
        }
        const newElement = new Element(oldElement.bucket.slice());
        if (!newElement.bucket) {
          throw new Error("Unexpected error");
        }
        newElement.bucket.splice(bucketIndex, 1);
        newData.splice(elementAt, 1, newElement);
      } else {
        newData.splice(elementAt, 1);
      }
      return newData;
    }
    async function collapseNodeInline(node2, bitpos, newNode) {
      assert(newNode.data.length === 1);
      if (!newNode.data[0].bucket) {
        throw new Error("Unexpected error");
      }
      const newBucket = newNode.data[0].bucket.slice();
      const newElement = new Element(newBucket);
      const elementIndex = index(node2.map, bitpos);
      const newData = node2.data.slice();
      newData[elementIndex] = newElement;
      return create$2(node2.store, node2.config, node2.map, node2.depth, newData);
    }
    function buildConfig(options) {
      const config2 = {};
      if (!options) {
        throw new TypeError("Invalid `options` object");
      }
      if (!Number.isInteger(options.hashAlg)) {
        throw new TypeError("Invalid `hashAlg` option");
      }
      if (!hasherRegistry[options.hashAlg]) {
        throw new TypeError(`Unknown hashAlg: '${options.hashAlg}'`);
      }
      config2.hashAlg = options.hashAlg;
      if (options.bitWidth !== void 0) {
        if (Number.isInteger(options.bitWidth)) {
          if (options.bitWidth < 3 || options.bitWidth > 16) {
            throw new TypeError("Invalid `bitWidth` option, must be between 3 and 16");
          }
          config2.bitWidth = options.bitWidth;
        } else {
          throw new TypeError("Invalid `bitWidth` option");
        }
      } else {
        config2.bitWidth = defaultBitWidth;
      }
      if (options.bucketSize !== void 0) {
        if (Number.isInteger(options.bucketSize)) {
          if (options.bucketSize < 2) {
            throw new TypeError("Invalid `bucketSize` option");
          }
          config2.bucketSize = options.bucketSize;
        } else {
          throw new TypeError("Invalid `bucketSize` option");
        }
      } else {
        config2.bucketSize = defaultBucketSize;
      }
      return config2;
    }
    function isRootSerializable(serializable) {
      return typeof serializable === "object" && Number.isInteger(serializable.hashAlg) && Number.isInteger(serializable.bucketSize) && Array.isArray(serializable.hamt) && isSerializable(serializable.hamt);
    }
    function isSerializable(serializable) {
      if (Array.isArray(serializable)) {
        return serializable.length === 2 && serializable[0] instanceof Uint8Array && Array.isArray(serializable[1]);
      }
      return isRootSerializable(serializable);
    }
    function fromSerializable(store, id, serializable, options, depth = 0) {
      let hamt;
      if (depth === 0) {
        if (!isRootSerializable(serializable)) {
          throw new Error("Loaded object does not appear to be an IAMap root (depth==0)");
        }
        options = serializableToOptions(serializable);
        hamt = serializable.hamt;
      } else {
        if (!isSerializable(serializable)) {
          throw new Error("Loaded object does not appear to be an IAMap node (depth>0)");
        }
        hamt = serializable;
      }
      const data = hamt[1].map(Element.fromSerializable.bind(null, store.isLink));
      const node2 = new IAMap(store, options, hamt[0], depth, data);
      if (id != null) {
        node2.id = id;
      }
      return node2;
    }
    function serializableToOptions(serializable) {
      return {
        hashAlg: serializable.hashAlg,
        bitWidth: Math.log2(serializable.hamt[0].length * 8),
        bucketSize: serializable.bucketSize
      };
    }
    IAMap.isIAMap = function isIAMap(node2) {
      return node2 instanceof IAMap;
    };
    function hasher(map) {
      return hasherRegistry[map.config.hashAlg].hasher;
    }
    function byteCompare(b1, b2) {
      let x = b1.length;
      let y = b2.length;
      for (let i = 0, len = Math.min(x, y); i < len; ++i) {
        if (b1[i] !== b2[i]) {
          x = b1[i];
          y = b2[i];
          break;
        }
      }
      if (x < y) {
        return -1;
      }
      if (y < x) {
        return 1;
      }
      return 0;
    }
    var create_1 = create$2;
    var load_1 = load$2;
    var registerHasher_1 = registerHasher;
    var Kinds$1 = {
      Null: (obj) => obj === null,
      Int: (obj) => Number.isInteger(obj),
      Float: (obj) => typeof obj === "number" && Number.isFinite(obj),
      String: (obj) => typeof obj === "string",
      Bool: (obj) => typeof obj === "boolean",
      Bytes: (obj) => obj instanceof Uint8Array,
      Link: (obj) => !Kinds$1.Null(obj) && typeof obj === "object" && obj.asCID === obj,
      List: (obj) => Array.isArray(obj),
      Map: (obj) => !Kinds$1.Null(obj) && typeof obj === "object" && obj.asCID !== obj && !Kinds$1.List(obj) && !Kinds$1.Bytes(obj)
    };
    var Types$1 = {
      Int: Kinds$1.Int,
      "HashMapRoot > hashAlg": (obj) => Types$1.Int(obj),
      "HashMapRoot > bucketSize": (obj) => Types$1.Int(obj),
      Bytes: Kinds$1.Bytes,
      "HashMapNode > map": (obj) => Types$1.Bytes(obj),
      "Element > HashMapNode (anon)": Kinds$1.Link,
      "BucketEntry > key": (obj) => Types$1.Bytes(obj),
      Any: (obj) => Kinds$1.Bool(obj) && Types$1.Bool(obj) || Kinds$1.String(obj) && Types$1.String(obj) || Kinds$1.Bytes(obj) && Types$1.Bytes(obj) || Kinds$1.Int(obj) && Types$1.Int(obj) || Kinds$1.Float(obj) && Types$1.Float(obj) || Kinds$1.Null(obj) && Types$1.Null(obj) || Kinds$1.Link(obj) && Types$1.Link(obj) || Kinds$1.Map(obj) && Types$1.AnyMap(obj) || Kinds$1.List(obj) && Types$1.AnyList(obj),
      Bool: Kinds$1.Bool,
      String: Kinds$1.String,
      Float: Kinds$1.Float,
      Null: Kinds$1.Null,
      Link: Kinds$1.Link,
      AnyMap: (obj) => Kinds$1.Map(obj) && Array.prototype.every.call(Object.values(obj), Types$1.Any),
      AnyList: (obj) => Kinds$1.List(obj) && Array.prototype.every.call(obj, Types$1.Any),
      "BucketEntry > value": (obj) => Types$1.Any(obj),
      BucketEntry: (obj) => Kinds$1.List(obj) && obj.length === 2 && Types$1["BucketEntry > key"](obj[0]) && Types$1["BucketEntry > value"](obj[1]),
      Bucket: (obj) => Kinds$1.List(obj) && Array.prototype.every.call(obj, Types$1.BucketEntry),
      Element: (obj) => Kinds$1.Link(obj) && Types$1["Element > HashMapNode (anon)"](obj) || Kinds$1.List(obj) && Types$1.Bucket(obj),
      "HashMapNode > data (anon)": (obj) => Kinds$1.List(obj) && Array.prototype.every.call(obj, Types$1.Element),
      "HashMapNode > data": (obj) => Types$1["HashMapNode > data (anon)"](obj),
      HashMapNode: (obj) => Kinds$1.List(obj) && obj.length === 2 && Types$1["HashMapNode > map"](obj[0]) && Types$1["HashMapNode > data"](obj[1]),
      "HashMapRoot > hamt": (obj) => Types$1.HashMapNode(obj),
      HashMapRoot: (obj) => {
        const keys2 = obj && Object.keys(obj);
        return Kinds$1.Map(obj) && ["hashAlg", "bucketSize", "hamt"].every((k) => keys2.includes(k)) && Object.entries(obj).every(([name2, value]) => Types$1["HashMapRoot > " + name2] && Types$1["HashMapRoot > " + name2](value));
      }
    };
    var HashMapRoot = Types$1.HashMapRoot;
    var HashMapNode = Types$1.HashMapNode;
    Types$1.Element;
    Types$1.Bucket;
    Types$1.BucketEntry;
    function kind(obj) {
      if (typeof obj === "number") {
        if (Number.isInteger(obj)) {
          return "int";
        }
        return "float";
      }
      if (typeof obj === "string") {
        return "string";
      }
      if (obj === null) {
        return "null";
      }
      if (typeof obj === "boolean") {
        return "bool";
      }
      if (typeof obj === "object" && obj.asCID === obj) {
        return "link";
      }
      if (obj instanceof Uint8Array) {
        return "bytes";
      }
      if (Array.isArray(obj)) {
        return "list";
      }
      if (typeof obj === "object") {
        return "map";
      }
      throw new TypeError(`Unknown IPLD kind for value: ${JSON.stringify(obj)}`);
    }
    function describe(obj) {
      const description2 = describeObject(obj, {types: {}});
      if (!Object.keys(description2.schema.types).length) {
        if (typeof description2.root === "object" && typeof description2.root.link === "object") {
          const name2 = "Link";
          description2.schema.types[name2] = {link: {}};
          description2.root = name2;
        } else if (typeof description2.root === "string") {
          const name2 = `${description2.root}`;
          description2.schema.types[name2] = {[description2.root.toLowerCase()]: {}};
          description2.root = name2;
        } else {
          throw new Error("internal error");
        }
      }
      if (typeof description2.root !== "string") {
        throw new Error("internal error");
      }
      return {schema: description2.schema, root: description2.root};
    }
    function describeObject(obj, schema) {
      const objKind = kind(obj);
      let name2 = `${objKind.charAt(0).toUpperCase()}${objKind.substring(1)}`;
      if (objKind === "null" || objKind === "int" || objKind === "bool" || objKind === "float" || objKind === "string" || objKind === "bytes") {
        return {schema, root: name2};
      }
      if (objKind === "link") {
        return {schema, root: {link: {}}};
      }
      const fieldNames = [];
      const entries = objKind === "map" ? Object.entries(obj) : obj.map((e, i) => [`f${i}`, e]);
      for (const [fieldName, value] of entries) {
        fieldNames.push({fieldName, root: describeObject(value, schema).root});
      }
      let unique = true;
      for (let i = 1; i < fieldNames.length; i++) {
        if (fieldNames[i].root !== fieldNames[i - 1].root) {
          unique = false;
          break;
        }
      }
      name2 = `${name2}_1`;
      let type;
      if (unique) {
        const valueType = fieldNames.length ? fieldNames[0].root : "Any";
        if (objKind === "map") {
          type = {map: {keyType: "String", valueType}};
        } else if (objKind === "list") {
          type = {list: {valueType}};
        } else {
          throw new Error(`Unexpected object kind: ${objKind}`);
        }
      } else {
        name2 = "Struct_1";
        type = {
          struct: {fields: {}}
        };
        for (const field of fieldNames) {
          type.struct.fields[field.fieldName] = {type: field.root};
        }
        if (objKind === "list") {
          type.struct.representation = {tuple: {}};
        }
      }
      while (schema.types[name2]) {
        if (deepEqual(schema.types[name2], type)) {
          break;
        }
        name2 = name2.split("_").map((s, i) => i ? parseInt(s, 10) + 1 : s).join("_");
      }
      schema.types[name2] = type;
      return {schema, root: name2};
    }
    function deepEqual(o1, o2) {
      const k1 = kind(o1);
      const k2 = kind(o2);
      if (k1 !== k2) {
        return false;
      }
      switch (k1) {
        case "bool":
        case "string":
        case "int":
        case "float":
        case "null":
          return o1 === o2;
        case "map":
          return deepEqual(Object.entries(o1), Object.entries(o2));
        case "list":
          if (o1.length !== o2.length) {
            return false;
          }
          for (let i = 0; i < o1.length; i++) {
            if (!deepEqual(o1[i], o2[i])) {
              return false;
            }
          }
      }
      return true;
    }
    var noop = (s) => s;
    var noopHighlighter = {
      keyword: noop,
      builtin: noop,
      operator: noop,
      number: noop,
      string: noop,
      className: noop,
      punctuation: noop
    };
    function print(schema, indent = "  ", highlighter = {}) {
      if (!schema || typeof schema.types !== "object") {
        throw new Error("Invalid schema");
      }
      highlighter = Object.assign({}, noopHighlighter, highlighter);
      let str = "";
      str += printAdvanced(schema, indent, highlighter);
      str += printTypes(schema, indent, highlighter);
      return str;
    }
    function printAdvanced(schema, indent, highlighter) {
      let str = "";
      if (typeof schema.advanced === "object") {
        for (const advanced of Object.keys(schema.advanced)) {
          str += `${highlighter.keyword("advanced")} ${highlighter.className(advanced)}

`;
        }
      }
      return str;
    }
    function printTypes(schema, indent, highlighter) {
      let str = "";
      for (const [type, defn] of Object.entries(schema.types)) {
        str += `${highlighter.keyword("type")} ${highlighter.className(type)} ${printType(defn, indent, highlighter)}

`;
      }
      return str.replace(/\n\n$/m, "");
    }
    function kindFromDefinition(defn) {
      const [kind2, more] = Object.keys(defn);
      if (!kind2) {
        throw new Error("Invalid schema, missing kind");
      }
      if (more !== void 0) {
        throw new Error("Invalid schema more than one kind");
      }
      return kind2;
    }
    function printType(defn, indent, highlighter) {
      const kind2 = kindFromDefinition(defn);
      if (["map", "list", "link", "copy"].includes(kind2)) {
        return printTypeTerm(defn, indent, highlighter);
      }
      if (["struct", "union", "enum"].includes(kind2)) {
        return `${highlighter.builtin(kind2)} ${printTypeTerm(defn, indent, highlighter)}`;
      }
      if ((kind2 === "bytes" || kind2 === "string") && defn[kind2].representation && typeof defn[kind2].representation.advanced === "string") {
        return `${kind2} ${highlighter.builtin("representation")} advanced ${defn[kind2].representation.advanced}`;
      }
      return kind2;
    }
    function printTypeTerm(defn, indent, highlighter) {
      if (typeof defn === "string") {
        return defn;
      }
      const kind2 = kindFromDefinition(defn);
      if (typeof printTypeTerm[kind2] !== "function") {
        throw new Error(`Invalid schema unsupported kind (${kind2})`);
      }
      return printTypeTerm[kind2](defn[kind2], indent, highlighter);
    }
    printTypeTerm.link = function link(defn, indent, highlighter) {
      return `${highlighter.punctuation("&")}${printTypeTerm(defn.expectedType || "Any", indent, highlighter)}`;
    };
    printTypeTerm.copy = function copy(defn, indent, highlighter) {
      return `${highlighter.operator("=")} ${defn.fromType}`;
    };
    printTypeTerm.map = function map(defn, indent, highlighter) {
      if (typeof defn.keyType !== "string") {
        throw new Error('Invalid schema, map definition needs a "keyType"');
      }
      if (!defn.valueType) {
        throw new Error('Invalid schema, map definition needs a "keyType"');
      }
      const nullable = defn.valueNullable === true ? "nullable " : "";
      let str = `${highlighter.punctuation("{")}${printTypeTerm(defn.keyType, indent, highlighter)}:${nullable}${printTypeTerm(defn.valueType, indent, highlighter)}${highlighter.punctuation("}")}`;
      if (defn.representation) {
        const repr = reprStrategy(defn);
        if (repr === "listpairs") {
          str += ` ${highlighter.builtin("representation")} listpairs`;
        } else if (repr === "stringpairs") {
          str += stringpairs(indent, "map", defn.representation.stringpairs, highlighter);
        } else if (repr === "advanced") {
          str += ` ${highlighter.builtin("representation")} advanced ${defn.representation.advanced}`;
        }
      }
      return str;
    };
    printTypeTerm.list = function list(defn, indent, highlighter) {
      if (!defn.valueType) {
        throw new Error('Invalid schema, list definition needs a "keyType"');
      }
      const nullable = defn.valueNullable === true ? "nullable " : "";
      let str = `${highlighter.punctuation("[")}${nullable}${printTypeTerm(defn.valueType, indent, highlighter)}${highlighter.punctuation("]")}`;
      if (defn.representation) {
        if (reprStrategy(defn) === "advanced") {
          str += ` ${highlighter.builtin("representation")} advanced ${defn.representation.advanced}`;
        }
      }
      return str;
    };
    printTypeTerm.struct = function struct(defn, indent, highlighter) {
      if (typeof defn.fields !== "object") {
        throw new Error('Invalid schema, struct requires a "fields" map');
      }
      let str = highlighter.punctuation("{");
      for (const [name2, fieldDefn] of Object.entries(defn.fields)) {
        const optional = fieldDefn.optional === true ? highlighter.keyword("optional") + " " : "";
        const nullable = fieldDefn.nullable === true ? highlighter.keyword("nullable") + " " : "";
        let fieldRepr = "";
        if (defn.representation && defn.representation.map && typeof defn.representation.map.fields === "object") {
          const fr = defn.representation.map.fields[name2];
          if (typeof fr === "object") {
            const hasRename = typeof fr.rename === "string";
            const hasImplicit = fr.implicit !== void 0;
            if (hasRename || hasImplicit) {
              fieldRepr = ` ${highlighter.punctuation("(")}`;
              if (hasRename) {
                fieldRepr += `${highlighter.keyword("rename")} ${highlighter.string(`"${fr.rename}"`)}`;
                if (hasImplicit) {
                  fieldRepr += " ";
                }
              }
              if (hasImplicit) {
                const impl = typeof fr.implicit === "string" ? highlighter.string(`"${fr.implicit}"`) : typeof fr.implicit === "number" ? highlighter.number(fr.implicit) : highlighter.keyword(fr.implicit);
                fieldRepr += `${highlighter.keyword("implicit")} ${impl}`;
              }
              fieldRepr += highlighter.punctuation(")");
            }
          }
        }
        const fieldType = typeof fieldDefn.type === "string" ? fieldDefn.type : printTypeTerm(fieldDefn.type, indent, highlighter);
        str += `
${indent}${name2} ${optional}${nullable}${fieldType}${fieldRepr}`;
      }
      if (str[str.length - 1] !== highlighter.punctuation("{")) {
        str += "\n";
      }
      str += highlighter.punctuation("}");
      if (defn.representation) {
        const repr = reprStrategy(defn);
        if (repr === "listpairs") {
          str += ` ${highlighter.builtin("representation")} listpairs`;
        } else if (repr === "stringjoin") {
          if (typeof defn.representation.stringjoin.join !== "string") {
            throw new Error("Invalid schema, struct stringjoin representations require an join string");
          }
          str += ` ${highlighter.builtin("representation")} stringjoin ${highlighter.punctuation("{")}
`;
          str += `${indent}join ${highlighter.string(`"${defn.representation.stringjoin.join}"`)}
`;
          str += fieldOrder(indent, defn.representation.stringjoin.fieldOrder, highlighter);
          str += highlighter.punctuation("}");
        } else if (repr === "stringpairs") {
          str += stringpairs(indent, "struct", defn.representation.stringpairs, highlighter);
        } else if (repr === "tuple") {
          str += ` ${highlighter.builtin("representation")} tuple`;
          if (Array.isArray(defn.representation.tuple.fieldOrder)) {
            str += ` ${highlighter.punctuation("{")}
`;
            str += fieldOrder(indent, defn.representation.tuple.fieldOrder, highlighter);
            str += highlighter.punctuation("}");
          }
        } else if (repr === "advanced") {
          str += ` ${highlighter.builtin("representation")} advanced ${defn.representation.advanced}`;
        }
      }
      return str;
    };
    function fieldOrder(indent, fieldOrder2, highlighter) {
      let str = "";
      if (Array.isArray(fieldOrder2)) {
        const fo = fieldOrder2.map((f) => highlighter.string(`"${f}"`)).join(", ");
        str += `${indent}fieldOrder ${highlighter.punctuation("[")}${fo}${highlighter.punctuation("]")}
`;
      }
      return str;
    }
    function stringpairs(indent, kind2, stringpairs2, highlighter) {
      let str = "";
      if (typeof stringpairs2.innerDelim !== "string") {
        throw new Error(`Invalid schema, ${kind2} stringpairs representations require an innerDelim string`);
      }
      if (typeof stringpairs2.entryDelim !== "string") {
        throw new Error(`Invalid schema, ${kind2} stringpairs representations require an entryDelim string`);
      }
      str += ` ${highlighter.builtin("representation")} stringpairs ${highlighter.punctuation("{")}
`;
      str += `${indent}innerDelim ${highlighter.string(`"${stringpairs2.innerDelim}"`)}
`;
      str += `${indent}entryDelim ${highlighter.string(`"${stringpairs2.entryDelim}"`)}
`;
      str += highlighter.punctuation("}");
      return str;
    }
    function reprStrategy(defn) {
      if (typeof defn.representation !== "object") {
        throw new Error("Expected 'representation' property of definition");
      }
      const keys2 = Object.keys(defn.representation);
      if (keys2.length !== 1) {
        throw new Error("Expected exactly one 'representation' field");
      }
      const repr = keys2[0];
      if (repr === "advanced") {
        if (typeof defn.representation[repr] !== "string") {
          throw new Error("Expected representation 'advanced' to be an string");
        }
      } else {
        if (typeof defn.representation[repr] !== "object") {
          throw new Error(`Expected representation '${repr}' to be an object`);
        }
      }
      return repr;
    }
    printTypeTerm.union = function union(defn, indent, highlighter) {
      if (typeof defn.representation !== "object") {
        throw new Error("Invalid schema, unions require a representation");
      }
      let str = highlighter.punctuation("{");
      const repr = reprStrategy(defn);
      if (repr === "kinded") {
        for (const [kind2, type] of Object.entries(defn.representation.kinded)) {
          str += `
${indent}${highlighter.punctuation("|")} ${printTypeTerm(type, indent, highlighter)} ${kind2}`;
        }
        str += `
${highlighter.punctuation("}")} ${highlighter.builtin("representation")} kinded`;
      } else if (repr === "stringprefix" || repr === "bytesprefix") {
        if (typeof defn.representation[repr].prefixes !== "object") {
          throw new Error(`Invalid schema, ${repr} unions require a representation prefixes map`);
        }
        for (const [key2, type] of Object.entries(defn.representation[repr].prefixes)) {
          str += `
${indent}${highlighter.punctuation("|")} ${printTypeTerm(type, indent, highlighter)} ${highlighter.string(`"${key2}"`)}`;
        }
        str += `
${highlighter.punctuation("}")} ${highlighter.builtin("representation")} ${repr}`;
      } else if (repr === "keyed") {
        if (typeof defn.representation[repr] !== "object") {
          throw new Error(`Invalid schema, ${repr} unions require a representation keyed map`);
        }
        for (const [key2, type] of Object.entries(defn.representation[repr])) {
          str += `
${indent}${highlighter.punctuation("|")} ${printTypeTerm(type, indent, highlighter)} ${highlighter.string(`"${key2}"`)}`;
        }
        str += `
${highlighter.punctuation("}")} ${highlighter.builtin("representation")} ${repr}`;
      } else if (repr === "inline") {
        if (typeof defn.representation.inline.discriminantTable !== "object") {
          throw new Error("Invalid schema, inline unions require a discriminantTable map");
        }
        if (typeof defn.representation.inline.discriminantKey !== "string") {
          throw new Error("Invalid schema, inline unions require a discriminantKey string");
        }
        for (const [key2, type] of Object.entries(defn.representation.inline.discriminantTable)) {
          str += `
${indent}${highlighter.punctuation("|")} ${printTypeTerm(type, indent, highlighter)} ${highlighter.string(`"${key2}"`)}`;
        }
        str += `
${highlighter.punctuation("}")} ${highlighter.builtin("representation")} inline ${highlighter.punctuation("{")}
${indent}discriminantKey ${highlighter.string(`"${defn.representation.inline.discriminantKey}"`)}
${highlighter.punctuation("}")}`;
      } else if (repr === "envelope") {
        if (typeof defn.representation.envelope.discriminantTable !== "object") {
          throw new Error("Invalid schema, envelope unions require a discriminantTable map");
        }
        if (typeof defn.representation.envelope.discriminantKey !== "string") {
          throw new Error("Invalid schema, envelope unions require a discriminantKey string");
        }
        if (typeof defn.representation.envelope.contentKey !== "string") {
          throw new Error("Invalid schema, envelope unions require a contentKey string");
        }
        for (const [key2, type] of Object.entries(defn.representation.envelope.discriminantTable)) {
          str += `
${indent}${highlighter.punctuation("|")} ${printTypeTerm(type, indent, highlighter)} ${highlighter.string(`"${key2}"`)}`;
        }
        str += `
${highlighter.punctuation("}")} ${highlighter.builtin("representation")} envelope ${highlighter.punctuation("{")}`;
        str += `
${indent}discriminantKey ${highlighter.string(`"${defn.representation.envelope.discriminantKey}"`)}`;
        str += `
${indent}contentKey ${highlighter.string(`"${defn.representation.envelope.contentKey}"`)}`;
        str += `
${highlighter.punctuation("}")}`;
      } else {
        throw new Error(`Invalid schema, unknown union representation type ${Object.keys(defn.representation)[0]}`);
      }
      return str;
    };
    printTypeTerm.enum = function _enum(defn, indent, highlighter) {
      if (typeof defn.representation !== "object") {
        throw new Error('Invalid schema, enum requires a "representation" map');
      }
      const repr = reprStrategy(defn);
      if (repr !== "string" && repr !== "int") {
        throw new Error('Invalid schema, enum requires a "string" or "int" representation map');
      }
      let str = highlighter.punctuation("{");
      for (const ev of defn.members) {
        str += `
${indent}${highlighter.punctuation("|")} ${ev}`;
        const sv = defn.representation.string && defn.representation.string[ev] || defn.representation.int && defn.representation.int[ev];
        if (sv !== void 0) {
          str += ` ${highlighter.punctuation("(")}${highlighter.string(`"${sv}"`)}${highlighter.punctuation(")")}`;
        }
      }
      str += `
${highlighter.punctuation("}")}`;
      if (defn.representation.int) {
        str += ` ${highlighter.builtin("representation")} int`;
      }
      return str;
    };
    var DEFAULT_HASHER = sha256$2;
    var DEFAULT_HASH_BYTES = 32;
    var DEFAULT_BITWIDTH = 5;
    var DEFAULT_BUCKET_SIZE = 3;
    var textDecoder = new TextDecoder();
    var HashMapImpl = class {
      constructor(iamap) {
        this._iamap = iamap;
      }
      async get(key2) {
        return this._iamap.get(key2);
      }
      async has(key2) {
        return this._iamap.has(key2);
      }
      async size() {
        return this._iamap.size();
      }
      async set(key2, value) {
        this._iamap = await this._iamap.set(key2, value);
      }
      async delete(key2) {
        this._iamap = await this._iamap.delete(key2);
      }
      async *values() {
        yield* this._iamap.values();
      }
      async *keys() {
        for await (const key2 of this._iamap.keys()) {
          yield textDecoder.decode(key2);
        }
      }
      async *keysRaw() {
        yield* this._iamap.keys();
      }
      async *entries() {
        for await (const {key: key2, value} of this._iamap.entries()) {
          yield [textDecoder.decode(key2), value];
        }
      }
      async *entriesRaw() {
        for await (const {key: key2, value} of this._iamap.entries()) {
          yield [key2, value];
        }
      }
      async *cids() {
        yield* this._iamap.ids();
      }
      get cid() {
        return this._iamap.id;
      }
      static async create(loader, options) {
        return _load(loader, null, options);
      }
      static async load(loader, root2, options) {
        return _load(loader, root2, options);
      }
    };
    async function _load(loader, root2, options) {
      const cid = CID.asCID(root2);
      if (!loader || typeof loader.get !== "function" || typeof loader.put !== "function") {
        throw new TypeError("'loader' object with get() and put() methods is required");
      }
      if (typeof options !== "object") {
        throw new TypeError("An 'options' argument is required");
      }
      if (!("blockCodec" in options) || typeof options.blockCodec !== "object" || typeof options.blockCodec.code !== "number" || typeof options.blockCodec.encode !== "function" || typeof options.blockCodec.decode !== "function") {
        throw new TypeError("A valid 'blockCodec' option is required");
      }
      const codec2 = options.blockCodec;
      if (!("blockHasher" in options) || typeof options.blockHasher !== "object" || typeof options.blockHasher.digest !== "function" || typeof options.blockHasher.code !== "number") {
        throw new TypeError("A valid 'blockHasher' option is required");
      }
      const hasher2 = options.blockHasher;
      const hamtHasher = (() => {
        if ("hasher" in options) {
          if (typeof options.hasher !== "object" || typeof options.hasher.digest !== "function" || typeof options.hasher.code !== "number") {
            throw new TypeError("'hasher' option must be a Multihasher");
          }
          return options.hasher;
        }
        return DEFAULT_HASHER;
      })();
      const hashBytes = (() => {
        if ("hashBytes" in options) {
          if (typeof options.hashBytes !== "number") {
            throw new TypeError("'hashBytes' option must be a number");
          }
          return options.hashBytes;
        }
        return DEFAULT_HASH_BYTES;
      })();
      const hashFn = async (bytes) => {
        const hash2 = await sha256$2.digest(bytes);
        return hash2.digest;
      };
      registerHasher_1(hamtHasher.code, hashBytes, hashFn);
      const bitWidth = (() => {
        if ("bitWidth" in options) {
          if (typeof options.bitWidth !== "number") {
            throw new TypeError("'bitWidth' option must be a number");
          }
          return options.bitWidth;
        }
        return DEFAULT_BITWIDTH;
      })();
      const bucketSize = (() => {
        if ("bucketSize" in options) {
          if (typeof options.bucketSize !== "number") {
            throw new TypeError("'bucketSize' option must be a number");
          }
          return options.bucketSize;
        }
        return DEFAULT_BUCKET_SIZE;
      })();
      const iamapOptions = {hashAlg: hamtHasher.code, bitWidth, bucketSize};
      const store = {
        async load(cid2) {
          const bytes = await loader.get(cid2);
          if (!bytes) {
            throw new Error(`Could not load block for: ${cid2}`);
          }
          const block = await create$6({bytes, cid: cid2, hasher: hasher2, codec: codec2});
          validateBlock(block.value);
          return block.value;
        },
        async save(value) {
          validateBlock(value);
          const block = await encode$5({value, codec: codec2, hasher: hasher2});
          await loader.put(block.cid, block.bytes);
          return block.cid;
        },
        isEqual(cid1, cid2) {
          return cid1.equals(cid2);
        },
        isLink(obj) {
          return CID.asCID(obj) != null;
        }
      };
      let iamap;
      if (cid) {
        iamap = await load_1(store, cid);
      } else {
        iamap = await create_1(store, iamapOptions);
      }
      return new HashMapImpl(iamap);
    }
    function validateBlock(block) {
      if (!HashMapNode(block) && !HashMapRoot(block)) {
        const description2 = print(describe(block).schema);
        throw new Error(`Internal error: unexpected layout for HashMap block does not match schema, got:
${description2}`);
      }
    }
    var create$1 = HashMapImpl.create;
    var load$1 = HashMapImpl.load;
    var Kinds = {
      Null: (obj) => obj === null,
      Int: (obj) => Number.isInteger(obj),
      Float: (obj) => typeof obj === "number" && Number.isFinite(obj),
      String: (obj) => typeof obj === "string",
      Bool: (obj) => typeof obj === "boolean",
      Bytes: (obj) => obj instanceof Uint8Array,
      Link: (obj) => !Kinds.Null(obj) && typeof obj === "object" && obj.asCID === obj,
      List: (obj) => Array.isArray(obj),
      Map: (obj) => !Kinds.Null(obj) && typeof obj === "object" && obj.asCID !== obj && !Kinds.List(obj) && !Kinds.Bytes(obj)
    };
    var Types = {
      Int: Kinds.Int,
      "CarHeader > version": (obj) => Types.Int(obj),
      "CarHeader > roots (anon) > valueType (anon)": Kinds.Link,
      "CarHeader > roots (anon)": (obj) => Kinds.List(obj) && Array.prototype.every.call(obj, Types["CarHeader > roots (anon) > valueType (anon)"]),
      "CarHeader > roots": (obj) => Types["CarHeader > roots (anon)"](obj),
      CarHeader: (obj) => {
        const keys2 = obj && Object.keys(obj);
        return Kinds.Map(obj) && ["version"].every((k) => keys2.includes(k)) && Object.entries(obj).every(([name2, value]) => Types["CarHeader > " + name2] && Types["CarHeader > " + name2](value));
      }
    };
    var CarHeader = Types.CarHeader;
    var CIDV0_BYTES = {
      SHA2_256: 18,
      LENGTH: 32,
      DAG_PB: 112
    };
    var V2_HEADER_LENGTH = 16 + 8 + 8 + 8;
    function decodeVarint(bytes, seeker) {
      if (!bytes.length) {
        throw new Error("Unexpected end of data");
      }
      const i = varint.decode(bytes);
      seeker.seek(varint.decode.bytes);
      return i;
    }
    function decodeV2Header(bytes) {
      const dv = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);
      let offset = 0;
      const header = {
        version: 2,
        characteristics: [
          dv.getBigUint64(offset, true),
          dv.getBigUint64(offset += 8, true)
        ],
        dataOffset: Number(dv.getBigUint64(offset += 8, true)),
        dataSize: Number(dv.getBigUint64(offset += 8, true)),
        indexOffset: Number(dv.getBigUint64(offset += 8, true))
      };
      return header;
    }
    function getMultihashLength(bytes) {
      varint.decode(bytes);
      const codeLength = varint.decode.bytes;
      const length2 = varint.decode(bytes.subarray(varint.decode.bytes));
      const lengthLength = varint.decode.bytes;
      const mhLength = codeLength + lengthLength + length2;
      return mhLength;
    }
    async function readHeader(reader, strictVersion) {
      const length2 = decodeVarint(await reader.upTo(8), reader);
      if (length2 === 0) {
        throw new Error("Invalid CAR header (zero length)");
      }
      const header = await reader.exactly(length2, true);
      const block = decode$3(header);
      if (!CarHeader(block)) {
        throw new Error("Invalid CAR header format");
      }
      if (block.version !== 1 && block.version !== 2 || strictVersion !== void 0 && block.version !== strictVersion) {
        throw new Error(`Invalid CAR version: ${block.version}${strictVersion !== void 0 ? ` (expected ${strictVersion})` : ""}`);
      }
      const hasRoots = Array.isArray(block.roots);
      if (block.version === 1 && !hasRoots || block.version === 2 && hasRoots) {
        throw new Error("Invalid CAR header format");
      }
      if (block.version === 1) {
        return block;
      }
      const v2Header = decodeV2Header(await reader.exactly(V2_HEADER_LENGTH, true));
      reader.seek(v2Header.dataOffset - reader.pos);
      const v1Header = await readHeader(reader, 1);
      return Object.assign(v1Header, v2Header);
    }
    async function readCid(reader) {
      const first = await reader.exactly(2, false);
      if (first[0] === CIDV0_BYTES.SHA2_256 && first[1] === CIDV0_BYTES.LENGTH) {
        const bytes2 = await reader.exactly(34, true);
        const multihash2 = decode$7(bytes2);
        return CID.create(0, CIDV0_BYTES.DAG_PB, multihash2);
      }
      const version2 = decodeVarint(await reader.upTo(8), reader);
      if (version2 !== 1) {
        throw new Error(`Unexpected CID version (${version2})`);
      }
      const codec2 = decodeVarint(await reader.upTo(8), reader);
      const bytes = await reader.exactly(getMultihashLength(await reader.upTo(8)), true);
      const multihash = decode$7(bytes);
      return CID.create(version2, codec2, multihash);
    }
    async function readBlockHead(reader) {
      const start = reader.pos;
      let length2 = decodeVarint(await reader.upTo(8), reader);
      if (length2 === 0) {
        throw new Error("Invalid CAR section (zero length)");
      }
      length2 += reader.pos - start;
      const cid = await readCid(reader);
      const blockLength2 = length2 - Number(reader.pos - start);
      return {cid, length: length2, blockLength: blockLength2};
    }
    async function readBlock(reader) {
      const {cid, blockLength: blockLength2} = await readBlockHead(reader);
      const bytes = await reader.exactly(blockLength2, true);
      return {bytes, cid};
    }
    async function readBlockIndex(reader) {
      const offset = reader.pos;
      const {cid, length: length2, blockLength: blockLength2} = await readBlockHead(reader);
      const index2 = {cid, length: length2, blockLength: blockLength2, offset, blockOffset: reader.pos};
      reader.seek(index2.blockLength);
      return index2;
    }
    function createDecoder(reader) {
      const headerPromise = (async () => {
        const header = await readHeader(reader);
        if (header.version === 2) {
          const v1length = reader.pos - header.dataOffset;
          reader = limitReader(reader, header.dataSize - v1length);
        }
        return header;
      })();
      return {
        header: () => headerPromise,
        async *blocks() {
          await headerPromise;
          while ((await reader.upTo(8)).length > 0) {
            yield await readBlock(reader);
          }
        },
        async *blocksIndex() {
          await headerPromise;
          while ((await reader.upTo(8)).length > 0) {
            yield await readBlockIndex(reader);
          }
        }
      };
    }
    function bytesReader(bytes) {
      let pos = 0;
      return {
        async upTo(length2) {
          const out = bytes.subarray(pos, pos + Math.min(length2, bytes.length - pos));
          return out;
        },
        async exactly(length2, seek = false) {
          if (length2 > bytes.length - pos) {
            throw new Error("Unexpected end of data");
          }
          const out = bytes.subarray(pos, pos + length2);
          if (seek) {
            pos += length2;
          }
          return out;
        },
        seek(length2) {
          pos += length2;
        },
        get pos() {
          return pos;
        }
      };
    }
    function chunkReader(readChunk) {
      let pos = 0;
      let have = 0;
      let offset = 0;
      let currentChunk = new Uint8Array(0);
      const read2 = async (length2) => {
        have = currentChunk.length - offset;
        const bufa = [currentChunk.subarray(offset)];
        while (have < length2) {
          const chunk = await readChunk();
          if (chunk == null) {
            break;
          }
          if (have < 0) {
            if (chunk.length > have) {
              bufa.push(chunk.subarray(-have));
            }
          } else {
            bufa.push(chunk);
          }
          have += chunk.length;
        }
        currentChunk = new Uint8Array(bufa.reduce((p, c) => p + c.length, 0));
        let off2 = 0;
        for (const b of bufa) {
          currentChunk.set(b, off2);
          off2 += b.length;
        }
        offset = 0;
      };
      return {
        async upTo(length2) {
          if (currentChunk.length - offset < length2) {
            await read2(length2);
          }
          return currentChunk.subarray(offset, offset + Math.min(currentChunk.length - offset, length2));
        },
        async exactly(length2, seek = false) {
          if (currentChunk.length - offset < length2) {
            await read2(length2);
          }
          if (currentChunk.length - offset < length2) {
            throw new Error("Unexpected end of data");
          }
          const out = currentChunk.subarray(offset, offset + length2);
          if (seek) {
            pos += length2;
            offset += length2;
          }
          return out;
        },
        seek(length2) {
          pos += length2;
          offset += length2;
        },
        get pos() {
          return pos;
        }
      };
    }
    function asyncIterableReader(asyncIterable) {
      const iterator = asyncIterable[Symbol.asyncIterator]();
      async function readChunk() {
        const next = await iterator.next();
        if (next.done) {
          return null;
        }
        return next.value;
      }
      return chunkReader(readChunk);
    }
    function limitReader(reader, byteLimit) {
      let bytesRead = 0;
      return {
        async upTo(length2) {
          let bytes = await reader.upTo(length2);
          if (bytes.length + bytesRead > byteLimit) {
            bytes = bytes.subarray(0, byteLimit - bytesRead);
          }
          return bytes;
        },
        async exactly(length2, seek = false) {
          const bytes = await reader.exactly(length2, seek);
          if (bytes.length + bytesRead > byteLimit) {
            throw new Error("Unexpected end of data");
          }
          if (seek) {
            bytesRead += length2;
          }
          return bytes;
        },
        seek(length2) {
          bytesRead += length2;
          reader.seek(length2);
        },
        get pos() {
          return reader.pos;
        }
      };
    }
    var CarReader = class {
      constructor(header, blocks) {
        this._header = header;
        this._blocks = blocks;
        this._keys = blocks.map((b) => b.cid.toString());
      }
      get version() {
        return this._header.version;
      }
      async getRoots() {
        return this._header.roots;
      }
      async has(key2) {
        return this._keys.indexOf(key2.toString()) > -1;
      }
      async get(key2) {
        const index2 = this._keys.indexOf(key2.toString());
        return index2 > -1 ? this._blocks[index2] : void 0;
      }
      async *blocks() {
        for (const block of this._blocks) {
          yield block;
        }
      }
      async *cids() {
        for (const block of this._blocks) {
          yield block.cid;
        }
      }
      static async fromBytes(bytes) {
        if (!(bytes instanceof Uint8Array)) {
          throw new TypeError("fromBytes() requires a Uint8Array");
        }
        return decodeReaderComplete(bytesReader(bytes));
      }
      static async fromIterable(asyncIterable) {
        if (!asyncIterable || !(typeof asyncIterable[Symbol.asyncIterator] === "function")) {
          throw new TypeError("fromIterable() requires an async iterable");
        }
        return decodeReaderComplete(asyncIterableReader(asyncIterable));
      }
    };
    async function decodeReaderComplete(reader) {
      const decoder = createDecoder(reader);
      const header = await decoder.header();
      const blocks = [];
      for await (const block of decoder.blocks()) {
        blocks.push(block);
      }
      return new CarReader(header, blocks);
    }
    function rawSha1(b) {
      let i = b.byteLength;
      let bs = 0;
      let A;
      let B;
      let C;
      let D;
      let G;
      const H = Uint32Array.from([A = 1732584193, B = 4023233417, ~A, ~B, 3285377520]);
      const W = new Uint32Array(80);
      const nrWords = i / 4 + 2 | 15;
      const words = new Uint32Array(nrWords + 1);
      let j;
      words[nrWords] = i * 8;
      words[i >> 2] |= 128 << (~i << 3);
      for (; i--; ) {
        words[i >> 2] |= b[i] << (~i << 3);
      }
      for (A = H.slice(); bs < nrWords; bs += 16, A.set(H)) {
        for (i = 0; i < 80; A[0] = (G = ((b = A[0]) << 5 | b >>> 27) + A[4] + (W[i] = i < 16 ? words[bs + i] : G << 1 | G >>> 31) + 1518500249, B = A[1], C = A[2], D = A[3], G + ((j = i / 5 >> 2) ? j !== 2 ? (B ^ C ^ D) + (j & 2 ? 1876969533 : 341275144) : (B & C | B & D | C & D) + 882459459 : B & C | ~B & D)), A[1] = b, A[2] = B << 30 | B >>> 2, A[3] = C, A[4] = D, ++i) {
          G = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];
        }
        for (i = 5; i; )
          H[--i] = H[i] + A[i];
      }
      return new Uint8Array(H.buffer, H.byteOffset, H.byteLength);
    }
    var chunker = bf(30);
    var blockOpts$1 = {cache: nocache, chunker, codec: codec$1, hasher: sha256$2, compare: simpleCompare};
    var NO_ENCRYPT = typeof process !== "undefined" && !!process.env?.NO_ENCRYPT;
    var Base = class {
      valetRootCarCid = null;
      keyMaterial = null;
      keyId = "null";
      readonly = false;
      constructor(name2, config2 = {}) {
        this.instanceId = Math.random().toString(36).slice(2);
        this.name = name2;
        this.config = config2;
        if (!this.config.branches) {
          this.config.branches = {
            main: {readonly: false}
          };
        }
        this.ready = this.getHeaders().then((blocksReady) => {
          return blocksReady;
        });
      }
      setCarCidMapCarCid(carCid) {
        if (!carCid)
          return;
        this.valetRootCarCid = parse(carCid);
        this.valetCarCidMap = null;
      }
      setKeyMaterial(km) {
        if (km && !NO_ENCRYPT) {
          const hex = Uint8Array.from(Buffer$3.from(km, "hex"));
          this.keyMaterial = km;
          const hash2 = rawSha1(hex);
          this.keyId = Buffer$3.from(hash2).toString("hex");
        } else {
          this.keyMaterial = null;
          this.keyId = "null";
        }
      }
      async compact(clock) {
        if (this.readonly)
          return;
        if (clock.length !== 1) {
          throw new Error(`Compacting with clock length ${clock.length} instead of 1. To merge the clock, apply an update to the database first.`);
        }
        const cidMap = await this.getCidCarMap();
        const dataCids = [...cidMap.keys()];
        const allBlocks = new Map();
        for (const cid of dataCids) {
          const block = await this.getLoaderBlock(cid);
          allBlocks.set(cid, block);
        }
        cidMap.clear();
        const blocks = {
          lastCid: clock[0],
          get: (cid) => allBlocks.get(cid.toString())
        };
        console.log("compact", this.instanceId, this.name, blocks.lastCid.toString(), dataCids.length);
        await this.parkCar(blocks, dataCids);
      }
      async parkCar(innerBlockstore, cids) {
        if (this.readonly)
          return;
        let newCar;
        if (this.keyMaterial) {
          newCar = await blocksToEncryptedCarBlock(innerBlockstore.lastCid, innerBlockstore, this.keyMaterial, [...cids]);
        } else {
          newCar = await blocksToCarBlock(innerBlockstore.lastCid, innerBlockstore);
        }
        return await this.saveCar(newCar.cid.toString(), newCar.bytes, cids);
      }
      async saveCar(carCid, value, cids) {
        const newValetCidCar = await this.updateCarCidMap(carCid, cids);
        const carList = [
          {
            cid: carCid,
            bytes: value,
            replaces: null
          },
          {
            cid: newValetCidCar.cid,
            bytes: newValetCidCar.bytes,
            replaces: null
          }
        ];
        await this.writeCars(carList);
        this.valetRootCarCid = newValetCidCar.cid;
        return newValetCidCar;
      }
      applyHeaders(headers) {
        this.headers = headers;
        for (const [, header] of Object.entries(headers)) {
          if (header) {
            header.key && this.setKeyMaterial(header.key);
            this.setCarCidMapCarCid(header.car);
          }
        }
        if (!this.valetRootCarCid) {
          this.setCarCidMapCarCid(this.config.car);
        }
        if (!this.keyMaterial) {
          const nullKey = this.config.key === null;
          if (nullKey || this.config.key) {
            this.setKeyMaterial(this.config.key);
          } else {
            this.setKeyMaterial(browserExports$1(32).toString("hex"));
          }
        }
      }
      async getHeaders() {
        const headers = {};
        for (const [branch] of Object.entries(this.config.branches)) {
          const got = await this.loadHeader(branch);
          headers[branch] = got;
        }
        this.applyHeaders(headers);
        return headers;
      }
      loadHeader(branch = "main") {
        throw new Error("not implemented");
      }
      async saveHeader(header) {
        for (const [branch, {readonly: readonly2}] of Object.entries(this.config.branches)) {
          if (readonly2)
            continue;
          await this.writeHeader(branch, header);
        }
      }
      prepareHeader(header, json = true) {
        header.key = this.keyMaterial;
        header.car = this.valetRootCarCid.toString();
        return json ? JSON.stringify(header) : header;
      }
      writeHeader(branch, header) {
        throw new Error("not implemented");
      }
      async getCarCIDForCID(cid) {
        const cidMap = await this.getCidCarMap();
        const carCid = cidMap.get(cid.toString());
        if (carCid) {
          return {result: carCid};
        }
        return {result: null};
      }
      async readCar(carCid) {
        throw new Error("not implemented");
      }
      async getLoaderBlock(dataCID) {
        const {result: carCid} = await this.getCarCIDForCID(dataCID);
        if (!carCid) {
          throw new Error("Missing car for: " + dataCID);
        }
        const reader = await this.getCarReader(carCid);
        return {block: await reader.get(dataCID), reader, carCid};
      }
      async getCidCarMap() {
        if (this.valetCarCidMap)
          return this.valetCarCidMap;
        if (this.valetRootCarCid) {
          this.valetCarCidMap = await this.mapForIPLDHashmapCarCid(this.valetRootCarCid);
          return this.valetCarCidMap;
        } else {
          this.valetCarCidMap = new Map();
          return this.valetCarCidMap;
        }
      }
      async mapForIPLDHashmapCarCid(carCid) {
        const carMapReader = await this.getWriteableCarReader(carCid);
        const indexNode = await load$1(carMapReader, carMapReader.root.cid, {
          blockHasher: blockOpts$1.hasher,
          blockCodec: blockOpts$1.codec
        });
        const theCarMap = new Map();
        for await (const [key2, value] of indexNode.entries()) {
          theCarMap.set(key2, value);
        }
        return theCarMap;
      }
      async getWriteableCarReader(carCid) {
        const carMapReader = await this.getCarReader(carCid);
        const theseWriteableBlocks = new VMemoryBlockstore();
        const combinedReader = {
          blocks: theseWriteableBlocks,
          root: carMapReader?.root,
          put: async (cid, bytes) => {
            return await theseWriteableBlocks.put(cid, bytes);
          },
          get: async (cid) => {
            try {
              const got = await theseWriteableBlocks.get(cid);
              return got.bytes;
            } catch (e) {
              if (!carMapReader)
                throw e;
              const bytes = await carMapReader.get(cid);
              await theseWriteableBlocks.put(cid, bytes);
              return bytes;
            }
          }
        };
        return combinedReader;
      }
      async xgetCarReader(carCid) {
        return this.getCarReaderImpl(carCid);
      }
      carReaderCache = new Map();
      async getCarReader(carCid) {
        if (!this.carReaderCache.has(carCid)) {
          this.carReaderCache.set(carCid, this.getCarReaderImpl(carCid));
        }
        return this.carReaderCache.get(carCid);
      }
      async getCarReaderImpl(carCid) {
        carCid = carCid.toString();
        const carBytes = await this.readCar(carCid);
        const reader = await CarReader.fromBytes(carBytes);
        if (this.keyMaterial) {
          const roots = await reader.getRoots();
          const readerGetWithCodec = async (cid) => {
            const got = await reader.get(cid);
            let useCodec = codec;
            if (cid.toString().indexOf("bafy") === 0) {
              useCodec = codec$1;
            }
            const decoded = await decode$5({
              ...got,
              codec: useCodec,
              hasher: sha256$2
            });
            return decoded;
          };
          const {blocks} = await blocksFromEncryptedCarBlock(roots[0], readerGetWithCodec, this.keyMaterial);
          const rootBlock = blocks[blocks.length - 1];
          const blocksIterable = function* () {
            for (const block of blocks)
              yield block;
          };
          const gat = async (dataCID) => {
            dataCID = dataCID.toString();
            return blocks.find((b) => b.cid.toString() === dataCID);
          };
          return {
            entries: blocksIterable,
            root: rootBlock,
            gat,
            get: async (dataCID) => {
              const block = await gat(dataCID);
              if (block) {
                return block.bytes;
              }
            }
          };
        } else {
          const gat = async (dataCID) => {
            return await reader.get(CID.parse(dataCID));
          };
          return {
            entries: reader.blocks.bind(reader),
            root: reader.getRoots()[0],
            gat,
            get: async (dataCID) => {
              const gotBlock = await gat(dataCID);
              if (gotBlock) {
                return gotBlock.bytes;
              }
            }
          };
        }
      }
      writeCars(cars) {
      }
      async updateCarCidMap(carCid, cids) {
        const theCarMap = await this.getCidCarMap();
        for (const cid of cids) {
          theCarMap.set(cid, carCid);
        }
        return await this.persistCarMap(theCarMap);
      }
      async persistCarMap(theCarMap) {
        const ipldLoader = await getEmptyLoader();
        const indexNode = await create$1(ipldLoader, {
          bitWidth: 4,
          bucketSize: 2,
          blockHasher: blockOpts$1.hasher,
          blockCodec: blockOpts$1.codec
        });
        for (const [key2, value] of theCarMap.entries()) {
          await indexNode.set(key2, value);
        }
        let newValetCidCar;
        if (this.keyMaterial) {
          const cids = [...ipldLoader.blocks.blocks.keys()];
          newValetCidCar = await blocksToEncryptedCarBlock(indexNode.cid, ipldLoader.blocks, this.keyMaterial, cids);
        } else {
          newValetCidCar = await blocksToCarBlock(indexNode.cid, ipldLoader.blocks);
        }
        return newValetCidCar;
      }
    };
    async function getEmptyLoader() {
      const theseWriteableBlocks = new VMemoryBlockstore();
      return {
        blocks: theseWriteableBlocks,
        put: async (cid, bytes) => {
          return await theseWriteableBlocks.put(cid, bytes);
        },
        get: async (cid) => {
          const got = await theseWriteableBlocks.get(cid);
          return got.bytes;
        }
      };
    }
    var VMemoryBlockstore = class {
      blocks = new Map();
      instanceId = Math.random().toString(36).slice(2);
      async get(cid) {
        const bytes = this.blocks.get(cid.toString());
        if (!bytes)
          throw new Error("block not found " + cid.toString());
        return {cid, bytes};
      }
      async put(cid, bytes) {
        this.blocks.set(cid.toString(), bytes);
      }
      *entries() {
        for (const [str, bytes] of this.blocks) {
          yield {cid: parse(str), bytes};
        }
      }
    };
    var blocksToCarBlock = async (rootCids, blocks) => {
      let size = 0;
      if (!Array.isArray(rootCids)) {
        rootCids = [rootCids];
      }
      const headerSize = headerLength({roots: rootCids});
      size += headerSize;
      if (!Array.isArray(blocks)) {
        blocks = Array.from(blocks.entries());
      }
      for (const {cid, bytes} of blocks) {
        size += blockLength({cid, bytes});
      }
      const buffer2 = new Uint8Array(size);
      const writer = await createWriter(buffer2, {headerSize});
      for (const cid of rootCids) {
        writer.addRoot(cid);
      }
      for (const {cid, bytes} of blocks) {
        writer.write({cid, bytes});
      }
      await writer.close();
      return await encode$5({value: writer.bytes, hasher: sha256$2, codec: raw});
    };
    var blocksToEncryptedCarBlock = async (innerBlockStoreClockRootCid, blocks, keyMaterial, cids) => {
      const encryptionKey = Buffer$3.from(keyMaterial, "hex");
      const encryptedBlocks = [];
      const theCids = cids;
      let last;
      for await (const block of encrypt({
        cids: theCids,
        get: async (cid) => {
          const got = blocks.get(cid);
          return got.block ? {cid, bytes: got.block} : got;
        },
        key: encryptionKey,
        hasher: sha256$2,
        chunker,
        cache: nocache,
        root: innerBlockStoreClockRootCid
      })) {
        encryptedBlocks.push(block);
        last = block;
      }
      const encryptedCar = await blocksToCarBlock(last.cid, encryptedBlocks);
      return encryptedCar;
    };
    var memoizeDecryptedCarBlocks = new Map();
    var blocksFromEncryptedCarBlock = async (cid, get2, keyMaterial) => {
      if (memoizeDecryptedCarBlocks.has(cid.toString())) {
        return memoizeDecryptedCarBlocks.get(cid.toString());
      } else {
        const blocksPromise = (async () => {
          const decryptionKey = Buffer$3.from(keyMaterial, "hex");
          const cids = new Set();
          const decryptedBlocks = [];
          for await (const block of decrypt({
            root: cid,
            get: get2,
            key: decryptionKey,
            chunker,
            hasher: sha256$2,
            cache: nocache
          })) {
            decryptedBlocks.push(block);
            cids.add(block.cid.toString());
          }
          return {blocks: decryptedBlocks, cids};
        })();
        memoizeDecryptedCarBlocks.set(cid.toString(), blocksPromise);
        return blocksPromise;
      }
    };
    var defaultConfig$1 = {
      headerKeyPrefix: "fp."
    };
    var Browser = class extends Base {
      constructor(name2, config2 = {}) {
        super(name2, Object.assign({}, defaultConfig$1, config2));
      }
      withDB = async (dbWorkFun) => {
        if (!this.idb) {
          this.idb = await openDB(`fp.${this.keyId}.${this.name}.valet`, 3, {
            upgrade(db, oldVersion, newVersion, transaction) {
              if (oldVersion < 1) {
                db.createObjectStore("cars");
              }
            }
          });
        }
        return await dbWorkFun(this.idb);
      };
      async writeCars(cars) {
        if (this.config.readonly)
          return;
        return await this.withDB(async (db) => {
          const tx = db.transaction(["cars"], "readwrite");
          for (const {cid, bytes, replaces} of cars) {
            await tx.objectStore("cars").put(bytes, cid.toString());
            if (replaces) {
              await tx.objectStore("cars").delete(replaces.toString());
            }
          }
          return await tx.done;
        });
      }
      async readCar(carCid) {
        return await this.withDB(async (db) => {
          const tx = db.transaction(["cars"], "readonly");
          return await tx.objectStore("cars").get(carCid);
        });
      }
      loadHeader(branch = "main") {
        try {
          return JSON.parse(localStorage.getItem(this.headerKey(branch)));
        } catch (e) {
        }
      }
      async writeHeader(branch, header) {
        if (this.config.readonly)
          return;
        try {
          return localStorage.setItem(this.headerKey(branch), this.prepareHeader(header));
        } catch (e) {
        }
      }
      headerKey(branch = "main") {
        return this.config.headerKeyPrefix + this.name + "." + branch;
      }
    };
    var browserPonyfillExports = {};
    var browserPonyfill = {
      get exports() {
        return browserPonyfillExports;
      },
      set exports(v2) {
        browserPonyfillExports = v2;
      }
    };
    (function(module2, exports2) {
      var global2 = typeof self !== "undefined" ? self : commonjsGlobal;
      var __self__ = function() {
        function F() {
          this.fetch = false;
          this.DOMException = global2.DOMException;
        }
        F.prototype = global2;
        return new F();
      }();
      (function(self2) {
        (function(exports3) {
          var support = {
            searchParams: "URLSearchParams" in self2,
            iterable: "Symbol" in self2 && "iterator" in Symbol,
            blob: "FileReader" in self2 && "Blob" in self2 && function() {
              try {
                new Blob();
                return true;
              } catch (e) {
                return false;
              }
            }(),
            formData: "FormData" in self2,
            arrayBuffer: "ArrayBuffer" in self2
          };
          function isDataView(obj) {
            return obj && DataView.prototype.isPrototypeOf(obj);
          }
          if (support.arrayBuffer) {
            var viewClasses = [
              "[object Int8Array]",
              "[object Uint8Array]",
              "[object Uint8ClampedArray]",
              "[object Int16Array]",
              "[object Uint16Array]",
              "[object Int32Array]",
              "[object Uint32Array]",
              "[object Float32Array]",
              "[object Float64Array]"
            ];
            var isArrayBufferView = ArrayBuffer.isView || function(obj) {
              return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
            };
          }
          function normalizeName(name2) {
            if (typeof name2 !== "string") {
              name2 = String(name2);
            }
            if (/[^a-z0-9\-#$%&'*+.^_`|~]/i.test(name2)) {
              throw new TypeError("Invalid character in header field name");
            }
            return name2.toLowerCase();
          }
          function normalizeValue(value) {
            if (typeof value !== "string") {
              value = String(value);
            }
            return value;
          }
          function iteratorFor(items) {
            var iterator = {
              next: function() {
                var value = items.shift();
                return {done: value === void 0, value};
              }
            };
            if (support.iterable) {
              iterator[Symbol.iterator] = function() {
                return iterator;
              };
            }
            return iterator;
          }
          function Headers(headers) {
            this.map = {};
            if (headers instanceof Headers) {
              headers.forEach(function(value, name2) {
                this.append(name2, value);
              }, this);
            } else if (Array.isArray(headers)) {
              headers.forEach(function(header) {
                this.append(header[0], header[1]);
              }, this);
            } else if (headers) {
              Object.getOwnPropertyNames(headers).forEach(function(name2) {
                this.append(name2, headers[name2]);
              }, this);
            }
          }
          Headers.prototype.append = function(name2, value) {
            name2 = normalizeName(name2);
            value = normalizeValue(value);
            var oldValue = this.map[name2];
            this.map[name2] = oldValue ? oldValue + ", " + value : value;
          };
          Headers.prototype["delete"] = function(name2) {
            delete this.map[normalizeName(name2)];
          };
          Headers.prototype.get = function(name2) {
            name2 = normalizeName(name2);
            return this.has(name2) ? this.map[name2] : null;
          };
          Headers.prototype.has = function(name2) {
            return this.map.hasOwnProperty(normalizeName(name2));
          };
          Headers.prototype.set = function(name2, value) {
            this.map[normalizeName(name2)] = normalizeValue(value);
          };
          Headers.prototype.forEach = function(callback, thisArg) {
            for (var name2 in this.map) {
              if (this.map.hasOwnProperty(name2)) {
                callback.call(thisArg, this.map[name2], name2, this);
              }
            }
          };
          Headers.prototype.keys = function() {
            var items = [];
            this.forEach(function(value, name2) {
              items.push(name2);
            });
            return iteratorFor(items);
          };
          Headers.prototype.values = function() {
            var items = [];
            this.forEach(function(value) {
              items.push(value);
            });
            return iteratorFor(items);
          };
          Headers.prototype.entries = function() {
            var items = [];
            this.forEach(function(value, name2) {
              items.push([name2, value]);
            });
            return iteratorFor(items);
          };
          if (support.iterable) {
            Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
          }
          function consumed(body) {
            if (body.bodyUsed) {
              return Promise.reject(new TypeError("Already read"));
            }
            body.bodyUsed = true;
          }
          function fileReaderReady(reader) {
            return new Promise(function(resolve, reject) {
              reader.onload = function() {
                resolve(reader.result);
              };
              reader.onerror = function() {
                reject(reader.error);
              };
            });
          }
          function readBlobAsArrayBuffer(blob) {
            var reader = new FileReader();
            var promise2 = fileReaderReady(reader);
            reader.readAsArrayBuffer(blob);
            return promise2;
          }
          function readBlobAsText(blob) {
            var reader = new FileReader();
            var promise2 = fileReaderReady(reader);
            reader.readAsText(blob);
            return promise2;
          }
          function readArrayBufferAsText(buf2) {
            var view = new Uint8Array(buf2);
            var chars = new Array(view.length);
            for (var i = 0; i < view.length; i++) {
              chars[i] = String.fromCharCode(view[i]);
            }
            return chars.join("");
          }
          function bufferClone(buf2) {
            if (buf2.slice) {
              return buf2.slice(0);
            } else {
              var view = new Uint8Array(buf2.byteLength);
              view.set(new Uint8Array(buf2));
              return view.buffer;
            }
          }
          function Body() {
            this.bodyUsed = false;
            this._initBody = function(body) {
              this._bodyInit = body;
              if (!body) {
                this._bodyText = "";
              } else if (typeof body === "string") {
                this._bodyText = body;
              } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
                this._bodyBlob = body;
              } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
                this._bodyFormData = body;
              } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                this._bodyText = body.toString();
              } else if (support.arrayBuffer && support.blob && isDataView(body)) {
                this._bodyArrayBuffer = bufferClone(body.buffer);
                this._bodyInit = new Blob([this._bodyArrayBuffer]);
              } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
                this._bodyArrayBuffer = bufferClone(body);
              } else {
                this._bodyText = body = Object.prototype.toString.call(body);
              }
              if (!this.headers.get("content-type")) {
                if (typeof body === "string") {
                  this.headers.set("content-type", "text/plain;charset=UTF-8");
                } else if (this._bodyBlob && this._bodyBlob.type) {
                  this.headers.set("content-type", this._bodyBlob.type);
                } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                  this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8");
                }
              }
            };
            if (support.blob) {
              this.blob = function() {
                var rejected = consumed(this);
                if (rejected) {
                  return rejected;
                }
                if (this._bodyBlob) {
                  return Promise.resolve(this._bodyBlob);
                } else if (this._bodyArrayBuffer) {
                  return Promise.resolve(new Blob([this._bodyArrayBuffer]));
                } else if (this._bodyFormData) {
                  throw new Error("could not read FormData body as blob");
                } else {
                  return Promise.resolve(new Blob([this._bodyText]));
                }
              };
              this.arrayBuffer = function() {
                if (this._bodyArrayBuffer) {
                  return consumed(this) || Promise.resolve(this._bodyArrayBuffer);
                } else {
                  return this.blob().then(readBlobAsArrayBuffer);
                }
              };
            }
            this.text = function() {
              var rejected = consumed(this);
              if (rejected) {
                return rejected;
              }
              if (this._bodyBlob) {
                return readBlobAsText(this._bodyBlob);
              } else if (this._bodyArrayBuffer) {
                return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
              } else if (this._bodyFormData) {
                throw new Error("could not read FormData body as text");
              } else {
                return Promise.resolve(this._bodyText);
              }
            };
            if (support.formData) {
              this.formData = function() {
                return this.text().then(decode2);
              };
            }
            this.json = function() {
              return this.text().then(JSON.parse);
            };
            return this;
          }
          var methods = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
          function normalizeMethod(method2) {
            var upcased = method2.toUpperCase();
            return methods.indexOf(upcased) > -1 ? upcased : method2;
          }
          function Request(input, options) {
            options = options || {};
            var body = options.body;
            if (input instanceof Request) {
              if (input.bodyUsed) {
                throw new TypeError("Already read");
              }
              this.url = input.url;
              this.credentials = input.credentials;
              if (!options.headers) {
                this.headers = new Headers(input.headers);
              }
              this.method = input.method;
              this.mode = input.mode;
              this.signal = input.signal;
              if (!body && input._bodyInit != null) {
                body = input._bodyInit;
                input.bodyUsed = true;
              }
            } else {
              this.url = String(input);
            }
            this.credentials = options.credentials || this.credentials || "same-origin";
            if (options.headers || !this.headers) {
              this.headers = new Headers(options.headers);
            }
            this.method = normalizeMethod(options.method || this.method || "GET");
            this.mode = options.mode || this.mode || null;
            this.signal = options.signal || this.signal;
            this.referrer = null;
            if ((this.method === "GET" || this.method === "HEAD") && body) {
              throw new TypeError("Body not allowed for GET or HEAD requests");
            }
            this._initBody(body);
          }
          Request.prototype.clone = function() {
            return new Request(this, {body: this._bodyInit});
          };
          function decode2(body) {
            var form = new FormData();
            body.trim().split("&").forEach(function(bytes) {
              if (bytes) {
                var split = bytes.split("=");
                var name2 = split.shift().replace(/\+/g, " ");
                var value = split.join("=").replace(/\+/g, " ");
                form.append(decodeURIComponent(name2), decodeURIComponent(value));
              }
            });
            return form;
          }
          function parseHeaders(rawHeaders) {
            var headers = new Headers();
            var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, " ");
            preProcessedHeaders.split(/\r?\n/).forEach(function(line) {
              var parts = line.split(":");
              var key2 = parts.shift().trim();
              if (key2) {
                var value = parts.join(":").trim();
                headers.append(key2, value);
              }
            });
            return headers;
          }
          Body.call(Request.prototype);
          function Response(bodyInit, options) {
            if (!options) {
              options = {};
            }
            this.type = "default";
            this.status = options.status === void 0 ? 200 : options.status;
            this.ok = this.status >= 200 && this.status < 300;
            this.statusText = "statusText" in options ? options.statusText : "OK";
            this.headers = new Headers(options.headers);
            this.url = options.url || "";
            this._initBody(bodyInit);
          }
          Body.call(Response.prototype);
          Response.prototype.clone = function() {
            return new Response(this._bodyInit, {
              status: this.status,
              statusText: this.statusText,
              headers: new Headers(this.headers),
              url: this.url
            });
          };
          Response.error = function() {
            var response = new Response(null, {status: 0, statusText: ""});
            response.type = "error";
            return response;
          };
          var redirectStatuses = [301, 302, 303, 307, 308];
          Response.redirect = function(url, status) {
            if (redirectStatuses.indexOf(status) === -1) {
              throw new RangeError("Invalid status code");
            }
            return new Response(null, {status, headers: {location: url}});
          };
          exports3.DOMException = self2.DOMException;
          try {
            new exports3.DOMException();
          } catch (err) {
            exports3.DOMException = function(message, name2) {
              this.message = message;
              this.name = name2;
              var error = Error(message);
              this.stack = error.stack;
            };
            exports3.DOMException.prototype = Object.create(Error.prototype);
            exports3.DOMException.prototype.constructor = exports3.DOMException;
          }
          function fetch2(input, init2) {
            return new Promise(function(resolve, reject) {
              var request = new Request(input, init2);
              if (request.signal && request.signal.aborted) {
                return reject(new exports3.DOMException("Aborted", "AbortError"));
              }
              var xhr = new XMLHttpRequest();
              function abortXhr() {
                xhr.abort();
              }
              xhr.onload = function() {
                var options = {
                  status: xhr.status,
                  statusText: xhr.statusText,
                  headers: parseHeaders(xhr.getAllResponseHeaders() || "")
                };
                options.url = "responseURL" in xhr ? xhr.responseURL : options.headers.get("X-Request-URL");
                var body = "response" in xhr ? xhr.response : xhr.responseText;
                resolve(new Response(body, options));
              };
              xhr.onerror = function() {
                reject(new TypeError("Network request failed"));
              };
              xhr.ontimeout = function() {
                reject(new TypeError("Network request failed"));
              };
              xhr.onabort = function() {
                reject(new exports3.DOMException("Aborted", "AbortError"));
              };
              xhr.open(request.method, request.url, true);
              if (request.credentials === "include") {
                xhr.withCredentials = true;
              } else if (request.credentials === "omit") {
                xhr.withCredentials = false;
              }
              if ("responseType" in xhr && support.blob) {
                xhr.responseType = "blob";
              }
              request.headers.forEach(function(value, name2) {
                xhr.setRequestHeader(name2, value);
              });
              if (request.signal) {
                request.signal.addEventListener("abort", abortXhr);
                xhr.onreadystatechange = function() {
                  if (xhr.readyState === 4) {
                    request.signal.removeEventListener("abort", abortXhr);
                  }
                };
              }
              xhr.send(typeof request._bodyInit === "undefined" ? null : request._bodyInit);
            });
          }
          fetch2.polyfill = true;
          if (!self2.fetch) {
            self2.fetch = fetch2;
            self2.Headers = Headers;
            self2.Request = Request;
            self2.Response = Response;
          }
          exports3.Headers = Headers;
          exports3.Request = Request;
          exports3.Response = Response;
          exports3.fetch = fetch2;
          Object.defineProperty(exports3, "__esModule", {value: true});
          return exports3;
        })({});
      })(__self__);
      __self__.fetch.ponyfill = true;
      delete __self__.fetch.polyfill;
      var ctx = __self__;
      exports2 = ctx.fetch;
      exports2.default = ctx.fetch;
      exports2.fetch = ctx.fetch;
      exports2.Headers = ctx.Headers;
      exports2.Request = ctx.Request;
      exports2.Response = ctx.Response;
      module2.exports = exports2;
    })(browserPonyfill, browserPonyfillExports);
    var fetch = /* @__PURE__ */ getDefaultExportFromCjs(browserPonyfillExports);
    var defaultConfig = {
      url: "http://localhost:4000"
    };
    var Rest = class extends Base {
      constructor(name2, config2 = {}) {
        super(name2, Object.assign({}, defaultConfig, config2));
      }
      headerURL(branch = "main") {
        return `${this.config.url}/${branch}.json`;
      }
      async writeCars(cars) {
        if (this.config.readonly)
          return;
        for (const {cid, bytes} of cars) {
          const carURL = `${this.config.url}/${cid.toString()}.car`;
          const response = await fetch(carURL, {
            method: "PUT",
            body: bytes,
            headers: {"Content-Type": "application/car"}
          });
          if (!response.ok)
            throw new Error(`An error occurred: ${response.statusText}`);
        }
      }
      async readCar(carCid) {
        const carURL = `${this.config.url}/${carCid.toString()}.car`;
        const response = await fetch(carURL);
        if (!response.ok)
          throw new Error(`An error occurred: ${response.statusText}`);
        const got = await response.arrayBuffer();
        return new Uint8Array(got);
      }
      async loadHeader(branch = "main") {
        const response = await fetch(this.headerURL(branch));
        if (!response.ok)
          return null;
        const got = await response.json();
        return got;
      }
      async writeHeader(branch, header) {
        if (this.config.readonly)
          return;
        const pHeader = this.prepareHeader(header);
        const response = await fetch(this.headerURL(branch), {
          method: "PUT",
          body: pHeader,
          headers: {"Content-Type": "application/json"}
        });
        if (!response.ok)
          throw new Error(`An error occurred: ${response.statusText}`);
      }
    };
    var Loader = {
      appropriate: (name2, config2 = {}) => {
        if (config2.StorageClass) {
          return new config2.StorageClass(name2, config2);
        }
        if (config2.type === "rest") {
          return new Rest(name2, config2);
        }
        return new Browser(name2, config2);
      }
    };
    var Valet = class {
      idb = null;
      name = null;
      uploadQueue = null;
      alreadyEnqueued = new Set();
      instanceId = Math.random().toString(36).slice(2);
      constructor(name2 = "default", config2 = {}) {
        this.name = name2;
        this.primary = Loader.appropriate(name2, config2.primary);
        this.secondary = config2.secondary ? Loader.appropriate(name2, config2.secondary) : null;
        const readyP = [this.primary.ready];
        if (this.secondary)
          readyP.push(this.secondary.ready);
        this.ready = Promise.all(readyP).then((blocksReady) => {
          return blocksReady;
        });
      }
      async saveHeader(header) {
        if (this.secondary) {
          this.secondary.saveHeader(header);
        }
        return await this.primary.saveHeader(header);
      }
      async compact(clock) {
        await this.primary.compact(clock);
        if (this.secondary)
          await this.secondary.compact(clock);
      }
      async writeTransaction(innerBlockstore, cids) {
        if (innerBlockstore.lastCid) {
          await this.primary.parkCar(innerBlockstore, cids);
          if (this.secondary)
            await this.secondary.parkCar(innerBlockstore, cids);
        } else {
          throw new Error("missing lastCid for car header");
        }
      }
      async *cids() {
      }
      remoteBlockFunction = null;
      async getValetBlock(dataCID) {
        try {
          const {block} = await this.primary.getLoaderBlock(dataCID);
          return block;
        } catch (e) {
          if (this.secondary) {
            try {
              const {block, reader} = await this.secondary.getLoaderBlock(dataCID);
              const cids = new Set();
              for await (const {cid} of reader.entries()) {
                cids.add(cid.toString());
              }
              reader.get = reader.gat;
              reader.lastCid = reader.root.cid;
              await this.primary.parkCar(reader, [...cids]);
              return block;
            } catch (e2) {
            }
          }
        }
      }
    };
    var husherMap = new Map();
    var husher = (id, workFn) => {
      if (!husherMap.has(id)) {
        husherMap.set(id, workFn().finally(() => setTimeout(() => husherMap.delete(id), 100)));
      }
      return husherMap.get(id);
    };
    var TransactionBlockstore = class {
      committedBlocks = new Map();
      valet = null;
      instanceId = "blkz." + Math.random().toString(36).substring(2, 4);
      inflightTransactions = new Set();
      syncs = new Set();
      constructor(name2, config2) {
        if (name2) {
          this.valet = new Valet(name2, config2);
          this.ready = this.valet.ready;
        } else {
          this.ready = Promise.resolve();
        }
        this.remoteBlockFunction = null;
      }
      async get(cid) {
        const key2 = cid.toString();
        const bytes = await Promise.any([this.transactionsGet(key2), this.committedGet(key2)]).catch((e) => {
          console.log("get error", cid.toString(), e);
          return this.networkGet(key2);
        });
        if (!bytes)
          throw new Error("Missing block: " + key2);
        return {cid, bytes};
      }
      async transactionsGet(key2) {
        for (const transaction of this.inflightTransactions) {
          const got = await transaction.get(key2);
          if (got && got.bytes)
            return got.bytes;
        }
        throw new Error("Missing block: " + key2);
      }
      async committedGet(key2) {
        const old = this.committedBlocks.get(key2);
        if (old)
          return old;
        if (!this.valet)
          throw new Error("Missing block: " + key2);
        const got = await this.valet.getValetBlock(key2);
        this.committedBlocks.set(key2, got);
        return got;
      }
      async clearCommittedCache() {
        this.committedBlocks.clear();
      }
      async networkGet(key2) {
        if (this.remoteBlockFunction) {
          const value = await husher(key2, async () => await this.remoteBlockFunction(key2));
          if (value) {
            doTransaction("networkGot: " + key2, this, async (innerBlockstore) => {
              await innerBlockstore.put(CID.parse(key2), value);
            });
            return value;
          }
        } else {
          return false;
        }
      }
      put(cid, bytes) {
        throw new Error("use a transaction to put");
      }
      async *entries() {
        for (const transaction of this.inflightTransactions) {
          for (const [cid, bytes] of transaction.entries()) {
            yield {cid: cid.toString(), bytes};
          }
        }
        for (const [str, bytes] of this.committedBlocks) {
          yield {cid: str, bytes};
        }
        if (this.valet) {
          for await (const {cid} of this.valet.cids()) {
            yield {cid};
          }
        }
      }
      begin(label = "") {
        const innerTransactionBlockstore = new InnerBlockstore(label, this);
        this.inflightTransactions.add(innerTransactionBlockstore);
        return innerTransactionBlockstore;
      }
      async commit(innerBlockstore, doSync = true) {
        await this.doCommit(innerBlockstore);
        if (doSync) {
          await Promise.all([...this.syncs].map(async (sync) => sync.sendUpdate(innerBlockstore).catch((e) => {
            console.error("sync error, cancelling", e);
            sync.destroy();
          })));
        }
      }
      doCommit = async (innerBlockstore) => {
        const cids = new Set();
        for (const {cid, bytes} of innerBlockstore.entries()) {
          const stringCid = cid.toString();
          if (this.committedBlocks.has(stringCid))
            ;
          else {
            this.committedBlocks.set(stringCid, bytes);
            cids.add(stringCid);
          }
        }
        if (cids.size > 0 && this.valet) {
          await this.valet.writeTransaction(innerBlockstore, cids);
        }
      };
      retire(innerBlockstore) {
        this.inflightTransactions.delete(innerBlockstore);
      }
    };
    var doTransaction = async (label, blockstore, doFun, doSync = true) => {
      if (!blockstore.commit)
        return await doFun(blockstore);
      const innerBlockstore = blockstore.begin(label);
      try {
        const result = await doFun(innerBlockstore);
        await blockstore.commit(innerBlockstore, doSync);
        return result;
      } catch (e) {
        console.error(`Transaction ${label} failed`, e, e.stack);
        throw e;
      } finally {
        blockstore.retire(innerBlockstore);
      }
    };
    var InnerBlockstore = class {
      blocks = new Map();
      lastCid = null;
      label = "";
      parentBlockstore = null;
      constructor(label, parentBlockstore) {
        this.label = label;
        this.parentBlockstore = parentBlockstore;
      }
      async get(cid) {
        const key2 = cid.toString();
        let bytes = this.blocks.get(key2);
        if (bytes) {
          return {cid, bytes};
        }
        bytes = await this.parentBlockstore.committedGet(key2);
        if (bytes) {
          return {cid, bytes};
        }
      }
      async put(cid, bytes) {
        this.blocks.set(cid.toString(), bytes);
        this.lastCid = cid;
      }
      *entries() {
        for (const [str, bytes] of this.blocks) {
          yield {cid: parse(str), bytes};
        }
      }
    };
    var blockOpts = {cache: nocache, chunker: bf(30), codec: codec$1, hasher: sha256$2, compare: simpleCompare};
    var makeGetBlock = (blocks) => {
      const getBlockFn = async (address) => {
        const {cid, bytes} = await blocks.get(address);
        return create$6({cid, bytes, hasher: sha256$2, codec: codec$1});
      };
      return {
        getBlock: getBlockFn
      };
    };
    async function createAndSaveNewEvent({inBlocks, bigPut, root: root2, event: inEvent, head, additions, removals = []}) {
      let cids;
      const {key: key2, value, del} = inEvent;
      const data = {
        root: root2 ? await root2.address : null,
        key: key2
      };
      if (del) {
        data.value = null;
        data.type = "del";
      } else {
        data.value = value;
        data.type = "put";
      }
      const event = await EventBlock.create(data, head);
      bigPut(event);
      ({head, cids} = await advance(inBlocks, head, event.cid));
      return {
        root: root2,
        additions,
        removals,
        head,
        clockCIDs: cids,
        event
      };
    }
    var makeGetAndPutBlock = (inBlocks) => {
      const {getBlock, cids} = makeGetBlock(inBlocks);
      const bigPut = async (block, additions) => {
        const {cid, bytes} = block;
        inBlocks.put(cid, bytes);
        if (additions) {
          additions.set(cid.toString(), block);
        }
      };
      return {getBlock, bigPut, blocks: inBlocks, cids};
    };
    var bulkFromEvents = (sorted, event) => {
      if (event) {
        const update = {value: {data: {key: event.key}}};
        if (event.del) {
          update.value.data.type = "del";
        } else {
          update.value.data.type = "put";
          update.value.data.value = event.value;
        }
        sorted.push(update);
      }
      const bulk = new Map();
      for (const {value: event2} of sorted) {
        const {
          data: {type, value, key: key2}
        } = event2;
        if (!key2) {
          throw new Error("key is required");
        }
        const bulkEvent = type === "put" ? {key: key2, value} : {key: key2, del: true};
        bulk.set(bulkEvent.key, bulkEvent);
      }
      return Array.from(bulk.values());
    };
    var prollyRootFromAncestor = async (events, ancestor, getBlock) => {
      const event = await events.get(ancestor);
      const {root: root2} = event.value.data;
      if (root2) {
        return load$4({cid: root2, get: getBlock, ...blockOpts});
      } else {
        return root2;
      }
    };
    var doProllyBulk = async (inBlocks, head, event, doFull = false) => {
      const {getBlock, blocks} = makeGetAndPutBlock(inBlocks);
      let bulkSorted = [];
      let prollyRootNode = null;
      const events = new EventFetcher(blocks);
      if (head.length) {
        if (!doFull && head.length === 1) {
          prollyRootNode = await prollyRootFromAncestor(events, head[0], getBlock);
        } else {
          const {ancestor, sorted} = await findCommonAncestorWithSortedEvents(events, head, doFull);
          bulkSorted = sorted;
          if (ancestor) {
            prollyRootNode = await prollyRootFromAncestor(events, ancestor, getBlock);
          }
        }
      }
      const bulkOperations = bulkFromEvents(bulkSorted, event);
      if (!prollyRootNode) {
        let root2;
        const newBlocks = [];
        if (bulkOperations.every((op) => op.del)) {
          return {root: null, blocks: [], clockCIDs: await events.all()};
        }
        for await (const node2 of create$4({get: getBlock, list: bulkOperations, ...blockOpts})) {
          root2 = node2;
          newBlocks.push(await node2.block);
        }
        return {root: root2, blocks: newBlocks, clockCIDs: await events.all()};
      } else {
        const writeResp = await prollyRootNode.bulk(bulkOperations);
        writeResp.clockCIDs = await events.all();
        return writeResp;
      }
    };
    async function put(inBlocks, head, event, options) {
      const {bigPut} = makeGetAndPutBlock(inBlocks);
      if (!head.length) {
        const additions = new Map();
        const {root: root2, blocks} = await doProllyBulk(inBlocks, head, event);
        for (const b of blocks) {
          bigPut(b, additions);
        }
        return createAndSaveNewEvent({inBlocks, bigPut, root: root2, event, head, additions: Array.from(additions.values())});
      }
      const {root: newProllyRootNode, blocks: newBlocks} = await doProllyBulk(inBlocks, head, event);
      if (!newProllyRootNode) {
        return createAndSaveNewEvent({
          inBlocks,
          bigPut,
          root: null,
          event,
          head,
          additions: []
        });
      } else {
        const prollyRootBlock = await newProllyRootNode.block;
        const additions = new Map();
        bigPut(prollyRootBlock, additions);
        for (const nb of newBlocks) {
          bigPut(nb, additions);
        }
        return createAndSaveNewEvent({
          inBlocks,
          bigPut,
          root: newProllyRootNode,
          event,
          head,
          additions: Array.from(additions.values())
        });
      }
    }
    async function root(inBlocks, head, doFull = false) {
      if (!head.length) {
        throw new Error("no head");
      }
      return await doTransaction("root", inBlocks, async (transactionBlocks) => {
        const {bigPut} = makeGetAndPutBlock(transactionBlocks);
        const {root: newProllyRootNode, blocks: newBlocks, clockCIDs} = await doProllyBulk(inBlocks, head, null, doFull);
        for (const nb of newBlocks) {
          bigPut(nb);
        }
        return {clockCIDs, node: newProllyRootNode};
      }, false);
    }
    async function eventsSince(blocks, head, since) {
      if (!head.length) {
        return {clockCIDs: [], result: []};
      }
      const sinceHead = [...since, ...head].map((h) => h.toString());
      const {cids, events: unknownSorted3} = await findEventsToSync(blocks, sinceHead);
      return {clockCIDs: cids, result: unknownSorted3.map(({value: {data}}) => data)};
    }
    async function getAll(blocks, head, rootCache = null, doFull = false) {
      if (!head.length) {
        return {root: null, clockCIDs: new CIDCounter(), cids: new CIDCounter(), result: []};
      }
      const {node: prollyRootNode, clockCIDs} = await rootOrCache(blocks, head, rootCache, doFull);
      if (!prollyRootNode) {
        return {root: null, clockCIDs, cids: new CIDCounter(), result: []};
      }
      const {result, cids} = await prollyRootNode.getAllEntries();
      return {root: prollyRootNode, clockCIDs, cids, result: result.map(({key: key2, value}) => ({key: key2, value}))};
    }
    async function rootOrCache(blocks, head, rootCache, doFull = false) {
      let node2;
      let clockCIDs;
      if (!doFull && rootCache && rootCache.root) {
        node2 = rootCache.root;
        clockCIDs = rootCache.clockCIDs;
      } else {
        ({node: node2, clockCIDs} = await root(blocks, head, doFull));
      }
      return {node: node2, clockCIDs};
    }
    async function get(blocks, head, key2, rootCache = null) {
      if (!head.length) {
        return {cids: new CIDCounter(), result: null};
      }
      const {node: prollyRootNode, clockCIDs} = await rootOrCache(blocks, head, rootCache);
      if (!prollyRootNode) {
        return {clockCIDs, cids: new CIDCounter(), result: null};
      }
      const {result, cids} = await prollyRootNode.get(key2);
      return {result, cids, clockCIDs, root: prollyRootNode};
    }
    async function* vis(blocks, head) {
      if (!head.length) {
        return {cids: new CIDCounter(), result: null};
      }
      const {node: prollyRootNode, cids} = await root(blocks, head);
      const lines = [];
      for await (const line of prollyRootNode.vis()) {
        yield line;
        lines.push(line);
      }
      return {vis: lines.join("\n"), cids};
    }
    async function visMerkleTree(blocks, head) {
      if (head && !Array.isArray(head)) {
        const getBl = makeGetBlock(blocks);
        const prollyRootNode2 = await load$4({
          cid: head,
          get: getBl.getBlock,
          ...blockOpts
        });
        const lines2 = [];
        for await (const line of prollyRootNode2.vis()) {
          lines2.push(line);
        }
        return {vis: lines2.join("\n"), cids: new CIDCounter()};
      }
      const {node: prollyRootNode, cids} = await root(blocks, head);
      const lines = [];
      for await (const line of prollyRootNode.vis()) {
        lines.push(line);
      }
      return {vis: lines.join("\n"), cids};
    }
    async function visMerkleClock(blocks, head) {
      const lines = [];
      for await (const line of vis$1(blocks, head)) {
        lines.push(line);
      }
      return {vis: lines.join("\n")};
    }
    var charwise = {};
    var number = {};
    number.encode = function(number2) {
      if (isNaN(number2)) {
        return "DaN";
      }
      if (number2 === 0) {
        return "FE  0M0";
      }
      if (number2 === Infinity) {
        return "FF";
      }
      if (number2 === -Infinity) {
        return "DD";
      }
      var splitScientificNotation = number2.toExponential().split("e");
      var exponent = Number(splitScientificNotation[1]) + 500;
      var mantissa = splitScientificNotation[0] + (splitScientificNotation[0].indexOf(".") === -1 ? "." : "") + "0".repeat(20);
      var encoded = "E" + padStart(String(exponent), 3) + "M" + String(mantissa);
      if (number2 > 0) {
        return "F" + encoded;
      } else {
        return "D" + flip(encoded);
      }
    };
    number.decode = function(encoded) {
      if (encoded === "DaN") {
        return NaN;
      }
      if (encoded === "FF") {
        return Infinity;
      }
      if (encoded === "DD") {
        return -Infinity;
      }
      var isNegative = encoded[0] === "D";
      var splitEncoded = (isNegative ? flip(encoded) : encoded).slice(2).split("M");
      return Number((isNegative ? "-" : "") + splitEncoded[1] + "e" + String(Number(splitEncoded[0]) - 500));
    };
    function flip(number2) {
      var flipped = "";
      for (var i = 0; i < number2.length; i++) {
        var digit = number2[i];
        if (isNaN(Number(digit)) || digit === " ") {
          if (digit !== "-") {
            flipped += digit;
          }
        } else {
          flipped += String(9 - Number(digit));
        }
      }
      return flipped;
    }
    function padStart(str, count) {
      return " ".repeat(count - str.length).substr(0, count) + str;
    }
    var object = {};
    var dictEscape = {"?": "?@", "!": "??", '"': "?%"};
    function escape(str) {
      if (!/[!"]/.test(str)) {
        return str;
      }
      return str.replace(/[\?!"]/g, function(match) {
        return dictEscape[match];
      });
    }
    var dictUnescape = {"?@": "?", "??": "!", "?%": '"'};
    function unescape(str) {
      if (!/\?[%\?@]/.test(str)) {
        return str;
      }
      return str.replace(/\?[%\?@]/g, function(match) {
        return dictUnescape[match];
      });
    }
    object.factory = function(codec2) {
      return {
        encode: encode2,
        decode: decode2
      };
      function encode2(array) {
        if (array === null) {
          return "A";
        }
        if (!Array.isArray(array)) {
          throw new Error("can only encode arrays");
        }
        var l = array.length;
        if (l == 0) {
          return "K!";
        }
        var s = encodeItem(array[0]);
        for (var i = 1; i < l; i++) {
          s += '"' + encodeItem(array[i]);
        }
        return "K" + s + "!";
      }
      function encodeItem(item) {
        if (typeof item === "object") {
          return encode2(item);
        }
        return escape(codec2.encode(item));
      }
      function decode2(encoded) {
        if (encoded === "A") {
          return null;
        }
        if (encoded === "K!") {
          return [];
        }
        var items = encoded.split('"');
        var pointers = [[]];
        var array;
        var depth = 0;
        var l = items.length;
        for (var i = 0; i < l; i++) {
          var item = items[i];
          var itemLength = item.length;
          var open = 0;
          while (item[open] == "K") {
            open++;
          }
          var close2 = 0;
          while (item[itemLength - close2 - 1] == "!") {
            close2++;
          }
          var content = item.slice(open, itemLength - close2);
          var newdepth = depth + open;
          for (var j = depth; j < newdepth; j++) {
            pointers[j + 1] = [];
            pointers[j].push(pointers[j + 1]);
            depth = newdepth;
            array = pointers[depth];
          }
          if (content.length !== 0) {
            array.push(codec2.decode(unescape(content)));
          }
          var newdepth = depth - close2;
          for (var j = newdepth; j < depth; j++) {
            pointers[j + 1] = [];
            depth = newdepth;
            array = pointers[depth];
          }
        }
        return pointers[0][0];
      }
    };
    (function(exports2) {
      var number$1 = number;
      var object$1 = object;
      exports2.flip = function(n) {
        var s = n.toString();
        var f = "";
        for (var i in s) {
          f += s[i] == "." ? "." : 9 - +s[i];
        }
        return f;
      };
      exports2.number = number$1;
      exports2.string = {
        encode: function(s) {
          if (!/\x00|\x01/.test(s))
            return "J" + s;
          else {
            return "J" + s.replace(/\x01/g, "").replace(/\x00/g, "");
          }
        },
        decode: function(s) {
          if (s[0] === "J")
            return s.substring(1);
        }
      };
      exports2.encode = function(t) {
        return exports2[typeof t].encode(t);
      };
      exports2.decode = function(s) {
        if (s === "")
          return s;
        if (!decoders2[s[0]])
          throw new Error("no decoder for:" + JSON.stringify(s));
        return decoders2[s[0]](s);
      };
      exports2.object = object$1.factory(exports2);
      exports2.boolean = {
        encode: function(b) {
          return b ? "C" : "B";
        },
        decode: function(b) {
          return b === "C";
        }
      };
      exports2.undefined = {
        encode: function(b) {
          return "L";
        },
        decode: function() {
          return void 0;
        }
      };
      var decoders2 = {
        A: exports2.object.decode,
        B: exports2.boolean.decode,
        C: exports2.boolean.decode,
        D: exports2.number.decode,
        F: exports2.number.decode,
        J: exports2.string.decode,
        K: exports2.object.decode,
        L: exports2.undefined.decode
      };
      exports2.buffer = false;
      exports2.type = "charwise";
    })(charwise);
    var compare$1 = (a, b) => {
      const [aKey, aRef] = a;
      const [bKey, bRef] = b;
      const comp = simpleCompare(aKey, bKey);
      if (comp !== 0)
        return comp;
      return refCompare$1(aRef, bRef);
    };
    var refCompare$1 = (aRef, bRef) => {
      if (Number.isNaN(aRef))
        return -1;
      if (Number.isNaN(bRef))
        throw new Error("ref may not be Infinity or NaN");
      if (!Number.isFinite(aRef))
        return 1;
      return simpleCompare(aRef, bRef);
    };
    var getIndex = async (node2, key2) => {
      const start = [
        key2,
        NaN
      ];
      const end = [
        key2,
        Infinity
      ];
      const {
        result: entries,
        cids
      } = await node2.getRangeEntries(start, end);
      return {
        result: entries.map((entry) => {
          const [key3, id] = entry.key;
          return {
            id,
            key: key3,
            row: entry.value
          };
        }),
        cids
      };
    };
    var getRange = async (node2, start, end) => {
      start = [
        start,
        NaN
      ];
      end = [
        end,
        Infinity
      ];
      const {
        result: entries,
        cids
      } = await node2.getRangeEntries(start, end);
      const result = entries.map((entry) => {
        const [key2, id] = entry.key;
        return {
          id,
          key: key2,
          row: entry.value
        };
      });
      return {
        result,
        cids
      };
    };
    var DBIndexLeaf = class extends MapLeaf {
      get(key2) {
        return getIndex(this, key2);
      }
      range(start, end) {
        return getRange(this, start, end);
      }
      bulk(bulk, opts = {}, isRoot = true) {
        return super.bulk(bulk, {
          ...classes,
          ...opts
        }, isRoot);
      }
    };
    var DBIndexBranch = class extends MapBranch {
      get(key2) {
        return getIndex(this, key2);
      }
      range(start, end) {
        return getRange(this, start, end);
      }
      bulk(bulk, opts = {}, isRoot = true) {
        return super.bulk(bulk, {
          ...classes,
          ...opts
        }, isRoot);
      }
    };
    var LeafClass = DBIndexLeaf;
    var BranchClass = DBIndexBranch;
    var classes = {
      LeafClass,
      BranchClass,
      LeafEntryClass: MapLeafEntry,
      BranchEntryClass: MapBranchEntry
    };
    var defaults = {
      ...classes,
      compare: compare$1
    };
    var create = (opts) => {
      opts = {
        ...defaults,
        ...opts
      };
      return create$4(opts);
    };
    var load = (opts) => {
      opts = {
        ...defaults,
        ...opts
      };
      return load$4(opts);
    };
    var compare = (a, b) => {
      const [aKey, aRef] = a;
      const [bKey, bRef] = b;
      const comp = simpleCompare(aKey, bKey);
      if (comp !== 0)
        return comp;
      return refCompare(aRef, bRef);
    };
    var refCompare = (aRef, bRef) => {
      if (Number.isNaN(aRef))
        return -1;
      if (Number.isNaN(bRef))
        throw new Error("ref may not be Infinity or NaN");
      if (aRef === Infinity)
        return 1;
      return simpleCompare(aRef, bRef);
    };
    var dbIndexOpts = {cache: nocache, chunker: bf(30), codec: codec$1, hasher: sha256$2, compare};
    var idIndexOpts = {cache: nocache, chunker: bf(30), codec: codec$1, hasher: sha256$2, compare: simpleCompare};
    var makeDoc = ({key: key2, value}) => ({_id: key2, ...value});
    var indexEntriesForChanges = (changes, mapFn) => {
      const indexEntries = [];
      changes.forEach(({key: _id, value, del}) => {
        if (del || !value)
          return;
        let mapCalled = false;
        const mapReturn = mapFn(makeDoc({key: _id, value}), (k, v2) => {
          mapCalled = true;
          if (typeof k === "undefined")
            return;
          indexEntries.push({
            key: [charwise.encode(k), _id],
            value: v2 || null
          });
        });
        if (!mapCalled && mapReturn) {
          indexEntries.push({
            key: [charwise.encode(mapReturn), _id],
            value: null
          });
        }
      });
      return indexEntries;
    };
    var DbIndex = class {
      constructor(database, name2, mapFn, clock = null, opts = {}) {
        this.database = database;
        if (typeof name2 === "function") {
          opts = clock || {};
          clock = mapFn || null;
          mapFn = name2;
          name2 = null;
        }
        this.applyMapFn(mapFn, name2);
        this.indexById = {root: null, cid: null};
        this.indexByKey = {root: null, cid: null};
        this.dbHead = null;
        if (clock) {
          this.indexById.cid = clock.byId;
          this.indexByKey.cid = clock.byKey;
          this.dbHead = clock.db;
        }
        this.instanceId = this.database.instanceId + `.DbIndex.${Math.random().toString(36).substring(2, 7)}`;
        this.updateIndexPromise = null;
        if (!opts.temporary) {
          DbIndex.registerWithDatabase(this, this.database);
        }
      }
      applyMapFn(mapFn, name2) {
        if (typeof mapFn === "string") {
          this.mapFnString = mapFn;
          const regex = /^[a-zA-Z0-9 ]+$/;
          if (regex.test(mapFn)) {
            this.mapFn = (doc, emit2) => {
              if (doc[mapFn])
                emit2(doc[mapFn]);
            };
            this.includeDocsDefault = true;
          }
        } else {
          this.mapFn = mapFn;
          this.mapFnString = mapFn.toString();
        }
        const matches = /=>\s*(.*)/.exec(this.mapFnString);
        this.includeDocsDefault = this.includeDocsDefault || matches && matches.length > 0;
        this.name = name2 || this.makeName();
      }
      makeName() {
        const regex = /\(([^,()]+,\s*[^,()]+|\[[^\]]+\],\s*[^,()]+)\)/g;
        let matches = Array.from(this.mapFnString.matchAll(regex), (match) => match[1].trim());
        if (matches.length === 0) {
          matches = /=>\s*(.*)/.exec(this.mapFnString);
        }
        if (matches === null) {
          return this.mapFnString;
        } else {
          return matches[1];
        }
      }
      static registerWithDatabase(inIndex, database) {
        if (!database.indexes.has(inIndex.mapFnString)) {
          database.indexes.set(inIndex.mapFnString, inIndex);
        } else {
          const existingIndex = database.indexes.get(inIndex.mapFnString);
          if (existingIndex.mapFn) {
            existingIndex.dbHead = inIndex.dbHead;
            existingIndex.indexById.cid = inIndex.indexById.cid;
            existingIndex.indexByKey.cid = inIndex.indexByKey.cid;
          } else {
            inIndex.dbHead = existingIndex.dbHead;
            inIndex.indexById.cid = existingIndex.indexById.cid;
            inIndex.indexByKey.cid = existingIndex.indexByKey.cid;
            database.indexes.set(inIndex.mapFnString, inIndex);
          }
        }
      }
      toJSON() {
        const indexJson = {name: this.name, code: this.mapFnString, clock: {db: null, byId: null, byKey: null}};
        indexJson.clock.db = this.dbHead?.map((cid) => cid.toString());
        indexJson.clock.byId = this.indexById.cid?.toString();
        indexJson.clock.byKey = this.indexByKey.cid?.toString();
        return indexJson;
      }
      static fromJSON(database, {code: code2, clock, name: name2}) {
        return new DbIndex(database, name2, code2, clock);
      }
      async visKeyTree() {
        return await visMerkleTree(this.database.indexBlocks, this.indexById.cid);
      }
      async visIdTree() {
        return await visMerkleTree(this.database.indexBlocks, this.indexByKey.cid);
      }
      async query(query = {}, update = true) {
        update && await this.updateIndex(this.database.indexBlocks);
        const response = await this.doIndexQuery(query);
        return {
          proof: {index: await cidsToProof(response.cids)},
          rows: response.result.map(({id, key: key2, row, doc}) => {
            return {id, key: charwise.decode(key2), value: row, doc};
          })
        };
      }
      async applyQuery(resp, query) {
        if (query.descending) {
          resp.result = resp.result.reverse();
        }
        if (query.limit) {
          resp.result = resp.result.slice(0, query.limit);
        }
        if (query.includeDocs) {
          resp.result = await Promise.all(resp.result.map(async (row) => {
            const doc = await this.database.get(row.id);
            return {...row, doc};
          }));
        }
        return resp;
      }
      async doIndexQuery(query = {}) {
        await loadIndex(this.database.indexBlocks, this.indexByKey, dbIndexOpts);
        if (!this.indexByKey.root)
          return {result: []};
        if (query.includeDocs === void 0)
          query.includeDocs = this.includeDocsDefault;
        if (query.prefix) {
          if (!Array.isArray(query.prefix))
            query.prefix = [query.prefix];
          const start = [...query.prefix, NaN];
          const end = [...query.prefix, Infinity];
          const prefixRange = [start, end].map((key2) => charwise.encode(key2));
          return await this.applyQuery(await this.indexByKey.root.range(...prefixRange), query);
        } else if (query.range) {
          const encodedRange = query.range.map((key2) => charwise.encode(key2));
          return await this.applyQuery(await this.indexByKey.root.range(...encodedRange), query);
        } else if (query.key) {
          const encodedKey = charwise.encode(query.key);
          return await this.applyQuery(await this.indexByKey.root.get(encodedKey), query);
        } else {
          const {result, ...all} = await this.indexByKey.root.getAllEntries();
          return await this.applyQuery({result: result.map(({key: [k, id], value}) => ({key: k, id, row: value})), ...all}, query);
        }
      }
      async updateIndex(blocks) {
        if (this.updateIndexPromise) {
          return this.updateIndexPromise.then(() => {
            this.updateIndexPromise = null;
            return this.updateIndex(blocks);
          });
        }
        this.updateIndexPromise = this.innerUpdateIndex(blocks);
        this.updateIndexPromise.finally(() => {
          this.updateIndexPromise = null;
        });
        return this.updateIndexPromise;
      }
      async innerUpdateIndex(inBlocks) {
        const result = await this.database.changesSince(this.dbHead);
        if (result.rows.length === 0) {
          this.dbHead = result.clock;
          return;
        }
        const didT = await doTransaction("updateIndex", inBlocks, async (blocks) => {
          let oldIndexEntries = [];
          let removeByIdIndexEntries = [];
          await loadIndex(blocks, this.indexById, idIndexOpts);
          await loadIndex(blocks, this.indexByKey, dbIndexOpts);
          if (this.indexById.root) {
            const oldChangeEntries = await this.indexById.root.getMany(result.rows.map(({key: key2}) => key2));
            oldIndexEntries = oldChangeEntries.result.map((key2) => ({key: key2, del: true}));
            removeByIdIndexEntries = oldIndexEntries.map(({key: key2}) => ({key: key2[1], del: true}));
          }
          if (!this.mapFn) {
            throw new Error("No live map function installed for index, cannot update. Make sure your index definition runs before any queries." + (this.mapFnString ? " Your code should match the stored map function source:\n" + this.mapFnString : ""));
          }
          const indexEntries = indexEntriesForChanges(result.rows, this.mapFn);
          const byIdIndexEntries = indexEntries.map(({key: key2}) => ({key: key2[1], value: key2}));
          this.indexById = await bulkIndex(blocks, this.indexById, removeByIdIndexEntries.concat(byIdIndexEntries), idIndexOpts);
          this.indexByKey = await bulkIndex(blocks, this.indexByKey, oldIndexEntries.concat(indexEntries), dbIndexOpts);
          this.dbHead = result.clock;
        }, false);
        return didT;
      }
    };
    async function bulkIndex(blocks, inIndex, indexEntries, opts) {
      if (!indexEntries.length)
        return inIndex;
      const putBlock = blocks.put.bind(blocks);
      const {getBlock} = makeGetBlock(blocks);
      let returnRootBlock;
      let returnNode;
      if (!inIndex.root) {
        const cid = inIndex.cid;
        if (!cid) {
          for await (const node2 of await create({get: getBlock, list: indexEntries, ...opts})) {
            const block = await node2.block;
            await putBlock(block.cid, block.bytes);
            returnRootBlock = block;
            returnNode = node2;
          }
          return {root: returnNode, cid: returnRootBlock.cid};
        }
        inIndex.root = await load({cid, get: getBlock, ...dbIndexOpts});
      }
      const {root: root2, blocks: newBlocks} = await inIndex.root.bulk(indexEntries);
      if (root2) {
        returnRootBlock = await root2.block;
        returnNode = root2;
        for await (const block of newBlocks) {
          await putBlock(block.cid, block.bytes);
        }
        await putBlock(returnRootBlock.cid, returnRootBlock.bytes);
        return {root: returnNode, cid: returnRootBlock.cid};
      } else {
        return {root: null, cid: null};
      }
    }
    async function loadIndex(blocks, index2, indexOpts) {
      if (!index2.root) {
        const cid = index2.cid;
        if (!cid) {
          return null;
        }
        const {getBlock} = makeGetBlock(blocks);
        index2.root = await load({cid, get: getBlock, ...indexOpts});
      }
      return index2.root;
    }
    var parseCID = (cid) => typeof cid === "string" ? CID.parse(cid) : cid;
    var Database = class {
      listeners = new Set();
      indexes = new Map();
      rootCache = null;
      eventsCache = new Map();
      constructor(name2, config2 = {}) {
        this.name = name2;
        this.clock = [];
        this.instanceId = `fp.${this.name}.${Math.random().toString(36).substring(2, 7)}`;
        this.blocks = new TransactionBlockstore(name2, config2);
        this.indexBlocks = new TransactionBlockstore(name2 ? name2 + ".indexes" : null, {primary: config2.index});
        this.config = config2;
        this.ready = Promise.all([this.blocks.ready, this.indexBlocks.ready]).then(([blocksReady, indexReady]) => {
          const clock = new Set();
          if (!blocksReady) {
            return;
          }
          for (const headers of blocksReady) {
            for (const [, header] of Object.entries(headers)) {
              if (!header)
                continue;
              for (const cid of header.clock) {
                clock.add(cid);
              }
              if (header.index) {
                this.indexBlocks.valet.primary.setCarCidMapCarCid(header.index.car);
                this.indexBlocks.valet.primary.setKeyMaterial(header.index.key);
              }
              if (header.indexes) {
                for (const {
                  name: name3,
                  code: code2,
                  clock: {byId, byKey, db}
                } of header.indexes) {
                  DbIndex.fromJSON(this, {
                    clock: {
                      byId: byId ? parseCID(byId) : null,
                      byKey: byKey ? parseCID(byKey) : null,
                      db: db && db.length > 0 ? db.map((c) => parseCID(c)) : null
                    },
                    code: code2,
                    name: name3
                  });
                }
              }
            }
          }
          this.clock = [...clock];
        });
      }
      toJSON() {
        return this.blocks.valet ? this.blocks.valet.primary.prepareHeader(this.toHeader(), false) : this.toHeader();
      }
      toHeader() {
        return {
          clock: this.clockToJSON(),
          name: this.name,
          index: {
            key: this.indexBlocks.valet?.primary.keyMaterial,
            car: this.indexBlocks.valet?.primary.valetRootCarCid?.toString()
          },
          indexes: [...this.indexes.values()].map((index2) => index2.toJSON())
        };
      }
      clockToJSON(clock = null) {
        return (clock || this.clock).map((cid) => cid.toString());
      }
      maybeSaveClock() {
        if (this.name && this.blocks.valet) {
          this.blocks.valet.saveHeader(this.toHeader());
        }
      }
      index(name2) {
        const indexes = [...this.indexes.values()].filter((index2) => index2.name === name2);
        if (indexes.length > 1) {
          throw new Error(`Multiple indexes found with name ${name2}`);
        }
        return indexes[0] || null;
      }
      async notifyReset() {
        await this.ready;
        await this.notifyListeners({_reset: true, _clock: this.clockToJSON()});
      }
      async compact() {
        if (this.name && this.blocks.valet) {
          await this.blocks.valet.compact(this.clock);
          await this.blocks.valet.saveHeader(this.toHeader());
        }
      }
      async changesSince(aClock) {
        await this.ready;
        let rows, dataCIDs, clockCIDs;
        if (aClock && aClock.length > 0) {
          aClock = aClock.map((cid) => cid.toString());
          const eventKey = JSON.stringify([...this.clockToJSON(aClock), ...this.clockToJSON()]);
          let resp;
          if (this.eventsCache.has(eventKey)) {
            resp = this.eventsCache.get(eventKey);
          } else {
            resp = await eventsSince(this.blocks, this.clock, aClock);
            this.eventsCache.set(eventKey, resp);
          }
          const docsMap = new Map();
          for (const {key: key2, type, value} of resp.result.map(decodeEvent)) {
            if (type === "del") {
              docsMap.set(key2, {key: key2, del: true});
            } else {
              docsMap.set(key2, {key: key2, value});
            }
          }
          rows = Array.from(docsMap.values());
          clockCIDs = resp.clockCIDs;
        } else {
          const allResp = await getAll(this.blocks, this.clock, this.rootCache);
          this.rootCache = {root: allResp.root, clockCIDs: allResp.clockCIDs};
          rows = allResp.result.map(({key: key2, value}) => decodeEvent({key: key2, value}));
          dataCIDs = allResp.cids;
        }
        return {
          rows,
          clock: this.clockToJSON(),
          proof: {data: await cidsToProof(dataCIDs), clock: await cidsToProof(clockCIDs)}
        };
      }
      async allDocuments() {
        await this.ready;
        const allResp = await getAll(this.blocks, this.clock, this.rootCache);
        this.rootCache = {root: allResp.root, clockCIDs: allResp.clockCIDs};
        const rows = allResp.result.map(({key: key2, value}) => decodeEvent({key: key2, value})).map(({key: key2, value}) => ({key: key2, value: {_id: key2, ...value}}));
        return {
          rows,
          clock: this.clockToJSON(),
          proof: await cidsToProof(allResp.cids)
        };
      }
      async allCIDs() {
        await this.ready;
        const allResp = await getAll(this.blocks, this.clock, this.rootCache, true);
        this.rootCache = {root: allResp.root, clockCIDs: allResp.clockCIDs};
        const cids = await cidsToProof(allResp.cids);
        const clockCids = await cidsToProof(allResp.clockCIDs);
        return [...cids, ...clockCids];
      }
      async allStoredCIDs() {
        await this.ready;
        const allCIDs = [];
        for await (const {cid} of this.blocks.entries()) {
          allCIDs.push(cid);
        }
        return allCIDs;
      }
      async get(key2, opts = {}) {
        await this.ready;
        const clock = opts.clock || this.clock;
        const resp = await get(this.blocks, clock, charwise.encode(key2), this.rootCache);
        this.rootCache = {root: resp.root, clockCIDs: resp.clockCIDs};
        if (!resp || resp.result === null) {
          throw new Error("Not found");
        }
        const doc = {...resp.result};
        if (opts.mvcc === true) {
          doc._clock = this.clockToJSON();
        }
        doc._proof = {
          data: await cidsToProof(resp.cids),
          clock: this.clockToJSON()
        };
        doc._id = key2;
        return doc;
      }
      async put({_id, _proof, ...doc}) {
        await this.ready;
        const id = _id || "f" + Math.random().toString(36).slice(2);
        await this.runValidation({_id: id, ...doc});
        return await this.putToProllyTree({key: id, value: doc}, doc._clock);
      }
      async del(docOrId) {
        await this.ready;
        let id;
        let clock = null;
        if (docOrId._id) {
          id = docOrId._id;
          clock = docOrId._clock;
        } else {
          id = docOrId;
        }
        await this.runValidation({_id: id, _deleted: true});
        return await this.putToProllyTree({key: id, del: true}, clock);
      }
      async runValidation(doc) {
        if (this.config && this.config.validateChange) {
          const oldDoc = await this.get(doc._id).then((doc2) => doc2).catch(() => ({}));
          this.config.validateChange(doc, oldDoc, this.authCtx);
        }
      }
      async putToProllyTree(decodedEvent, clock = null) {
        const event = encodeEvent(decodedEvent);
        if (clock && JSON.stringify(this.clockToJSON(clock)) !== JSON.stringify(this.clockToJSON())) {
          const resp = await eventsSince(this.blocks, this.clock, event.value._clock);
          const missedChange = resp.result.find(({key: key2}) => key2 === event.key);
          if (missedChange) {
            throw new Error("MVCC conflict, document is changed, please reload the document and try again.");
          }
        }
        const prevClock = [...this.clock];
        const result = await doTransaction("putToProllyTree", this.blocks, async (blocks) => await put(blocks, this.clock, event));
        if (!result) {
          console.error("failed", event);
          throw new Error("failed to put at storage layer");
        }
        this.applyClock(prevClock, result.head);
        await this.notifyListeners([decodedEvent]);
        return {
          id: decodedEvent.key,
          clock: this.clockToJSON(),
          proof: {data: await cidsToProof(result.cids), clock: await cidsToProof(result.clockCIDs)}
        };
      }
      applyClock(prevClock, newClock) {
        const stPrev = prevClock.map((cid) => cid.toString());
        const keptPrevClock = this.clock.filter((cid) => stPrev.indexOf(cid.toString()) === -1);
        const merged = keptPrevClock.concat(newClock);
        const uniquebyCid = new Map();
        for (const cid of merged) {
          uniquebyCid.set(cid.toString(), cid);
        }
        this.clock = Array.from(uniquebyCid.values()).sort((a, b) => a.toString().localeCompare(b.toString()));
        this.rootCache = null;
        this.eventsCache.clear();
      }
      async *vis() {
        return yield* vis(this.blocks, this.clock);
      }
      async visTree() {
        return await visMerkleTree(this.blocks, this.clock);
      }
      async visClock() {
        return await visMerkleClock(this.blocks, this.clock);
      }
      subscribe(listener) {
        this.listeners.add(listener);
        return () => {
          this.listeners.delete(listener);
        };
      }
      registerListener(listener) {
        return this.subscribe(listener);
      }
      async notifyListeners(changes) {
        await this.maybeSaveClock();
        for (const listener of this.listeners) {
          await listener(changes);
        }
      }
      setRemoteBlockReader(remoteBlockReaderFn) {
        this.blocks.remoteBlockFunction = remoteBlockReaderFn;
      }
    };
    async function cidsToProof(cids) {
      if (!cids)
        return [];
      if (!cids.all) {
        return [...cids];
      }
      const all = await cids.all();
      return [...all].map((cid) => cid.toString());
    }
    function decodeEvent(event) {
      const decodedKey = charwise.decode(event.key);
      return {...event, key: decodedKey};
    }
    function encodeEvent(event) {
      if (!(event && event.key))
        return;
      const encodedKey = charwise.encode(event.key);
      return {...event, key: encodedKey};
    }
    var browserExports = {};
    var browser = {
      get exports() {
        return browserExports;
      },
      set exports(v2) {
        browserExports = v2;
      }
    };
    var ms;
    var hasRequiredMs;
    function requireMs() {
      if (hasRequiredMs)
        return ms;
      hasRequiredMs = 1;
      var s = 1e3;
      var m = s * 60;
      var h = m * 60;
      var d = h * 24;
      var w = d * 7;
      var y = d * 365.25;
      ms = function(val, options) {
        options = options || {};
        var type = typeof val;
        if (type === "string" && val.length > 0) {
          return parse2(val);
        } else if (type === "number" && isFinite(val)) {
          return options.long ? fmtLong(val) : fmtShort(val);
        }
        throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
      };
      function parse2(str) {
        str = String(str);
        if (str.length > 100) {
          return;
        }
        var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
        if (!match) {
          return;
        }
        var n = parseFloat(match[1]);
        var type = (match[2] || "ms").toLowerCase();
        switch (type) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return n * y;
          case "weeks":
          case "week":
          case "w":
            return n * w;
          case "days":
          case "day":
          case "d":
            return n * d;
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return n * h;
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return n * m;
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return n * s;
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return n;
          default:
            return void 0;
        }
      }
      function fmtShort(ms2) {
        var msAbs = Math.abs(ms2);
        if (msAbs >= d) {
          return Math.round(ms2 / d) + "d";
        }
        if (msAbs >= h) {
          return Math.round(ms2 / h) + "h";
        }
        if (msAbs >= m) {
          return Math.round(ms2 / m) + "m";
        }
        if (msAbs >= s) {
          return Math.round(ms2 / s) + "s";
        }
        return ms2 + "ms";
      }
      function fmtLong(ms2) {
        var msAbs = Math.abs(ms2);
        if (msAbs >= d) {
          return plural(ms2, msAbs, d, "day");
        }
        if (msAbs >= h) {
          return plural(ms2, msAbs, h, "hour");
        }
        if (msAbs >= m) {
          return plural(ms2, msAbs, m, "minute");
        }
        if (msAbs >= s) {
          return plural(ms2, msAbs, s, "second");
        }
        return ms2 + " ms";
      }
      function plural(ms2, msAbs, n, name2) {
        var isPlural = msAbs >= n * 1.5;
        return Math.round(ms2 / n) + " " + name2 + (isPlural ? "s" : "");
      }
      return ms;
    }
    function setup(env2) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce2;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = requireMs();
      createDebug.destroy = destroy;
      Object.keys(env2).forEach((key2) => {
        createDebug[key2] = env2[key2];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash2 = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash2 = (hash2 << 5) - hash2 + namespace.charCodeAt(i);
          hash2 |= 0;
        }
        return createDebug.colors[Math.abs(hash2) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug2(...args) {
          if (!debug2.enabled) {
            return;
          }
          const self2 = debug2;
          const curr = Number(new Date());
          const ms2 = curr - (prevTime || curr);
          self2.diff = ms2;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index2 = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format2) => {
            if (match === "%%") {
              return "%";
            }
            index2++;
            const formatter = createDebug.formatters[format2];
            if (typeof formatter === "function") {
              const val = args[index2];
              match = formatter.call(self2, val);
              args.splice(index2, 1);
              index2--;
            }
            return match;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug2.namespace = namespace;
        debug2.useColors = createDebug.useColors();
        debug2.color = createDebug.selectColor(namespace);
        debug2.extend = extend;
        debug2.destroy = createDebug.destroy;
        Object.defineProperty(debug2, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v2) => {
            enableOverride = v2;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug2);
        }
        return debug2;
      }
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        let i;
        const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        const len = split.length;
        for (i = 0; i < len; i++) {
          if (!split[i]) {
            continue;
          }
          namespaces = split[i].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
          } else {
            createDebug.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
      }
      function disable() {
        const namespaces = [
          ...createDebug.names.map(toNamespace),
          ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name2) {
        if (name2[name2.length - 1] === "*") {
          return true;
        }
        let i;
        let len;
        for (i = 0, len = createDebug.skips.length; i < len; i++) {
          if (createDebug.skips[i].test(name2)) {
            return false;
          }
        }
        for (i = 0, len = createDebug.names.length; i < len; i++) {
          if (createDebug.names[i].test(name2)) {
            return true;
          }
        }
        return false;
      }
      function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
      }
      function coerce2(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    var common = setup;
    (function(module2, exports2) {
      exports2.formatArgs = formatArgs;
      exports2.save = save2;
      exports2.load = load2;
      exports2.useColors = useColors;
      exports2.storage = localstorage();
      exports2.destroy = (() => {
        let warned = false;
        return () => {
          if (!warned) {
            warned = true;
            console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
          }
        };
      })();
      exports2.colors = [
        "#0000CC",
        "#0000FF",
        "#0033CC",
        "#0033FF",
        "#0066CC",
        "#0066FF",
        "#0099CC",
        "#0099FF",
        "#00CC00",
        "#00CC33",
        "#00CC66",
        "#00CC99",
        "#00CCCC",
        "#00CCFF",
        "#3300CC",
        "#3300FF",
        "#3333CC",
        "#3333FF",
        "#3366CC",
        "#3366FF",
        "#3399CC",
        "#3399FF",
        "#33CC00",
        "#33CC33",
        "#33CC66",
        "#33CC99",
        "#33CCCC",
        "#33CCFF",
        "#6600CC",
        "#6600FF",
        "#6633CC",
        "#6633FF",
        "#66CC00",
        "#66CC33",
        "#9900CC",
        "#9900FF",
        "#9933CC",
        "#9933FF",
        "#99CC00",
        "#99CC33",
        "#CC0000",
        "#CC0033",
        "#CC0066",
        "#CC0099",
        "#CC00CC",
        "#CC00FF",
        "#CC3300",
        "#CC3333",
        "#CC3366",
        "#CC3399",
        "#CC33CC",
        "#CC33FF",
        "#CC6600",
        "#CC6633",
        "#CC9900",
        "#CC9933",
        "#CCCC00",
        "#CCCC33",
        "#FF0000",
        "#FF0033",
        "#FF0066",
        "#FF0099",
        "#FF00CC",
        "#FF00FF",
        "#FF3300",
        "#FF3333",
        "#FF3366",
        "#FF3399",
        "#FF33CC",
        "#FF33FF",
        "#FF6600",
        "#FF6633",
        "#FF9900",
        "#FF9933",
        "#FFCC00",
        "#FFCC33"
      ];
      function useColors() {
        if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
          return true;
        }
        if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
          return false;
        }
        return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
      }
      function formatArgs(args) {
        args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
        if (!this.useColors) {
          return;
        }
        const c = "color: " + this.color;
        args.splice(1, 0, c, "color: inherit");
        let index2 = 0;
        let lastC = 0;
        args[0].replace(/%[a-zA-Z%]/g, (match) => {
          if (match === "%%") {
            return;
          }
          index2++;
          if (match === "%c") {
            lastC = index2;
          }
        });
        args.splice(lastC, 0, c);
      }
      exports2.log = console.debug || console.log || (() => {
      });
      function save2(namespaces) {
        try {
          if (namespaces) {
            exports2.storage.setItem("debug", namespaces);
          } else {
            exports2.storage.removeItem("debug");
          }
        } catch (error) {
        }
      }
      function load2() {
        let r;
        try {
          r = exports2.storage.getItem("debug");
        } catch (error) {
        }
        if (!r && typeof process !== "undefined" && "env" in process) {
          r = process.env.DEBUG;
        }
        return r;
      }
      function localstorage() {
        try {
          return localStorage;
        } catch (error) {
        }
      }
      module2.exports = common(exports2);
      const {formatters} = module2.exports;
      formatters.j = function(v2) {
        try {
          return JSON.stringify(v2);
        } catch (error) {
          return "[UnexpectedJSONParseError]: " + error.message;
        }
      };
    })(browser, browserExports);
    var getBrowserRtc = function getBrowserRTC2() {
      if (typeof globalThis === "undefined")
        return null;
      var wrtc = {
        RTCPeerConnection: globalThis.RTCPeerConnection || globalThis.mozRTCPeerConnection || globalThis.webkitRTCPeerConnection,
        RTCSessionDescription: globalThis.RTCSessionDescription || globalThis.mozRTCSessionDescription || globalThis.webkitRTCSessionDescription,
        RTCIceCandidate: globalThis.RTCIceCandidate || globalThis.mozRTCIceCandidate || globalThis.webkitRTCIceCandidate
      };
      if (!wrtc.RTCPeerConnection)
        return null;
      return wrtc;
    };
    /*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
    var promise;
    var queueMicrotask_1 = typeof queueMicrotask === "function" ? queueMicrotask.bind(typeof window !== "undefined" ? window : commonjsGlobal) : (cb) => (promise || (promise = Promise.resolve())).then(cb).catch((err) => setTimeout(() => {
      throw err;
    }, 0));
    function assign(obj, props) {
      for (const key2 in props) {
        Object.defineProperty(obj, key2, {
          value: props[key2],
          enumerable: true,
          configurable: true
        });
      }
      return obj;
    }
    function createError(err, code2, props) {
      if (!err || typeof err === "string") {
        throw new TypeError("Please pass an Error to err-code");
      }
      if (!props) {
        props = {};
      }
      if (typeof code2 === "object") {
        props = code2;
        code2 = "";
      }
      if (code2) {
        props.code = code2;
      }
      try {
        return assign(err, props);
      } catch (_) {
        props.message = err.message;
        props.stack = err.stack;
        const ErrClass = function() {
        };
        ErrClass.prototype = Object.create(Object.getPrototypeOf(err));
        const output = assign(new ErrClass(), props);
        return output;
      }
    }
    var errCode$1 = createError;
    /*! simple-peer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
    var debug = browserExports("simple-peer");
    var getBrowserRTC = getBrowserRtc;
    var randombytes = browserExports$1;
    var stream = readableBrowserExports;
    var queueMicrotask$1 = queueMicrotask_1;
    var errCode = errCode$1;
    var {Buffer: Buffer$1} = require$$6$1;
    var MAX_BUFFERED_AMOUNT = 64 * 1024;
    var ICECOMPLETE_TIMEOUT = 5 * 1e3;
    var CHANNEL_CLOSING_TIMEOUT = 5 * 1e3;
    function filterTrickle(sdp) {
      return sdp.replace(/a=ice-options:trickle\s\n/g, "");
    }
    function warn(message) {
      console.warn(message);
    }
    var Peer = class extends stream.Duplex {
      constructor(opts) {
        opts = Object.assign({
          allowHalfOpen: false
        }, opts);
        super(opts);
        this._id = randombytes(4).toString("hex").slice(0, 7);
        this._debug("new peer %o", opts);
        this.channelName = opts.initiator ? opts.channelName || randombytes(20).toString("hex") : null;
        this.initiator = opts.initiator || false;
        this.channelConfig = opts.channelConfig || Peer.channelConfig;
        this.channelNegotiated = this.channelConfig.negotiated;
        this.config = Object.assign({}, Peer.config, opts.config);
        this.offerOptions = opts.offerOptions || {};
        this.answerOptions = opts.answerOptions || {};
        this.sdpTransform = opts.sdpTransform || ((sdp) => sdp);
        this.streams = opts.streams || (opts.stream ? [opts.stream] : []);
        this.trickle = opts.trickle !== void 0 ? opts.trickle : true;
        this.allowHalfTrickle = opts.allowHalfTrickle !== void 0 ? opts.allowHalfTrickle : false;
        this.iceCompleteTimeout = opts.iceCompleteTimeout || ICECOMPLETE_TIMEOUT;
        this.destroyed = false;
        this.destroying = false;
        this._connected = false;
        this.remoteAddress = void 0;
        this.remoteFamily = void 0;
        this.remotePort = void 0;
        this.localAddress = void 0;
        this.localFamily = void 0;
        this.localPort = void 0;
        this._wrtc = opts.wrtc && typeof opts.wrtc === "object" ? opts.wrtc : getBrowserRTC();
        if (!this._wrtc) {
          if (typeof window === "undefined") {
            throw errCode(new Error("No WebRTC support: Specify `opts.wrtc` option in this environment"), "ERR_WEBRTC_SUPPORT");
          } else {
            throw errCode(new Error("No WebRTC support: Not a supported browser"), "ERR_WEBRTC_SUPPORT");
          }
        }
        this._pcReady = false;
        this._channelReady = false;
        this._iceComplete = false;
        this._iceCompleteTimer = null;
        this._channel = null;
        this._pendingCandidates = [];
        this._isNegotiating = false;
        this._firstNegotiation = true;
        this._batchedNegotiation = false;
        this._queuedNegotiation = false;
        this._sendersAwaitingStable = [];
        this._senderMap = new Map();
        this._closingInterval = null;
        this._remoteTracks = [];
        this._remoteStreams = [];
        this._chunk = null;
        this._cb = null;
        this._interval = null;
        try {
          this._pc = new this._wrtc.RTCPeerConnection(this.config);
        } catch (err) {
          this.destroy(errCode(err, "ERR_PC_CONSTRUCTOR"));
          return;
        }
        this._isReactNativeWebrtc = typeof this._pc._peerConnectionId === "number";
        this._pc.oniceconnectionstatechange = () => {
          this._onIceStateChange();
        };
        this._pc.onicegatheringstatechange = () => {
          this._onIceStateChange();
        };
        this._pc.onconnectionstatechange = () => {
          this._onConnectionStateChange();
        };
        this._pc.onsignalingstatechange = () => {
          this._onSignalingStateChange();
        };
        this._pc.onicecandidate = (event) => {
          this._onIceCandidate(event);
        };
        if (typeof this._pc.peerIdentity === "object") {
          this._pc.peerIdentity.catch((err) => {
            this.destroy(errCode(err, "ERR_PC_PEER_IDENTITY"));
          });
        }
        if (this.initiator || this.channelNegotiated) {
          this._setupData({
            channel: this._pc.createDataChannel(this.channelName, this.channelConfig)
          });
        } else {
          this._pc.ondatachannel = (event) => {
            this._setupData(event);
          };
        }
        if (this.streams) {
          this.streams.forEach((stream2) => {
            this.addStream(stream2);
          });
        }
        this._pc.ontrack = (event) => {
          this._onTrack(event);
        };
        this._debug("initial negotiation");
        this._needsNegotiation();
        this._onFinishBound = () => {
          this._onFinish();
        };
        this.once("finish", this._onFinishBound);
      }
      get bufferSize() {
        return this._channel && this._channel.bufferedAmount || 0;
      }
      get connected() {
        return this._connected && this._channel.readyState === "open";
      }
      address() {
        return {port: this.localPort, family: this.localFamily, address: this.localAddress};
      }
      signal(data) {
        if (this.destroying)
          return;
        if (this.destroyed)
          throw errCode(new Error("cannot signal after peer is destroyed"), "ERR_DESTROYED");
        if (typeof data === "string") {
          try {
            data = JSON.parse(data);
          } catch (err) {
            data = {};
          }
        }
        this._debug("signal()");
        if (data.renegotiate && this.initiator) {
          this._debug("got request to renegotiate");
          this._needsNegotiation();
        }
        if (data.transceiverRequest && this.initiator) {
          this._debug("got request for transceiver");
          this.addTransceiver(data.transceiverRequest.kind, data.transceiverRequest.init);
        }
        if (data.candidate) {
          if (this._pc.remoteDescription && this._pc.remoteDescription.type) {
            this._addIceCandidate(data.candidate);
          } else {
            this._pendingCandidates.push(data.candidate);
          }
        }
        if (data.sdp) {
          this._pc.setRemoteDescription(new this._wrtc.RTCSessionDescription(data)).then(() => {
            if (this.destroyed)
              return;
            this._pendingCandidates.forEach((candidate) => {
              this._addIceCandidate(candidate);
            });
            this._pendingCandidates = [];
            if (this._pc.remoteDescription.type === "offer")
              this._createAnswer();
          }).catch((err) => {
            this.destroy(errCode(err, "ERR_SET_REMOTE_DESCRIPTION"));
          });
        }
        if (!data.sdp && !data.candidate && !data.renegotiate && !data.transceiverRequest) {
          this.destroy(errCode(new Error("signal() called with invalid signal data"), "ERR_SIGNALING"));
        }
      }
      _addIceCandidate(candidate) {
        const iceCandidateObj = new this._wrtc.RTCIceCandidate(candidate);
        this._pc.addIceCandidate(iceCandidateObj).catch((err) => {
          if (!iceCandidateObj.address || iceCandidateObj.address.endsWith(".local")) {
            warn("Ignoring unsupported ICE candidate.");
          } else {
            this.destroy(errCode(err, "ERR_ADD_ICE_CANDIDATE"));
          }
        });
      }
      send(chunk) {
        if (this.destroying)
          return;
        if (this.destroyed)
          throw errCode(new Error("cannot send after peer is destroyed"), "ERR_DESTROYED");
        this._channel.send(chunk);
      }
      addTransceiver(kind2, init2) {
        if (this.destroying)
          return;
        if (this.destroyed)
          throw errCode(new Error("cannot addTransceiver after peer is destroyed"), "ERR_DESTROYED");
        this._debug("addTransceiver()");
        if (this.initiator) {
          try {
            this._pc.addTransceiver(kind2, init2);
            this._needsNegotiation();
          } catch (err) {
            this.destroy(errCode(err, "ERR_ADD_TRANSCEIVER"));
          }
        } else {
          this.emit("signal", {
            type: "transceiverRequest",
            transceiverRequest: {kind: kind2, init: init2}
          });
        }
      }
      addStream(stream2) {
        if (this.destroying)
          return;
        if (this.destroyed)
          throw errCode(new Error("cannot addStream after peer is destroyed"), "ERR_DESTROYED");
        this._debug("addStream()");
        stream2.getTracks().forEach((track) => {
          this.addTrack(track, stream2);
        });
      }
      addTrack(track, stream2) {
        if (this.destroying)
          return;
        if (this.destroyed)
          throw errCode(new Error("cannot addTrack after peer is destroyed"), "ERR_DESTROYED");
        this._debug("addTrack()");
        const submap = this._senderMap.get(track) || new Map();
        let sender = submap.get(stream2);
        if (!sender) {
          sender = this._pc.addTrack(track, stream2);
          submap.set(stream2, sender);
          this._senderMap.set(track, submap);
          this._needsNegotiation();
        } else if (sender.removed) {
          throw errCode(new Error("Track has been removed. You should enable/disable tracks that you want to re-add."), "ERR_SENDER_REMOVED");
        } else {
          throw errCode(new Error("Track has already been added to that stream."), "ERR_SENDER_ALREADY_ADDED");
        }
      }
      replaceTrack(oldTrack, newTrack, stream2) {
        if (this.destroying)
          return;
        if (this.destroyed)
          throw errCode(new Error("cannot replaceTrack after peer is destroyed"), "ERR_DESTROYED");
        this._debug("replaceTrack()");
        const submap = this._senderMap.get(oldTrack);
        const sender = submap ? submap.get(stream2) : null;
        if (!sender) {
          throw errCode(new Error("Cannot replace track that was never added."), "ERR_TRACK_NOT_ADDED");
        }
        if (newTrack)
          this._senderMap.set(newTrack, submap);
        if (sender.replaceTrack != null) {
          sender.replaceTrack(newTrack);
        } else {
          this.destroy(errCode(new Error("replaceTrack is not supported in this browser"), "ERR_UNSUPPORTED_REPLACETRACK"));
        }
      }
      removeTrack(track, stream2) {
        if (this.destroying)
          return;
        if (this.destroyed)
          throw errCode(new Error("cannot removeTrack after peer is destroyed"), "ERR_DESTROYED");
        this._debug("removeSender()");
        const submap = this._senderMap.get(track);
        const sender = submap ? submap.get(stream2) : null;
        if (!sender) {
          throw errCode(new Error("Cannot remove track that was never added."), "ERR_TRACK_NOT_ADDED");
        }
        try {
          sender.removed = true;
          this._pc.removeTrack(sender);
        } catch (err) {
          if (err.name === "NS_ERROR_UNEXPECTED") {
            this._sendersAwaitingStable.push(sender);
          } else {
            this.destroy(errCode(err, "ERR_REMOVE_TRACK"));
          }
        }
        this._needsNegotiation();
      }
      removeStream(stream2) {
        if (this.destroying)
          return;
        if (this.destroyed)
          throw errCode(new Error("cannot removeStream after peer is destroyed"), "ERR_DESTROYED");
        this._debug("removeSenders()");
        stream2.getTracks().forEach((track) => {
          this.removeTrack(track, stream2);
        });
      }
      _needsNegotiation() {
        this._debug("_needsNegotiation");
        if (this._batchedNegotiation)
          return;
        this._batchedNegotiation = true;
        queueMicrotask$1(() => {
          this._batchedNegotiation = false;
          if (this.initiator || !this._firstNegotiation) {
            this._debug("starting batched negotiation");
            this.negotiate();
          } else {
            this._debug("non-initiator initial negotiation request discarded");
          }
          this._firstNegotiation = false;
        });
      }
      negotiate() {
        if (this.destroying)
          return;
        if (this.destroyed)
          throw errCode(new Error("cannot negotiate after peer is destroyed"), "ERR_DESTROYED");
        if (this.initiator) {
          if (this._isNegotiating) {
            this._queuedNegotiation = true;
            this._debug("already negotiating, queueing");
          } else {
            this._debug("start negotiation");
            setTimeout(() => {
              this._createOffer();
            }, 0);
          }
        } else {
          if (this._isNegotiating) {
            this._queuedNegotiation = true;
            this._debug("already negotiating, queueing");
          } else {
            this._debug("requesting negotiation from initiator");
            this.emit("signal", {
              type: "renegotiate",
              renegotiate: true
            });
          }
        }
        this._isNegotiating = true;
      }
      destroy(err) {
        this._destroy(err, () => {
        });
      }
      _destroy(err, cb) {
        if (this.destroyed || this.destroying)
          return;
        this.destroying = true;
        this._debug("destroying (error: %s)", err && (err.message || err));
        queueMicrotask$1(() => {
          this.destroyed = true;
          this.destroying = false;
          this._debug("destroy (error: %s)", err && (err.message || err));
          this.readable = this.writable = false;
          if (!this._readableState.ended)
            this.push(null);
          if (!this._writableState.finished)
            this.end();
          this._connected = false;
          this._pcReady = false;
          this._channelReady = false;
          this._remoteTracks = null;
          this._remoteStreams = null;
          this._senderMap = null;
          clearInterval(this._closingInterval);
          this._closingInterval = null;
          clearInterval(this._interval);
          this._interval = null;
          this._chunk = null;
          this._cb = null;
          if (this._onFinishBound)
            this.removeListener("finish", this._onFinishBound);
          this._onFinishBound = null;
          if (this._channel) {
            try {
              this._channel.close();
            } catch (err2) {
            }
            this._channel.onmessage = null;
            this._channel.onopen = null;
            this._channel.onclose = null;
            this._channel.onerror = null;
          }
          if (this._pc) {
            try {
              this._pc.close();
            } catch (err2) {
            }
            this._pc.oniceconnectionstatechange = null;
            this._pc.onicegatheringstatechange = null;
            this._pc.onsignalingstatechange = null;
            this._pc.onicecandidate = null;
            this._pc.ontrack = null;
            this._pc.ondatachannel = null;
          }
          this._pc = null;
          this._channel = null;
          if (err)
            this.emit("error", err);
          this.emit("close");
          cb();
        });
      }
      _setupData(event) {
        if (!event.channel) {
          return this.destroy(errCode(new Error("Data channel event is missing `channel` property"), "ERR_DATA_CHANNEL"));
        }
        this._channel = event.channel;
        this._channel.binaryType = "arraybuffer";
        if (typeof this._channel.bufferedAmountLowThreshold === "number") {
          this._channel.bufferedAmountLowThreshold = MAX_BUFFERED_AMOUNT;
        }
        this.channelName = this._channel.label;
        this._channel.onmessage = (event2) => {
          this._onChannelMessage(event2);
        };
        this._channel.onbufferedamountlow = () => {
          this._onChannelBufferedAmountLow();
        };
        this._channel.onopen = () => {
          this._onChannelOpen();
        };
        this._channel.onclose = () => {
          this._onChannelClose();
        };
        this._channel.onerror = (event2) => {
          const err = event2.error instanceof Error ? event2.error : new Error(`Datachannel error: ${event2.message} ${event2.filename}:${event2.lineno}:${event2.colno}`);
          this.destroy(errCode(err, "ERR_DATA_CHANNEL"));
        };
        let isClosing = false;
        this._closingInterval = setInterval(() => {
          if (this._channel && this._channel.readyState === "closing") {
            if (isClosing)
              this._onChannelClose();
            isClosing = true;
          } else {
            isClosing = false;
          }
        }, CHANNEL_CLOSING_TIMEOUT);
      }
      _read() {
      }
      _write(chunk, encoding, cb) {
        if (this.destroyed)
          return cb(errCode(new Error("cannot write after peer is destroyed"), "ERR_DATA_CHANNEL"));
        if (this._connected) {
          try {
            this.send(chunk);
          } catch (err) {
            return this.destroy(errCode(err, "ERR_DATA_CHANNEL"));
          }
          if (this._channel.bufferedAmount > MAX_BUFFERED_AMOUNT) {
            this._debug("start backpressure: bufferedAmount %d", this._channel.bufferedAmount);
            this._cb = cb;
          } else {
            cb(null);
          }
        } else {
          this._debug("write before connect");
          this._chunk = chunk;
          this._cb = cb;
        }
      }
      _onFinish() {
        if (this.destroyed)
          return;
        const destroySoon = () => {
          setTimeout(() => this.destroy(), 1e3);
        };
        if (this._connected) {
          destroySoon();
        } else {
          this.once("connect", destroySoon);
        }
      }
      _startIceCompleteTimeout() {
        if (this.destroyed)
          return;
        if (this._iceCompleteTimer)
          return;
        this._debug("started iceComplete timeout");
        this._iceCompleteTimer = setTimeout(() => {
          if (!this._iceComplete) {
            this._iceComplete = true;
            this._debug("iceComplete timeout completed");
            this.emit("iceTimeout");
            this.emit("_iceComplete");
          }
        }, this.iceCompleteTimeout);
      }
      _createOffer() {
        if (this.destroyed)
          return;
        this._pc.createOffer(this.offerOptions).then((offer) => {
          if (this.destroyed)
            return;
          if (!this.trickle && !this.allowHalfTrickle)
            offer.sdp = filterTrickle(offer.sdp);
          offer.sdp = this.sdpTransform(offer.sdp);
          const sendOffer = () => {
            if (this.destroyed)
              return;
            const signal = this._pc.localDescription || offer;
            this._debug("signal");
            this.emit("signal", {
              type: signal.type,
              sdp: signal.sdp
            });
          };
          const onSuccess = () => {
            this._debug("createOffer success");
            if (this.destroyed)
              return;
            if (this.trickle || this._iceComplete)
              sendOffer();
            else
              this.once("_iceComplete", sendOffer);
          };
          const onError = (err) => {
            this.destroy(errCode(err, "ERR_SET_LOCAL_DESCRIPTION"));
          };
          this._pc.setLocalDescription(offer).then(onSuccess).catch(onError);
        }).catch((err) => {
          this.destroy(errCode(err, "ERR_CREATE_OFFER"));
        });
      }
      _requestMissingTransceivers() {
        if (this._pc.getTransceivers) {
          this._pc.getTransceivers().forEach((transceiver) => {
            if (!transceiver.mid && transceiver.sender.track && !transceiver.requested) {
              transceiver.requested = true;
              this.addTransceiver(transceiver.sender.track.kind);
            }
          });
        }
      }
      _createAnswer() {
        if (this.destroyed)
          return;
        this._pc.createAnswer(this.answerOptions).then((answer) => {
          if (this.destroyed)
            return;
          if (!this.trickle && !this.allowHalfTrickle)
            answer.sdp = filterTrickle(answer.sdp);
          answer.sdp = this.sdpTransform(answer.sdp);
          const sendAnswer = () => {
            if (this.destroyed)
              return;
            const signal = this._pc.localDescription || answer;
            this._debug("signal");
            this.emit("signal", {
              type: signal.type,
              sdp: signal.sdp
            });
            if (!this.initiator)
              this._requestMissingTransceivers();
          };
          const onSuccess = () => {
            if (this.destroyed)
              return;
            if (this.trickle || this._iceComplete)
              sendAnswer();
            else
              this.once("_iceComplete", sendAnswer);
          };
          const onError = (err) => {
            this.destroy(errCode(err, "ERR_SET_LOCAL_DESCRIPTION"));
          };
          this._pc.setLocalDescription(answer).then(onSuccess).catch(onError);
        }).catch((err) => {
          this.destroy(errCode(err, "ERR_CREATE_ANSWER"));
        });
      }
      _onConnectionStateChange() {
        if (this.destroyed)
          return;
        if (this._pc.connectionState === "failed") {
          this.destroy(errCode(new Error("Connection failed."), "ERR_CONNECTION_FAILURE"));
        }
      }
      _onIceStateChange() {
        if (this.destroyed)
          return;
        const iceConnectionState = this._pc.iceConnectionState;
        const iceGatheringState = this._pc.iceGatheringState;
        this._debug("iceStateChange (connection: %s) (gathering: %s)", iceConnectionState, iceGatheringState);
        this.emit("iceStateChange", iceConnectionState, iceGatheringState);
        if (iceConnectionState === "connected" || iceConnectionState === "completed") {
          this._pcReady = true;
          this._maybeReady();
        }
        if (iceConnectionState === "failed") {
          this.destroy(errCode(new Error("Ice connection failed."), "ERR_ICE_CONNECTION_FAILURE"));
        }
        if (iceConnectionState === "closed") {
          this.destroy(errCode(new Error("Ice connection closed."), "ERR_ICE_CONNECTION_CLOSED"));
        }
      }
      getStats(cb) {
        const flattenValues = (report) => {
          if (Object.prototype.toString.call(report.values) === "[object Array]") {
            report.values.forEach((value) => {
              Object.assign(report, value);
            });
          }
          return report;
        };
        if (this._pc.getStats.length === 0 || this._isReactNativeWebrtc) {
          this._pc.getStats().then((res) => {
            const reports = [];
            res.forEach((report) => {
              reports.push(flattenValues(report));
            });
            cb(null, reports);
          }, (err) => cb(err));
        } else if (this._pc.getStats.length > 0) {
          this._pc.getStats((res) => {
            if (this.destroyed)
              return;
            const reports = [];
            res.result().forEach((result) => {
              const report = {};
              result.names().forEach((name2) => {
                report[name2] = result.stat(name2);
              });
              report.id = result.id;
              report.type = result.type;
              report.timestamp = result.timestamp;
              reports.push(flattenValues(report));
            });
            cb(null, reports);
          }, (err) => cb(err));
        } else {
          cb(null, []);
        }
      }
      _maybeReady() {
        this._debug("maybeReady pc %s channel %s", this._pcReady, this._channelReady);
        if (this._connected || this._connecting || !this._pcReady || !this._channelReady)
          return;
        this._connecting = true;
        const findCandidatePair = () => {
          if (this.destroyed)
            return;
          this.getStats((err, items) => {
            if (this.destroyed)
              return;
            if (err)
              items = [];
            const remoteCandidates = {};
            const localCandidates = {};
            const candidatePairs = {};
            let foundSelectedCandidatePair = false;
            items.forEach((item) => {
              if (item.type === "remotecandidate" || item.type === "remote-candidate") {
                remoteCandidates[item.id] = item;
              }
              if (item.type === "localcandidate" || item.type === "local-candidate") {
                localCandidates[item.id] = item;
              }
              if (item.type === "candidatepair" || item.type === "candidate-pair") {
                candidatePairs[item.id] = item;
              }
            });
            const setSelectedCandidatePair = (selectedCandidatePair) => {
              foundSelectedCandidatePair = true;
              let local = localCandidates[selectedCandidatePair.localCandidateId];
              if (local && (local.ip || local.address)) {
                this.localAddress = local.ip || local.address;
                this.localPort = Number(local.port);
              } else if (local && local.ipAddress) {
                this.localAddress = local.ipAddress;
                this.localPort = Number(local.portNumber);
              } else if (typeof selectedCandidatePair.googLocalAddress === "string") {
                local = selectedCandidatePair.googLocalAddress.split(":");
                this.localAddress = local[0];
                this.localPort = Number(local[1]);
              }
              if (this.localAddress) {
                this.localFamily = this.localAddress.includes(":") ? "IPv6" : "IPv4";
              }
              let remote = remoteCandidates[selectedCandidatePair.remoteCandidateId];
              if (remote && (remote.ip || remote.address)) {
                this.remoteAddress = remote.ip || remote.address;
                this.remotePort = Number(remote.port);
              } else if (remote && remote.ipAddress) {
                this.remoteAddress = remote.ipAddress;
                this.remotePort = Number(remote.portNumber);
              } else if (typeof selectedCandidatePair.googRemoteAddress === "string") {
                remote = selectedCandidatePair.googRemoteAddress.split(":");
                this.remoteAddress = remote[0];
                this.remotePort = Number(remote[1]);
              }
              if (this.remoteAddress) {
                this.remoteFamily = this.remoteAddress.includes(":") ? "IPv6" : "IPv4";
              }
              this._debug("connect local: %s:%s remote: %s:%s", this.localAddress, this.localPort, this.remoteAddress, this.remotePort);
            };
            items.forEach((item) => {
              if (item.type === "transport" && item.selectedCandidatePairId) {
                setSelectedCandidatePair(candidatePairs[item.selectedCandidatePairId]);
              }
              if (item.type === "googCandidatePair" && item.googActiveConnection === "true" || (item.type === "candidatepair" || item.type === "candidate-pair") && item.selected) {
                setSelectedCandidatePair(item);
              }
            });
            if (!foundSelectedCandidatePair && (!Object.keys(candidatePairs).length || Object.keys(localCandidates).length)) {
              setTimeout(findCandidatePair, 100);
              return;
            } else {
              this._connecting = false;
              this._connected = true;
            }
            if (this._chunk) {
              try {
                this.send(this._chunk);
              } catch (err2) {
                return this.destroy(errCode(err2, "ERR_DATA_CHANNEL"));
              }
              this._chunk = null;
              this._debug('sent chunk from "write before connect"');
              const cb = this._cb;
              this._cb = null;
              cb(null);
            }
            if (typeof this._channel.bufferedAmountLowThreshold !== "number") {
              this._interval = setInterval(() => this._onInterval(), 150);
              if (this._interval.unref)
                this._interval.unref();
            }
            this._debug("connect");
            this.emit("connect");
          });
        };
        findCandidatePair();
      }
      _onInterval() {
        if (!this._cb || !this._channel || this._channel.bufferedAmount > MAX_BUFFERED_AMOUNT) {
          return;
        }
        this._onChannelBufferedAmountLow();
      }
      _onSignalingStateChange() {
        if (this.destroyed)
          return;
        if (this._pc.signalingState === "stable") {
          this._isNegotiating = false;
          this._debug("flushing sender queue", this._sendersAwaitingStable);
          this._sendersAwaitingStable.forEach((sender) => {
            this._pc.removeTrack(sender);
            this._queuedNegotiation = true;
          });
          this._sendersAwaitingStable = [];
          if (this._queuedNegotiation) {
            this._debug("flushing negotiation queue");
            this._queuedNegotiation = false;
            this._needsNegotiation();
          } else {
            this._debug("negotiated");
            this.emit("negotiated");
          }
        }
        this._debug("signalingStateChange %s", this._pc.signalingState);
        this.emit("signalingStateChange", this._pc.signalingState);
      }
      _onIceCandidate(event) {
        if (this.destroyed)
          return;
        if (event.candidate && this.trickle) {
          this.emit("signal", {
            type: "candidate",
            candidate: {
              candidate: event.candidate.candidate,
              sdpMLineIndex: event.candidate.sdpMLineIndex,
              sdpMid: event.candidate.sdpMid
            }
          });
        } else if (!event.candidate && !this._iceComplete) {
          this._iceComplete = true;
          this.emit("_iceComplete");
        }
        if (event.candidate) {
          this._startIceCompleteTimeout();
        }
      }
      _onChannelMessage(event) {
        if (this.destroyed)
          return;
        let data = event.data;
        if (data instanceof ArrayBuffer)
          data = Buffer$1.from(data);
        this.push(data);
      }
      _onChannelBufferedAmountLow() {
        if (this.destroyed || !this._cb)
          return;
        this._debug("ending backpressure: bufferedAmount %d", this._channel.bufferedAmount);
        const cb = this._cb;
        this._cb = null;
        cb(null);
      }
      _onChannelOpen() {
        if (this._connected || this.destroyed)
          return;
        this._debug("on channel open");
        this._channelReady = true;
        this._maybeReady();
      }
      _onChannelClose() {
        if (this.destroyed)
          return;
        this._debug("on channel close");
        this.destroy();
      }
      _onTrack(event) {
        if (this.destroyed)
          return;
        event.streams.forEach((eventStream) => {
          this._debug("on track");
          this.emit("track", event.track, eventStream);
          this._remoteTracks.push({
            track: event.track,
            stream: eventStream
          });
          if (this._remoteStreams.some((remoteStream) => {
            return remoteStream.id === eventStream.id;
          }))
            return;
          this._remoteStreams.push(eventStream);
          queueMicrotask$1(() => {
            this._debug("on stream");
            this.emit("stream", eventStream);
          });
        });
      }
      _debug() {
        const args = [].slice.call(arguments);
        args[0] = "[" + this._id + "] " + args[0];
        debug.apply(null, args);
      }
    };
    Peer.WEBRTC_SUPPORT = !!getBrowserRTC();
    Peer.config = {
      iceServers: [
        {
          urls: [
            "stun:stun.l.google.com:19302",
            "stun:global.stun.twilio.com:3478"
          ]
        }
      ],
      sdpSemantics: "unified-plan"
    };
    Peer.channelConfig = {};
    var simplePeer = Peer;
    var Sync = class {
      status = "new";
      constructor(database, PeerClass = simplePeer) {
        this.database = database;
        this.database.blocks.syncs.add(this);
        this.PeerClass = PeerClass;
        this.pushBacklog = new Promise((resolve, reject) => {
          this.pushBacklogResolve = resolve;
          this.pushBacklogReject = reject;
        });
        this.isReady = false;
      }
      async offer() {
        this.status = "offering";
        return this.setupPeer(true);
      }
      async accept(base64offer) {
        const offer = JSON.parse(atob(base64offer));
        const p = this.setupPeer(false);
        this.peer.signal(offer);
        this.status = "accepting";
        return p;
      }
      connect(base64accept) {
        const accept = JSON.parse(atob(base64accept));
        this.status = "connecting";
        this.peer.signal(accept);
      }
      async setupPeer(initiator = false) {
        this.peer = new this.PeerClass({
          initiator,
          trickle: false
        });
        this.peer.on("connect", () => this.startSync());
        this.peer.on("data", (data) => this.gotData(data));
        const p = new Promise((resolve, reject) => {
          this.peer.on("signal", resolve);
          this.peer.on("error", reject);
        });
        return p.then((signal) => btoa(JSON.stringify(signal)));
      }
      async backlog() {
        return this.pushBacklog;
      }
      async gotData(data) {
        let reader = null;
        try {
          reader = await CarReader.fromBytes(data);
        } catch (e) {
        }
        if (reader) {
          this.status = "parking car";
          const blz = new Set();
          for await (const block of reader.blocks()) {
            blz.add(block);
          }
          const roots = await reader.getRoots();
          reader.entries = reader.blocks;
          await this.database.blocks.commit({
            label: "sync",
            entries: () => [...blz],
            get: async (cid) => await reader.get(cid),
            lastCid: [...blz][0].cid
          }, false);
          const parents = await Promise.all(roots.map(async (cid) => {
            const rbl = await reader.get(cid);
            if (!rbl) {
              console.log("missing root block", cid.toString(), reader);
              throw new Error("missing root block");
            }
            const block = await decodeEventBlock(rbl.bytes);
            return block.value.parents;
          }));
          this.database.applyClock(parents.flat(), roots);
          this.database.notifyReset();
          this.pushBacklogResolve({ok: true});
        } else {
          const message = JSON.parse(data.toString());
          if (message.ok) {
            this.status = "ok";
            this.pushBacklogResolve({ok: true});
          } else if (message.clock) {
            const reqCidDiff = message;
            const carBlock = await Sync.makeCar(this.database, null, reqCidDiff.cids);
            if (!carBlock) {
              this.status = "full synced";
              this.peer.send(JSON.stringify({ok: true}));
            } else {
              this.status = "sending diff car";
              this.peer.send(carBlock.bytes);
            }
          }
        }
      }
      destroy() {
        this.database.blocks.syncs.delete(this);
        this.status = "destroyed";
      }
      async sendUpdate(blockstore) {
        if (!this.peer || !this.isReady)
          return;
        const newCar = await blocksToCarBlock(blockstore.lastCid, blockstore);
        this.status = "sending update car";
        this.peer.send(newCar.bytes);
      }
      async startSync() {
        this.isReady = true;
        const allCIDs = await this.database.allStoredCIDs();
        const reqCidDiff = {
          clock: this.database.clockToJSON(),
          cids: allCIDs.map((cid) => cid.toString())
        };
        this.status = "sending cid diff";
        this.peer.send(JSON.stringify(reqCidDiff));
      }
      static async makeCar(database, key2, skip = []) {
        const allCIDs = await database.allCIDs();
        const blocks = database.blocks;
        const rootCIDs = database.clock;
        const newCIDs = [...new Set([...rootCIDs, ...allCIDs])].filter((cid) => !skip.includes(cid.toString()));
        const syncCIDs = [...new Set([...rootCIDs, ...allCIDs.filter((cid) => !skip.includes(cid.toString()))])];
        if (newCIDs.length === 0) {
          return null;
        }
        if (typeof key2 === "undefined") {
          key2 = blocks.valet?.primary.keyMaterial;
        }
        if (key2) {
          return blocksToEncryptedCarBlock(rootCIDs, {
            entries: () => syncCIDs.map((cid) => ({cid})),
            get: async (cid) => await blocks.get(cid)
          }, key2, syncCIDs.map((c) => c.toString()));
        } else {
          const carBlocks = await Promise.all(syncCIDs.map(async (c) => {
            const b = await blocks.get(c);
            if (typeof b.cid === "string") {
              b.cid = parseCID(b.cid);
            }
            return b;
          }));
          return blocksToCarBlock(rootCIDs, {
            entries: () => carBlocks
          });
        }
      }
    };
    var _Fireproof = class {
      static fromJSON(primary, secondary, database) {
        const json = primary && primary.indexes ? primary : secondary;
        if (json.indexes) {
          for (const {
            name: name2,
            code: code2,
            clock: {byId, byKey, db}
          } of json.indexes) {
            DbIndex.fromJSON(database, {
              clock: {
                byId: byId ? parseCID(byId) : null,
                byKey: byKey ? parseCID(byKey) : null,
                db: db && db.length > 0 ? db.map((c) => parseCID(c)) : null
              },
              code: code2,
              name: name2
            });
          }
        }
        return database;
      }
      static snapshot(database, clock) {
        const definition = database.toJSON();
        if (clock) {
          definition.clock = clock.map((c) => parseCID(c));
          definition.indexes.forEach((index2) => {
            index2.clock.byId = null;
            index2.clock.byKey = null;
            index2.clock.db = null;
          });
        }
        const withBlocks = new Database(database.name);
        withBlocks.blocks = database.blocks;
        withBlocks.ready.then(() => {
          withBlocks.clock = definition.clock.map((c) => parseCID(c));
        });
        const snappedDb = _Fireproof.fromJSON(definition, null, withBlocks);
        [...database.indexes.values()].forEach((index2) => {
          snappedDb.indexes.get(index2.mapFnString).mapFn = index2.mapFn;
        });
        return snappedDb;
      }
      static async zoom(database, clock) {
        [...database.indexes.values()].forEach((index2) => {
          index2.indexById = {root: null, cid: null};
          index2.indexByKey = {root: null, cid: null};
          index2.dbHead = null;
        });
        database.clock = clock.map((c) => parseCID(c));
        await database.notifyReset();
        return database;
      }
    };
    var Fireproof = _Fireproof;
    __publicField(Fireproof, "storage", (name2 = null, opts = {}) => {
      return new Database(name2, opts);
    });
    exports.Database = Database;
    exports.Fireproof = Fireproof;
    exports.Index = DbIndex;
    exports.Sync = Sync;
  });

  // ../../node_modules/.pnpm/use-fireproof@0.7.3_react-dom@17.0.2_react@17.0.2/node_modules/use-fireproof/dist/index.js
  var require_dist = __commonJS((exports) => {
    Object.defineProperty(exports, "__esModule", {value: true});
    var react = require_react();
    var core = require_fireproof();
    var __assign = function() {
      return (__assign = Object.assign || function(e) {
        for (var t, r = 1, n = arguments.length; r < n; r++)
          for (var a in t = arguments[r])
            Object.prototype.hasOwnProperty.call(t, a) && (e[a] = t[a]);
        return e;
      }).apply(this, arguments);
    };
    function __awaiter(o, u, i, s) {
      return new (i = i || Promise)(function(e, t) {
        function r(e2) {
          try {
            a(s.next(e2));
          } catch (e3) {
            t(e3);
          }
        }
        function n(e2) {
          try {
            a(s.throw(e2));
          } catch (e3) {
            t(e3);
          }
        }
        function a(t2) {
          t2.done ? e(t2.value) : new i(function(e2) {
            e2(t2.value);
          }).then(r, n);
        }
        a((s = s.apply(o, u || [])).next());
      });
    }
    function __generator(n, a) {
      var o, u, i, s = {label: 0, sent: function() {
        if (1 & i[0])
          throw i[1];
        return i[1];
      }, trys: [], ops: []}, e = {next: t(0), throw: t(1), return: t(2)};
      return typeof Symbol == "function" && (e[Symbol.iterator] = function() {
        return this;
      }), e;
      function t(r) {
        return function(e2) {
          var t2 = [r, e2];
          if (o)
            throw new TypeError("Generator is already executing.");
          for (; s; )
            try {
              if (o = 1, u && (i = 2 & t2[0] ? u.return : t2[0] ? u.throw || ((i = u.return) && i.call(u), 0) : u.next) && !(i = i.call(u, t2[1])).done)
                return i;
              switch (u = 0, (t2 = i ? [2 & t2[0], i.value] : t2)[0]) {
                case 0:
                case 1:
                  i = t2;
                  break;
                case 4:
                  return s.label++, {value: t2[1], done: false};
                case 5:
                  s.label++, u = t2[1], t2 = [0];
                  continue;
                case 7:
                  t2 = s.ops.pop(), s.trys.pop();
                  continue;
                default:
                  if (!(i = 0 < (i = s.trys).length && i[i.length - 1]) && (t2[0] === 6 || t2[0] === 2)) {
                    s = 0;
                    continue;
                  }
                  if (t2[0] === 3 && (!i || t2[1] > i[0] && t2[1] < i[3]))
                    s.label = t2[1];
                  else if (t2[0] === 6 && s.label < i[1])
                    s.label = i[1], i = t2;
                  else {
                    if (!(i && s.label < i[2])) {
                      i[2] && s.ops.pop(), s.trys.pop();
                      continue;
                    }
                    s.label = i[2], s.ops.push(t2);
                  }
              }
              t2 = a.call(n, s);
            } catch (e3) {
              t2 = [6, e3], u = 0;
            } finally {
              o = i = 0;
            }
          if (5 & t2[0])
            throw t2[1];
          return {value: t2[0] ? t2[1] : void 0, done: true};
        };
      }
    }
    var FireproofCtx = react.createContext({});
    var databases = new Map();
    var initializeDatabase = function(e, t, r) {
      var n;
      return typeof e == "object" && e instanceof core.Database ? databases.has(e.name) ? databases.get(e.name) : (t(e), databases.set(e.name, n = {database: e, setupStarted: false}), n) : databases.has(e) ? databases.get(e) : (t(t = core.Fireproof.storage(e, r)), databases.set(e, n = {database: t, setupStarted: false}), n);
    };
    var topLevelUseLiveQuery = function() {
      for (var e = [], t = 0; t < arguments.length; t++)
        e[t] = arguments[t];
      var r = useFireproof2(), n = r.useLiveQuery, r = r.database;
      return topLevelUseLiveQuery.database = r, n.apply(void 0, e);
    };
    var useLiveQuery = topLevelUseLiveQuery;
    var topLevelUseLiveDocument = function() {
      for (var e = [], t = 0; t < arguments.length; t++)
        e[t] = arguments[t];
      var r = useFireproof2(), n = r.useDocument, r = r.database;
      return topLevelUseLiveQuery.database = r, n.apply(void 0, e);
    };
    var useDocument = topLevelUseLiveDocument;
    function useFireproof2(e, t, r, n) {
      var a = this, o = (e === void 0 && (e = "useFireproof"), t === void 0 && (t = function(e2) {
      }), r === void 0 && (r = null), n === void 0 && (n = {}), react.useState(false)), u = o[0], i = o[1], s = initializeDatabase(e, t, n), c = s.database;
      return react.useEffect(function() {
        __awaiter(a, void 0, void 0, function() {
          return __generator(this, function(e2) {
            switch (e2.label) {
              case 0:
                return u || s.setupStarted ? [2] : (s.setupStarted = true, r && c.clock.length === 0 ? [4, r(c)] : [3, 2]);
              case 1:
                e2.sent(), e2.label = 2;
              case 2:
                return i(true), [2];
            }
          });
        });
      }, [e]), {useLiveQuery: function(e2, r2, t2) {
        var n2 = this;
        r2 === void 0 && (r2 = {});
        var a2 = (t2 = react.useState({rows: t2 = t2 === void 0 ? [] : t2, proof: {}, docs: t2.map(function(e3) {
          return e3.doc;
        })}))[0], o2 = t2[1], u2 = (t2 = react.useState(null))[0], i2 = t2[1], s2 = react.useCallback(function() {
          return __awaiter(n2, void 0, void 0, function() {
            var t3;
            return __generator(this, function(e3) {
              switch (e3.label) {
                case 0:
                  return u2 ? [4, u2.query(r2)] : [3, 2];
                case 1:
                  t3 = e3.sent(), o2(__assign(__assign({}, t3), {docs: t3.rows.map(function(e4) {
                    return e4.doc;
                  })})), e3.label = 2;
                case 2:
                  return [2];
              }
            });
          });
        }, [u2, JSON.stringify(r2)]);
        return react.useEffect(function() {
          return c.subscribe(function() {
            s2();
          });
        }, [c, s2]), react.useEffect(function() {
          s2();
        }, [u2]), react.useEffect(function() {
          i2(new core.Index(c, null, e2));
        }, [e2.toString()]), a2;
      }, useDocument: function(r2) {
        var e2 = this, n2 = r2._id, t2 = (o2 = react.useState(r2))[0], a2 = o2[1], o2 = react.useCallback(function() {
          return __awaiter(e2, void 0, void 0, function() {
            return __generator(this, function(e3) {
              switch (e3.label) {
                case 0:
                  return [4, c.put(__assign(__assign({}, t2), {_id: n2}))];
                case 1:
                  return [2, e3.sent()];
              }
            });
          });
        }, [n2, t2]), u2 = react.useCallback(function() {
          return __awaiter(e2, void 0, void 0, function() {
            var t3;
            return __generator(this, function(e3) {
              switch (e3.label) {
                case 0:
                  return t3 = a2, [4, c.get(n2).catch(function() {
                    return r2;
                  })];
                case 1:
                  return t3.apply(void 0, [e3.sent()]), [2];
              }
            });
          });
        }, [n2, r2]);
        return react.useEffect(function() {
          return c.subscribe(function(e3) {
            e3.find(function(e4) {
              return e4.key === n2;
            }) && u2();
          });
        }, [n2, u2]), react.useEffect(function() {
          u2();
        }, []), [t2, function(t3) {
          return a2(t3 ? function(e3) {
            return __assign(__assign({}, e3), t3);
          } : r2);
        }, o2];
      }, database: c, ready: u};
    }
    exports.FireproofCtx = FireproofCtx, exports.useDocument = useDocument, exports.useFireproof = useFireproof2, exports.useLiveQuery = useLiveQuery;
  });

  // react-shim.js
  var React = __toModule(require_react());

  // src/app.jsx
  var import_react_dom = __toModule(require_react_dom());
  var import_use_fireproof = __toModule(require_dist());
  var App = () => {
    console.log("App");
    const {database, useLiveQuery, useDocument} = (0, import_use_fireproof.useFireproof)();
    console.log("database", database);
    const items = useLiveQuery("type", {key: "todo"}).docs;
    const [doc, setDoc, saveDoc] = useDocument({message: "new todo", type: "todo"});
    console.log("items", items);
    return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("h1", null, "Welcome to Tomato Park"), /* @__PURE__ */ React.createElement("form", null, /* @__PURE__ */ React.createElement("input", {
      value: doc.message,
      onChange: (e) => setDoc({message: e.target.value})
    }), /* @__PURE__ */ React.createElement("button", {
      onClick: (e) => {
        e.preventDefault();
        saveDoc();
      }
    }, "Save")), /* @__PURE__ */ React.createElement("ul", null, items.map((item) => /* @__PURE__ */ React.createElement("li", {
      key: item.key
    }, item.message))));
  };
  import_react_dom.default.render(/* @__PURE__ */ React.createElement(App, null), document.getElementById("root"));
})();
//# sourceMappingURL=app.js.map
